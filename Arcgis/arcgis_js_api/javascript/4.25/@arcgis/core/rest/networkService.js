/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import t from"../request.js";import e from"../core/Error.js";import{L as r}from"../chunks/Logger.js";import{a as o,i as s}from"../chunks/maybe.js";import{g as i}from"../chunks/object.js";import{removeTrailingSlash as n}from"../core/urlUtils.js";import{a,p}from"../chunks/utils4.js";import{_ as u}from"../chunks/tslib.es6.js";import{JSONSupport as l}from"../core/JSONSupport.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"../chunks/ensureType.js";import{e as d}from"../chunks/enumeration.js";import{r as m}from"../chunks/reader.js";import{subclass as h}from"../core/accessorSupport/decorators/subclass.js";import{w as v}from"../chunks/writer.js";import{i as f,b as g,u as y,a as k}from"../chunks/networkEnums.js";import T from"./support/TravelMode.js";import"../config.js";import"../kernel.js";import"../chunks/string.js";import"../core/promiseUtils.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../chunks/ArrayPool.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../chunks/jsonMap.js";import"../core/Clonable.js";let j=class extends l{constructor(t){super(t),this.dataType=null,this.name=null,this.parameterNames=null,this.restrictionUsageParameterName=null,this.timeNeutralAttributeName=null,this.trafficSupport=null,this.units=null,this.usageType=null}};u([c({type:String})],j.prototype,"dataType",void 0),u([d(f,{ignoreUnknown:!1})],j.prototype,"name",void 0),u([c({type:[String]})],j.prototype,"parameterNames",void 0),u([c({type:String})],j.prototype,"restrictionUsageParameterName",void 0),u([d(g,{ignoreUnknown:!1})],j.prototype,"timeNeutralAttributeName",void 0),u([c({type:String})],j.prototype,"trafficSupport",void 0),u([c({type:String})],j.prototype,"units",void 0),u([d(y)],j.prototype,"usageType",void 0),j=u([h("esri.rest.support.NetworkAttribute")],j);const w=j;let M=class extends l{constructor(t){super(t),this.buildTime=null,this.name=null,this.networkAttributes=null,this.networkSources=null,this.state=null}};u([c({type:Number})],M.prototype,"buildTime",void 0),u([c({type:String})],M.prototype,"name",void 0),u([c({type:[w]})],M.prototype,"networkAttributes",void 0),u([c()],M.prototype,"networkSources",void 0),u([c({type:String})],M.prototype,"state",void 0),M=u([h("esri.rest.support.NetworkDataset")],M);const S=M;let N=class extends l{constructor(t){super(t),this.accumulateAttributeNames=null,this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsLengthUnits=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}readAccumulateAttributes(t){return o(t)?null:t.map((t=>f.fromJSON(t)))}writeAccumulateAttributes(t,e,r){!o(t)&&t.length&&(e[r]=t.map((t=>f.toJSON(t))))}};u([c()],N.prototype,"accumulateAttributeNames",void 0),u([m("accumulateAttributeNames")],N.prototype,"readAccumulateAttributes",null),u([v("accumulateAttributeNames")],N.prototype,"writeAccumulateAttributes",null),u([c()],N.prototype,"currentVersion",void 0),u([c()],N.prototype,"defaultTravelMode",void 0),u([c()],N.prototype,"directionsLanguage",void 0),u([d(k)],N.prototype,"directionsLengthUnits",void 0),u([c()],N.prototype,"directionsSupportedLanguages",void 0),u([d(g,{ignoreUnknown:!1})],N.prototype,"directionsTimeAttribute",void 0),u([c()],N.prototype,"hasZ",void 0),u([d(f,{ignoreUnknown:!1})],N.prototype,"impedance",void 0),u([c({type:S})],N.prototype,"networkDataset",void 0),u([c({type:[T]})],N.prototype,"supportedTravelModes",void 0),N=u([h("esri.rest.support.NetworkServiceDescription")],N);const b=N,A=r.getLogger("esri.rest.networkService");function U(t,e,r,o){o[r]=[e.length,e.length+t.length],t.forEach((t=>{e.push(t.geometry)}))}function L(t,e){for(let r=0;r<e.length;r++){const o=t[e[r]];if(o&&o.length)for(const t of o)t.z=void 0}A.warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function x(t,e){for(let r=0;r<e.length;r++){const o=t[e[r]];if(o&&o.length)for(const t of o)if(s(t)&&t.hasZ)return!0}return!1}async function O(r,o,s){if(!r)throw new e("network-service:missing-url","Url to Network service is missing");const u=a({f:"json",token:o},s),{data:l}=await t(r,u);l.supportedTravelModes||(l.supportedTravelModes=[]);for(let t=0;t<l.supportedTravelModes.length;t++)l.supportedTravelModes[t].id||(l.supportedTravelModes[t].id=l.supportedTravelModes[t].itemId);const c=l.currentVersion>=10.4?async function(r,o,s){try{const e=a({f:"json",token:o},s),i=n(r)+"/retrieveTravelModes",{data:{supportedTravelModes:p,defaultTravelMode:u}}=await t(i,e);return{supportedTravelModes:p,defaultTravelMode:u}}catch(t){throw new e("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:t})}}(r,o,s):async function(e,r){const o=a({f:"json"},r),{data:s}=await t(e.replace(/\/rest\/.*$/i,"/info"),o);if(!s||!s.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:u}=s,l=n(u)+"/sharing/rest/portals/self",{data:c}=await t(l,o),d=i("helperServices.routingUtilities.url",c);if(!d)return{supportedTravelModes:[],defaultTravelMode:null};const m=p(u),h=/\/solve$/i.test(m.path)?"Route":/\/solveclosestfacility$/i.test(m.path)?"ClosestFacility":"ServiceAreas",v=a({f:"json",serviceName:h},r),f=n(d)+"/GetTravelModes/execute",g=await t(f,v),y=[];let k=null;if(g?.data?.results?.length){const t=g.data.results;for(const e of t)if("supportedTravelModes"===e.paramName){if(e.value?.features)for(const{attributes:t}of e.value.features)if(t){const e=JSON.parse(t.TravelMode);y.push(e)}}else"defaultTravelMode"===e.paramName&&(k=e.value)}return{supportedTravelModes:y,defaultTravelMode:k}}(r,s),{defaultTravelMode:d,supportedTravelModes:m}=await c;return l.defaultTravelMode=d,l.supportedTravelModes=m,b.fromJSON(l)}export{U as collectGeometries,L as dropZValuesOffInputGeometry,O as fetchServiceDescription,x as isInputGeometryZAware};
