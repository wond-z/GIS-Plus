/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"../core/Error.js";import{HandleOwnerMixin as r}from"../core/HandleOwner.js";import n from"../core/Loadable.js";import{L as o}from"../chunks/Logger.js";import{i as s,a as i}from"../chunks/maybe.js";import{EsriPromiseMixin as a}from"../core/Promise.js";import{whenOrAbort as c,eachAlwaysValues as l,isAborted as p,throwIfAborted as u}from"../core/promiseUtils.js";import{watch as h}from"../core/reactiveUtils.js";import{property as f}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"../chunks/ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{d as g,a as d,t as x,n as y,s as w,b as j,e as b,Z as v,g as A,f as k}from"../chunks/vec3.js";import M from"./Extent.js";import R from"./Geometry.js";import F from"./Point.js";import L from"./Polygon.js";import{c as P,a as O,b as C,d as z,f as U}from"../chunks/axisAngleDegrees.js";import S,{M as T}from"./support/MeshComponent.js";import{i as $,u as I,g as B,a as E,M as G}from"../chunks/georeference.js";import{t as _}from"../chunks/triangulationUtils.js";import{projectPointToVector as Z,computeTranslationToOriginAndRotation as q}from"./projection.js";import{removeFile as D,makeRelative as V}from"../core/urlUtils.js";import{f as W}from"../chunks/mat3.js";import{c as H}from"../chunks/mat3f64.js";import{c as N}from"../chunks/mat4f64.js";import{c as J}from"../chunks/projectionEllipsoid.js";import{p as K,a as Q,b as X,c as Y,d as ee,e as te}from"../chunks/projection.js";import{a as re}from"../chunks/mat4.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/metadata.js";import"../chunks/ArrayPool.js";import"../chunks/tracking.js";import"../chunks/watch.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../chunks/WatchUpdatingTracking.js";import"../chunks/common.js";import"./SpatialReference.js";import"../core/JSONSupport.js";import"../chunks/writer.js";import"./support/webMercatorUtils.js";import"../chunks/Ellipsoid.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/extentUtils.js";import"../chunks/zmUtils.js";import"../chunks/mathUtils.js";import"../chunks/quat.js";import"../chunks/quatf64.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/imageUtils.js";import"../chunks/persistableUrlUtils.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";import"../chunks/vec32.js";import"../chunks/earcut.js";import"../chunks/deduplicate.js";import"../chunks/SimpleObservable.js";import"./Multipoint.js";import"../chunks/pe.js";import"../chunks/assets.js";import"../request.js";import"../kernel.js";import"./Polyline.js";import"../chunks/aaBoundingRect.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";import"../chunks/zscale.js";const ne=o.getLogger("esri.geometry.support.meshUtils.centerAt"),oe=g(),se=g();function ie(e){const t=D(e.url);return r=>{const n=V(r,t,t),o=n?n.replace(/^ *\.\//,""):null;return(o?e.files.get(o):null)??r}}async function ae(e,r){return e instanceof Blob?ce.fromBlob(e):"string"==typeof e?new ce(e):Array.isArray(e)?async function(e,r){const n=new Map;let o=null;const s=await l(e.map((async e=>({name:e.name,source:await ae(e instanceof Blob?e:e.source,r)})))),a=[];for(const e of s)e&&(p(r)?e.source.dispose():a.push(e));u(r);for(const{name:e,source:t}of a)(i(o)||/\.(gltf|glb)/i.test(e))&&(o=t.url),n.set(e,t.url),t.files&&t.files.forEach(((e,t)=>n.set(t,e)));if(i(o))throw new t("mesh-load-external:missing-files","Missing files to load external mesh source");return new ce(o,(()=>a.forEach((({source:e})=>e.dispose()))),n)}(e,r):async function(e,t){const{default:r}=await c(import("../request.js").then((e=>e.r)),t),n="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await r(e,{responseType:"array-buffer"})).data))):e.multipart;return ce.fromBlob(new Blob(n))}(e,r)}class ce{constructor(e,t=(()=>{}),r=new Map){this.url=e,this.dispose=t,this.files=r}static fromBlob(e){const t=URL.createObjectURL(e);return new ce(t,(()=>URL.revokeObjectURL(t)))}}function le(e,t){if(e)for(let r=0;r<e.length;r+=3)for(let n=0;n<3;n++)e[r+n]+=t[n]}const pe=g(),ue=N(),he=H(),fe={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function me(e,t,r){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null==t)return;const r="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];ye[0]=r[0],ye[4]=r[1],ye[8]=r[2];for(let t=0;t<e.position.length;t+=3){for(let r=0;r<3;r++)xe[r]=e.position[t+r];x(xe,xe,ye);for(let r=0;r<3;r++)e.position[t+r]=xe[r]}if(r[0]!==r[1]||r[1]!==r[2]){ye[0]=1/r[0],ye[4]=1/r[1],ye[8]=1/r[2];for(let t=0;t<e.normal.length;t+=3){for(let r=0;r<3;r++)xe[r]=e.normal[t+r];x(xe,xe,ye),y(xe,xe);for(let r=0;r<3;r++)e.normal[t+r]=xe[r]}}}(e,r?.size);const{vertexAttributes:n,transform:o}=E(e,t,r);return{vertexAttributes:new T({...n,uv:e.uv}),transform:o,components:[new S({faces:e.faces,material:r&&r.material||null})],spatialReference:t.spatialReference}}const ge={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},de={south:0,east:1,north:2,west:3,up:4,down:5},xe=g(),ye=H(),we=o.getLogger("esri.geometry.support.meshUtils.rotate");function je(e,t,r,n=v){if(!i(e)){re(ke,C(t),z(t));for(let t=0;t<e.length;t+=r){for(let r=0;r<3;r++)be[r]=e[t+r]-n[r];b(be,be,ke);for(let r=0;r<3;r++)e[t+r]=be[r]+n[r]}}}const be=g(),ve=g(),Ae=P(),ke=N(),Me=H(),Re=g(),Fe=o.getLogger("esri.geometry.support.meshUtils.scale");function Le(e,t,r=v){if(e)for(let n=0;n<e.length;n+=3){for(let t=0;t<3;t++)Pe[t]=e[n+t]-r[t];A(Pe,Pe,t);for(let t=0;t<3;t++)e[n+t]=Pe[t]+r[t]}}const Pe=g(),Oe=g(),Ce=g();var ze;const Ue="esri.geometry.Mesh";let Se=ze=class extends(r(n.LoadableMixin(a(R)))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new T,this.type="mesh"}initialize(){(i(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(h((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&s(this.external)&&s(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new F({x:0,y:0,z:0,spatialReference:t})};const r=s(this.transform)?this.transform.project(e,t):e;let n=1/0,o=1/0,i=1/0,a=-1/0,c=-1/0,l=-1/0,p=0,u=0,h=0;const f=r.length,m=1/(f/3);let g=0;for(;g<f;){const e=r[g++],t=r[g++],s=r[g++];n=Math.min(n,e),o=Math.min(o,t),i=Math.min(i,s),a=Math.max(a,e),c=Math.max(c,t),l=Math.max(l,s),p+=m*e,u+=m*t,h+=m*s}return{extent:new M({xmin:n,ymin:o,zmin:i,xmax:a,ymax:c,zmax:l,spatialReference:t}),center:new F({x:p,y:u,z:h,spatialReference:t})}}get anchor(){if(s(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this._boundingInfo;return new F({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return s(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&s(this.external)&&s(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(S.from(e)),this.notifyChange("components")):o.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}o.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else o.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,r,n){return U(Te.x,e,$e),U(Te.y,t,Ie),U(Te.z,r,Be),O($e,Ie,$e),O($e,Be,$e),function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const n=e.spatialReference;if(s(e.transform)){null!=r?.geographic&&r.geographic!==e.transform.geographic&&we.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=r?.origin??e.transform.getOriginPoint(n);!function(e,t,r){const n=w(be,r.x,r.y,r.z),o=j(be,n,e.origin);e.applyLocalInverse(o,ve),e.rotation=O(e.rotation,t,P()),e.applyLocalInverse(o,o),j(o,o,ve),e.translation=d(g(),e.translation,o)}(e.transform,t,o)}else{const n=r?.origin??e.origin;$(e.spatialReference,r)?function(e,t,r){const n=e.spatialReference,o=J(n),i=Re;Z(r,i,o)||Z(e.origin,i,o);const a=e.vertexAttributes.position,c=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,p=new Float64Array(a.length),u=s(c)?new Float32Array(c.length):null,h=s(l)?new Float32Array(l.length):null;q(o,i,ke,o),W(Me,ke);const f=Ae;x(z(Ae),z(t),Me),f[3]=t[3],K(a,n,p),s(c)&&s(u)&&Q(c,a,p,n,u),s(l)&&s(h)&&X(l,a,p,n,h),je(p,f,3,i),Y(p,a,n),s(c)&&s(u)&&(je(u,f,3),ee(u,a,p,n,c)),s(l)&&s(h)&&(je(h,f,4),te(h,a,p,n,l)),e.vertexAttributesChanged()}(e,t,n):function(e,t,r){const n=Re;if(!Z(r,n,e.spatialReference)){const t=e.origin;n[0]=t.x,n[1]=t.y,n[2]=t.z,we.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}je(e.vertexAttributes.position,t,3,n),je(e.vertexAttributes.normal,t,3),je(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,n)}}(this,$e,n),this}offset(e,t,r,n){return this.loaded?(Ee[0]=e,Ee[1]=t,Ee[2]=r,function(e,t,r){e.vertexAttributes&&e.vertexAttributes.position&&(s(e.transform)?(null!=r?.geographic&&r.geographic!==e.transform.geographic&&o.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const r=e.origin;e.origin=d(g(),r,t)}(e.transform,t)):$(e.spatialReference,r)?function(e,t){const r=e.spatialReference,n=e.vertexAttributes.position,o=e.vertexAttributes.normal,i=e.vertexAttributes.tangent,a=new Float64Array(n.length),c=s(o)?new Float32Array(o.length):null,l=s(i)?new Float32Array(i.length):null,p=e.extent.center,u=pe;q(r,[p.x,p.y,p.z],ue,J(r)),W(he,ue),x(u,t,he),K(n,r,a),s(o)&&s(c)&&Q(o,n,a,r,c),s(i)&&s(l)&&X(i,n,a,r,l),le(a,u),Y(a,n,r),s(o)&&s(c)&&ee(c,n,a,r,o),s(i)&&s(l)&&te(l,n,a,r,i),e.vertexAttributesChanged()}(e,t):function(e,t){le(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t))}(this,Ee,n),this):(o.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const n=e.spatialReference;if(s(e.transform)){null!=r?.geographic&&r.geographic!==e.transform.geographic&&Fe.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=r?.origin??e.transform.getOriginPoint(n);!function(e,t,r){const n=w(Pe,r.x,r.y,r.z),o=j(Pe,n,e.origin);e.applyLocalInverse(o,Oe);const s=A(g(),e.scale,t);e.scale=s,e.applyLocalInverse(o,o),j(o,o,Oe),e.translation=d(g(),e.translation,o)}(e.transform,t,o)}else{const n=$(e.spatialReference,r),o=r&&r.origin||e.origin;n?function(e,t,r){const n=e.spatialReference,o=J(n),i=Ce;Z(r,i,o)||Z(e.origin,i,o);const a=e.vertexAttributes.position,c=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,p=new Float64Array(a.length),u=s(c)?new Float32Array(c.length):null,h=s(l)?new Float32Array(l.length):null;K(a,n,p),s(c)&&s(u)&&Q(c,a,p,n,u),s(l)&&s(h)&&X(l,a,p,n,h),Le(p,t,i),Y(p,a,n),s(c)&&s(u)&&ee(u,a,p,n,c),s(l)&&s(h)&&te(h,a,p,n,l),e.vertexAttributesChanged()}(e,t,o):function(e,t,r){const n=Ce;if(!Z(r,n,e.spatialReference)){const t=e.origin;n[0]=t.x,n[1]=t.y,n[2]=t.z,Fe.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Le(e.vertexAttributes.position,t,n),e.vertexAttributesChanged()}(e,t,o)}}(this,e,t),this):(o.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(function(e,t,r){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const n=r?.origin??e.origin;s(e.transform)?(null!=r?.geographic&&r.geographic!==e.transform.geographic&&ne.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,r){const n=t.x-r.x,o=t.y-r.y,s=t.hasZ&&r.hasZ?t.z-r.z:0,i=e.origin;e.origin=[i[0]+n,i[1]+o,i[2]+s]}(e.transform,t,n)):$(e.spatialReference,r)?function(e,t,r){const n=I(e.vertexAttributes,r,{geographic:!0}),{position:o,normal:s,tangent:i}=B(n,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=s,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}(e,t,n):function(e,t,r){const n=se,o=oe;if(Z(t,o,e.spatialReference)){if(!Z(r,n,e.spatialReference)){const t=e.origin;n[0]=t.x,n[1]=t.y,n[2]=t.z,ne.error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,r){if(e)for(let n=0;n<e.length;n+=3)for(let o=0;o<3;o++)e[n+o]+=t[o]-r[o]})(e.vertexAttributes.position,o,n),e.vertexAttributesChanged()}else ne.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,n)}(this,e,t),this):(o.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return s(this.external)&&this.addResolvingPromise(async function(e,t,r){const{loadGLTFMesh:n}=await c(import("../chunks/loadGLTFMesh.js"),r),o=await ae(t,r),i=n(new F({x:0,y:0,z:0,spatialReference:e.spatialReference}),o.url,{resolveFile:ie(o),useTransform:!0,signal:s(r)?r.signal:null});i.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:a,components:l}=await i;e.vertexAttributes=a,e.components=l}(this,this.external.source,e)),Promise.resolve(this)}updateExternalSource(e){this._set("external",e)}clone(){let e=null;if(this.components){const t=new Map,r=new Map;e=this.components.map((e=>e.cloneWithDeduplication(t,r)))}const t={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:s(this.transform)?this.transform.clone():null,external:s(this.external)?{source:this.external.source,extent:s(this.external.extent)?this.external.extent.clone():null}:null};return new ze(t)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=import("../chunks/gltfexport.js"),r=this.load(),n=await Promise.all([t,r]),{toBinaryGLTF:o}=n[0];return o(this,e)}static createBox(e,t){if(!(e instanceof F))return o.getLogger(Ue).error(".createBox()","expected location to be a Point instance"),null;const r=new ze(me(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:r}=ge,n=4*e.length,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(2*e.length*3);let c=0,l=0,p=0,u=0;for(let n=0;n<e.length;n++){const h=e[n],f=c/3;for(const e of t)a[u++]=f+e;const m=h.corners;for(let e=0;e<4;e++){const t=m[e];let n=0;i[p++]=.25*r[e][0]+h.uvOrigin[0],i[p++]=h.uvOrigin[1]-.25*r[e][1];for(let e=0;e<3;e++)0!==h.axis[e]?(o[c++]=.5*h.axis[e],s[l++]=h.axis[e]):(o[c++]=.5*t[n++],s[l++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const r=e.components[0],n=r.faces,o=de[t],i=6*o,a=new Array(6),c=new Array(n.length-6);let l=0,p=0;for(let e=0;e<n.length;e++)e>=i&&e<i+6?a[l++]=n[e]:c[p++]=n[e];if(s(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),r=4*o*2,n=[0,1,1,1,1,0,0,0];for(let e=0;e<n.length;e++)t[r+e]=n[e];e.vertexAttributes.uv=t}return e.components=[new S({faces:a,material:r.material}),new S({faces:c})],e}(r,t.imageFace):r}static createSphere(e,t){return e instanceof F?new ze(me(function(e=0){const t=Math.round(8*2**e),r=2*t,n=(t-1)*(r+1)+2*r,o=new Float64Array(3*n),s=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array((t-1)*r*2*3);let c=0,l=0,p=0,u=0;for(let e=0;e<=t;e++){const n=e/t*Math.PI+.5*Math.PI,h=Math.cos(n),f=Math.sin(n);xe[2]=f;const m=0===e||e===t,g=m?r-1:r;for(let n=0;n<=g;n++){const f=n/g*2*Math.PI;xe[0]=-Math.sin(f)*h,xe[1]=Math.cos(f)*h;for(let e=0;e<3;e++)o[c]=.5*xe[e],s[c]=xe[e],++c;i[l++]=(n+(m?.5:0))/r,i[l++]=e/t,0!==e&&n!==r&&(e!==t&&(a[p++]=u,a[p++]=u+1,a[p++]=u-r),1!==e&&(a[p++]=u,a[p++]=u-r,a[p++]=u-r-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(t&&t.densificationFactor||0),e,t)):(o.getLogger(Ue).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof F?new ze(me(function(e=0){const t=Math.round(16*2**e),r=4*(t+1)+2*t,n=new Float64Array(3*r),o=new Float32Array(3*r),s=new Float32Array(2*r),i=new Uint32Array(4*t*3);let a=0,c=0,l=0,p=0,u=0;for(let e=0;e<=5;e++){const r=0===e||5===e,h=e<=1||e>=4,f=2===e||4===e,m=r?t-1:t;for(let g=0;g<=m;g++){const d=g/m*2*Math.PI,x=r?0:.5;xe[0]=x*Math.sin(d),xe[1]=x*-Math.cos(d),xe[2]=e<=2?.5:-.5;for(let t=0;t<3;t++)n[a++]=xe[t],o[c++]=h?2===t?e<=1?1:-1:0:2===t?0:xe[t]/x;s[l++]=(g+(r?.5:0))/t,s[l++]=e<=1?1*e/3:e<=3?1*(e-2)/3+1/3:1*(e-4)/3+2/3,f||0===e||g===t||(5!==e&&(i[p++]=u,i[p++]=u+1,i[p++]=u-t),1!==e&&(i[p++]=u,i[p++]=u-t,i[p++]=u-t-1)),u++}}return{position:n,normal:o,uv:s,faces:i}}(t&&t.densificationFactor||0),e,t)):(o.getLogger(Ue).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){if(!(e instanceof F))return o.getLogger(Ue).error(".createPlane()","expected location to be a Point instance"),null;const r=t?.facing??"up",n=function(e,t){const r="number"==typeof t?t:null!=t?t.width:1,n="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:r,depth:n};case"north":case"south":return{width:r,height:n};case"east":case"west":return{depth:r,height:n}}}(r,t?.size);return new ze(me(function(e){const t=fe.facingAxisOrderSwap[e],r=fe.position,n=fe.normal,o=new Float64Array(r.length),s=new Float32Array(n.length);let i=0;for(let e=0;e<4;e++){const e=i;for(let a=0;a<3;a++){const c=t[a],l=Math.abs(c)-1,p=c>=0?1:-1;o[i]=r[e+l]*p,s[i]=n[e+l]*p,i++}}return{position:o,normal:s,uv:new Float32Array(fe.uv),faces:new Uint32Array(fe.faces),isPlane:!0}}(r),e,{...t,size:n}))}static createFromPolygon(e,t){if(!(e instanceof L))return o.getLogger(Ue).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=_(e);return new ze({vertexAttributes:new T({position:r.position}),components:[new S({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,r,n){if(!(e instanceof F))throw o.getLogger(Ue).error(".createfromGLTF()","expected location to be a Point instance"),new t("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:s}=await c(import("../chunks/loadGLTFMesh.js"),n);return new ze(await s(e,r,n))}static createWithExternalSource(e,t,r){const n=r?.extent??null,o=r?.transform?.clone()??new G;o.origin=[e.x,e.y,e.z??0];const s=e.spatialReference;return new ze({external:{source:t,extent:n},transform:o,spatialReference:s})}static createIncomplete(e,r){const n=r?.transform?.clone()??new G;n.origin=[e.x,e.y,e.z??0];const o=e.spatialReference,s=new ze({transform:n,spatialReference:o});return s.addResolvingPromise(Promise.reject(new t("mesh-incomplete","Mesh resources are not complete"))),s}};e([f({type:[S],json:{write:!0}})],Se.prototype,"components",void 0),e([f({type:G,json:{write:!0}})],Se.prototype,"transform",void 0),e([f({constructOnly:!0})],Se.prototype,"external",void 0),e([f({readOnly:!0})],Se.prototype,"hasExtent",null),e([f({readOnly:!0})],Se.prototype,"_boundingInfo",null),e([f({readOnly:!0})],Se.prototype,"anchor",null),e([f({readOnly:!0})],Se.prototype,"origin",null),e([f({readOnly:!0,json:{read:!1}})],Se.prototype,"extent",null),e([f({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Se.prototype,"hasZ",void 0),e([f({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Se.prototype,"hasM",void 0),e([f({type:T,nonNullable:!0,json:{write:!0}})],Se.prototype,"vertexAttributes",void 0),Se=ze=e([m(Ue)],Se);const Te={x:k(1,0,0),y:k(0,1,0),z:k(0,0,1)},$e=P(),Ie=P(),Be=P(),Ee=g(),Ge=Se;export{Ge as default};
