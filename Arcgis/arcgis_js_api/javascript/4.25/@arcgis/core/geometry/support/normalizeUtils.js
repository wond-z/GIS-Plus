/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import t from"../../config.js";import s from"../../core/Error.js";import{L as e}from"../../chunks/Logger.js";import{a as o,i as n}from"../../chunks/maybe.js";import r from"../Polygon.js";import i from"../Polyline.js";import{g as c,c as p,o as l,u}from"../../chunks/normalizeUtilsCommon.js";import{g as f}from"../SpatialReference.js";import{geographicToWebMercator as m,webMercatorToGeographic as a}from"./webMercatorUtils.js";import{c as h,s as g}from"../../chunks/simplify.js";import"../../chunks/object.js";import"../../core/lang.js";import"../../chunks/string.js";import"../../chunks/tslib.es6.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ensureType.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/tracking.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/ArrayPool.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/Ellipsoid.js";import"../../chunks/extentUtils.js";import"../../chunks/zmUtils.js";import"./jsonUtils.js";import"../Multipoint.js";import"../../geometry.js";import"../../chunks/typeUtils.js";import"../../chunks/jsonMap.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/utils4.js";import"../../chunks/utils5.js";const j=e.getLogger("esri.geometry.support.normalizeUtils");function y(t){const s=[];let e=0,o=0;for(let n=0;n<t.length;n++){const r=t[n];let i=null;for(let t=0;t<r.length;t++)i=r[t],s.push(i),0===t?(e=i[0],o=e):(e=Math.min(e,i[0]),o=Math.max(o,i[0]));i&&s.push([(e+o)/2,0])}return s}function x(t,e){if(!(t instanceof i||t instanceof r)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw j.error(t),new s(t)}const o=c(t),n=[];for(const t of o){const s=[];n.push(s),s.push([t[0][0],t[0][1]]);for(let o=0;o<t.length-1;o++){const n=t[o][0],r=t[o][1],i=t[o+1][0],c=t[o+1][1],p=Math.sqrt((i-n)*(i-n)+(c-r)*(c-r)),l=(c-r)/p,u=(i-n)/p,f=p/e;if(f>1){for(let t=1;t<=f-1;t++){const o=t*e,i=u*o+n,c=l*o+r;s.push([i,c])}const t=(p+Math.floor(f-1)*e)/2,o=u*t+n,i=l*t+r;s.push([o,i])}s.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new r({rings:n,spatialReference:t.spatialReference}):new i({paths:n,spatialReference:t.spatialReference})}function k(t,s,e){if(s){const s=x(t,1e6);t=a(s,!0)}return e&&(t=u(t,e)),t}function d(t,s,e){if(Array.isArray(t)){const o=t[0];if(o>s){const e=l(o,s);t[0]=o+e*(-2*s)}else if(o<e){const s=l(o,e);t[0]=o+s*(-2*e)}}else{const o=t.x;if(o>s){const e=l(o,s);t=t.clone().offset(e*(-2*s),0)}else if(o<e){const s=l(o,e);t=t.clone().offset(s*(-2*e),0)}}return t}async function w(s,e,a){if(!Array.isArray(s))return w([s],e);e&&"string"!=typeof e&&j.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const y="string"==typeof e?e:e?.url??t.geometryServiceUrl;let x,M,U,b,R,P,S,A,L=0;const z=[],v=[];for(const t of s)if(o(t))v.push(t);else if(x||(x=t.spatialReference,M=f(x),U=x.isWebMercator,P=U?102100:4326,b=p[P].maxX,R=p[P].minX,S=p[P].plus180Line,A=p[P].minus180Line),M)if("mesh"===t.type)v.push(t);else if("point"===t.type)v.push(d(t.clone(),b,R));else if("multipoint"===t.type){const s=t.clone();s.points=s.points.map((t=>d(t,b,R))),v.push(s)}else if("extent"===t.type){const s=t.clone()._normalize(!1,!1,M);v.push(s.rings?new r(s):s)}else if(t.extent){const s=t.extent,e=l(s.xmin,R)*(2*b);let o=0===e?t.clone():u(t.clone(),e);s.offset(e,0),s.intersects(S)&&s.xmax!==b?(L=s.xmax>L?s.xmax:L,o=k(o,U),z.push(o),v.push("cut")):s.intersects(A)&&s.xmin!==R?(L=s.xmax*(2*b)>L?s.xmax*(2*b):L,o=k(o,U,360),z.push(o),v.push("cut")):v.push(o)}else v.push(t.clone());else v.push(t);let E=l(L,b),T=-90;const q=E,C=new i;for(;E>0;){const t=360*E-180;C.addPath([[t,T],[t,-1*T]]),T*=-1,E--}if(z.length>0&&q>0){const t=function(t,s){let e=-1;for(let o=0;o<s.cutIndexes.length;o++){const n=s.cutIndexes[o],r=s.geometries[o],i=c(r);for(let t=0;t<i.length;t++){const s=i[t];s.some((e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<s.length;t++){const o=s[t][0];e=o>e?o:e}e=Number(e.toFixed(9));const o=-360*l(e,180);for(let e=0;e<s.length;e++){const s=r.getPoint(t,e);r.setPoint(t,e,s.clone().offset(o,0))}return!0}}))}if(n===e){if("polygon"===t[0].type)for(const s of c(r))t[n]=t[n].addRing(s);else if("polyline"===t[0].type)for(const s of c(r))t[n]=t[n].addPath(s)}else e=n,t[n]=r}return t}(z,await h(y,z,C,a)),e=[],o=[];for(let r=0;r<v.length;r++){const i=v[r];if("cut"!==i)o.push(i);else{const i=t.shift(),c=s[r];n(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(e.push(i),o.push("simplify")):o.push(U?m(i):i)}}if(!e.length)return o;const r=await g(y,e,a),i=[];for(let t=0;t<o.length;t++){const s=o[t];"simplify"!==s?i.push(s):i.push(U?m(r.shift()):r.shift())}return i}const I=[];for(let t=0;t<v.length;t++){const s=v[t];if("cut"!==s)I.push(s);else{const t=z.shift();I.push(!0===U?m(t):t)}}return I}function M(t){if(!t)return null;const s=t.extent;if(!s)return null;const e=t.spatialReference&&f(t.spatialReference);if(!e)return s;const[o,n]=e.valid,r=2*n,{width:i}=s;let c,{xmin:p,xmax:l}=s;if([p,l]=[l,p],"extent"===t.type||0===i||i<=n||i>r||p<o||l>n)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;c=y(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;c=y(t.paths);break;case"multipoint":c=t.points}const u=s.clone();for(let t=0;t<c.length;t++){let s=c[t][0];s<0?(s+=n,l=Math.max(s,l)):(s-=n,p=Math.min(s,p))}return u.xmin=p,u.xmax=l,u.width<i?(u.xmin-=n,u.xmax-=n,u):s}function U(t,s){const e=f(s);if(e){const[s,o]=e.valid,n=o-s;if(t<s)for(;t<s;)t+=n;if(t>o)for(;t>o;)t-=n}return t}export{M as getDenormalizedExtent,w as normalizeCentralMeridian,U as normalizeMapX,x as straightLineDensify};
