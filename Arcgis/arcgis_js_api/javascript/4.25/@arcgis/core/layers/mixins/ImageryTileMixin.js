/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as e}from"../../rasterRenderers.js";import s from"../../request.js";import r from"../../core/Error.js";import{L as i}from"../../chunks/Logger.js";import{i as o,u as n,a,c as l}from"../../chunks/maybe.js";import{property as m}from"../../core/accessorSupport/decorators/property.js";import"../../core/lang.js";import{m as p}from"../../chunks/ensureType.js";import{subclass as c}from"../../core/accessorSupport/decorators/subclass.js";import u,{g as h}from"../../geometry/SpatialReference.js";import{s as d}from"../../chunks/arcgisLayerUrl.js";import{u as f}from"../../chunks/commonProperties.js";import y from"../support/DimensionalDefinition.js";import j from"../support/MultidimensionalSubset.js";import g from"../support/RasterFunction.js";import{R as x}from"../../chunks/RasterJobHandler.js";import b from"../support/TileInfo.js";import{JSONSupport as I}from"../../core/JSONSupport.js";import{EsriPromiseMixin as k}from"../../core/Promise.js";import{onAbort as R}from"../../core/promiseUtils.js";import{R as S}from"../support/RasterInfo.js";import{i as w,b as v,c as T,d as P,a as C,h as _,g as D}from"../../chunks/multidimensionalUtils.js";import{g as M,a as F,p as J,d as H,b as B}from"../../chunks/RawBlockCache.js";import{d as U,R as E}from"../../chunks/RasterSymbolizer.js";import{m as L,d as z,g as O}from"../../chunks/pixelUtils.js";import{l as W,g as V,p as A,s as N,a as q,b as G,c as $,d as Q,e as K,f as X}from"../../chunks/rasterProjectionHelper.js";import{d as Y,u as Z,c as tt}from"../../chunks/vectorFieldUtils.js";import et from"../../geometry/Extent.js";import st from"../../geometry/Point.js";import{c as rt}from"../../chunks/rasterFunctionHelper.js";import{n as it,b as ot,a as nt,c as at}from"../../chunks/rasterRendererHelper.js";import{c as lt}from"../../chunks/dataUtils.js";import"../../geometry/Geometry.js";import"../../chunks/reader.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../chunks/object.js";import"../../chunks/ArrayPool.js";import"../../chunks/tracking.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../config.js";import"../../chunks/string.js";import"../../chunks/writer.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../chunks/Ellipsoid.js";import"../../core/accessorSupport/decorators/cast.js";import"../../geometry/Polygon.js";import"../../chunks/extentUtils.js";import"../../geometry/Polyline.js";import"../../chunks/typeUtils.js";import"../../chunks/jsonMap.js";import"../../geometry/support/jsonUtils.js";import"../../renderers/ClassBreaksRenderer.js";import"../../symbols.js";import"../../symbols/CIMSymbol.js";import"../../chunks/enumeration.js";import"../support/fieldUtils.js";import"../../chunks/arcadeOnDemand.js";import"../../symbols/Symbol.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/common.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils2.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../chunks/opacityUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/lineMarkers.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils3.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../chunks/aaBoundingRect.js";import"../../symbols/Font.js";import"../../symbols/IconSymbol3DLayer.js";import"../../core/urlUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../symbols/LabelSymbol3D.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../kernel.js";import"../../core/Loadable.js";import"../../chunks/locale.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../portal/PortalGroup.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../core/Clonable.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../chunks/LegendOptions.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/sizeVariableUtils.js";import"../../chunks/visualVariableUtils.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../chunks/date.js";import"../../chunks/number.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../chunks/compilerUtils.js";import"../../chunks/lengthUtils.js";import"../../chunks/unitUtils.js";import"../../chunks/projectionEllipsoid.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties2.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/symbolConversion.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/UniqueValueRenderer.js";import"../../core/reactiveUtils.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils2.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils4.js";import"../../chunks/utils5.js";import"../../chunks/utils6.js";import"../../chunks/asyncUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/parser.js";import"../../chunks/mat4f32.js";import"../../chunks/mat4.js";import"../../chunks/_commonjsHelpers.js";import"../../chunks/assets.js";import"../../chunks/ItemCache.js";import"../../chunks/MemCache.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils7.js";import"../support/PixelBlock.js";import"../../TimeExtent.js";import"../../chunks/timeUtils.js";import"../../support/timeUtils.js";import"../../chunks/ElevationInfo.js";import"../../chunks/unitConversionUtils.js";import"../../core/workers/workers.js";import"../../core/workers/Connection.js";import"../../chunks/Queue.js";import"../../core/workers/RemoteClient.js";import"../../intl.js";import"../../chunks/messages.js";import"../support/LOD.js";import"../../chunks/TileKey.js";import"../../chunks/stretchUtils.js";import"../../chunks/pe.js";import"../../geometry/projection.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../../chunks/generateRendererUtils.js";let mt=class extends(k(I)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=W();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:b.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=V(t.spatialReference);return o(e)&&t.extent.width>=e/2}set url(t){this._set("url",d(t,i.getLogger(this.declaredClass)))}async open(t){throw new r("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,s,r={}){const i=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,e,s,i);return this.fetchPixels(o,i.size[0],i.size[1],r)}async identify(t,e={}){t=p(st,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:r}=e,{hasMultidimensionalTranspose:i,multidimensionalInfo:l}=this.rasterInfo;let{transposedVariableName:m}=e;const c=o(l)&&i&&(null!=r||w(s));c&&!m&&(m=o(s)&&s.length>0?s[0].variableName??void 0:l.variables[0].name,e={...e,transposedVariableName:m}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:u,extent:h}=this.rasterInfo,{datumTransformation:d}=e;let f=A(t,u,d);if(!h.intersects(f))return{location:f,value:null};if(o(this.rasterInfo.transform)){const t=this.rasterInfo.transform.inverseTransform(f);if(!this.rasterInfo.nativeExtent.intersects(t))return{location:t,value:null};f=t}let y=0;const j=o(m)&&o(l)&&this.rasterInfo.hasMultidimensionalTranspose;if(!j)if(e.srcResolution)y=N(e.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel;else if(y=await this.computeBestPyramidLevelForLocation(t,e),null==y)return{location:f,value:null};const g=this.identifyPixelLocation(f,y,null,j);if(null===g)return{location:f,value:null};const{row:x,col:b,rowOffset:I,colOffset:k,blockWidth:R}=g,S=m??n(e.sliceId),v=M(this.url,S),T=`${y}/${x}/${b}`;let P=F(v,null,T);a(P)&&(P=this.fetchRawTile(y,x,b,e),J(v,null,T,P));const C=await P;if(a(C)||!C.pixels?.length)return{location:f,value:null};const _=I*R+k;return this._processIdentifyResult(C,{srcLocation:f,position:_,pyramidLevel:y,useTransposedTile:!!j,requestSomeSlices:c,identifyOptions:e})}async fetchPixels(t,e,s,r={}){if(t=q(t),(r=this._getRequestOptionsWithSliceId(r)).requestRawData)return this._fetchPixels(t,e,s,r);const i=V(t.spatialReference),o=G(t);if(a(i)||0===o||1===o&&this._isGlobalWrappableSource)return this._fetchPixels(t,e,s,r);if(o>=3)return{extent:t,pixelBlock:null};const n=[],{xmin:l,xmax:m}=t,p=Math.round(i/(m-l)*e),c=p-Math.round((i/2-l)/(m-l)*e);let u=0;const h=[];for(let a=0;a<=o;a++){const d=new et({xmin:0===a?l:-i/2,xmax:a===o?m-i*a:i/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),f=0===a?p-c:a===o?e-u:p;u+=f,h.push(f);const y=r.disableWrapAround&&a>0?null:this._fetchPixels(d,f,s,r);n.push(y)}const d=(await Promise.all(n)).map((t=>t?.pixelBlock));let f=null;const y={width:e,height:s};return f=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},r)).pixelBlock:L(d,y,{blockWidths:h}),{extent:t,srcExtent:$(t,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:f}}async fetchRawPixels(t,e,s,r={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const i=await this._fetchRawTiles(t,e,s,r),{nativeExtent:n,nativePixelSize:a,storageInfo:l}=this.rasterInfo,m=2**t,p=a.x*m,c=a.y*m,u=new et({xmin:n.xmin+p*e.x,xmax:n.xmin+p*(e.x+s.width-1),ymin:n.ymax-c*(e.y+s.height-1),ymax:n.ymax-c*e.y,spatialReference:n.spatialReference});if(!i)return{extent:u,srcExtent:u,pixelBlock:null};const{pixelBlocks:h,mosaicSize:d}=i;if(1===h.length&&o(h[0])&&h[0].width===s.width&&h[0].height===s.height)return{extent:u,srcExtent:u,pixelBlock:i.pixelBlocks[0]};const f=t>0?l.pyramidBlockWidth:l.blockWidth,y=t>0?l.pyramidBlockHeight:l.blockHeight,j={x:e.x%f,y:e.y%y};let g;return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:d,destDimension:s,clipOffset:j,clipSize:s,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:L(h,d,{clipOffset:j,clipSize:s}),{extent:u,srcExtent:u,pixelBlock:g}}fetchRawTile(t,e,s,i){throw new r("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return $(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?U(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,r=0){const{customFetchParameters:i}=this.ioConfig,{range:o,query:n,headers:a}=e;r=r??e.retryCount??this.ioConfig.retryCount;const l=o?{Range:`bytes=${o.from}-${o.to}`}:null;try{return await s(t,{...e,query:{...n,...i},headers:{...a,...l}})}catch(s){if(r>0)return r--,this.request(t,e,r);throw s}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return a(e)||a(t)||0===t.length?null:v(t,e)}getTileExtentFromTileInfo(t,e,s,r){const i=l(r.lodAt(t));return this.getTileExtent({x:i.resolution,y:i.resolution},e,s,r.origin,r.spatialReference,r.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:s,pixelSize:r}=this.rasterInfo;if(!t.tileInfo){const i=[],o=t.maximumPyramidLevel||0;let n=Math.max(r.x,r.y),a=1/.0254*96*n;for(let t=0;t<=o;t++)i.push({level:o-t,resolution:n,scale:a}),n*=2,a*=2;const l=new st({x:s.xmin,y:s.ymax,spatialReference:e});t.tileInfo=new b({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:i}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,s=512,r){const{width:i,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=t,m=new st({x:n.xmin,y:n.ymax,spatialReference:l});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(i,o))/Math.LN2-8)));const p=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],r);t.storageInfo=new S({blockWidth:e,blockHeight:s,pyramidBlockWidth:e,pyramidBlockHeight:s,origin:m,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:p})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,s,r,i,o=0,n=2){if(1===i.length&&o>0){i=[...i];let{x:t,y:e}=i[0];for(let s=0;s<o;s++)t*=n,e*=n,i.push({x:t,y:e})}const a=[],{x:l,y:m}=r;for(let r=0;r<i.length;r++){const{x:o,y:n}=i[r];a.push({minCol:Math.floor((t.xmin-l+.1*o)/e/o),maxCol:Math.floor((t.xmax-l-.1*o)/e/o),minRow:Math.floor((m-t.ymax+.1*n)/s/n),maxRow:Math.floor((m-t.ymin-.1*n)/s/n)})}return a}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(0===t)return e;if(o(s)&&s.length)return s[t-1];const i=r**t;return{x:e.x*i,y:e.y*i}}identifyPixelLocation(t,e,s,r){const{spatialReference:i,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:l,origin:m,transposeInfo:p}=a,c=r&&o(p)?p.tileSize[0]:a.blockWidth,u=r&&o(p)?p.tileSize[1]:a.blockHeight,h=A(t,i,s);if(!n.intersects(h))return null;if(e<0||e>l)return null;const d=this.getPyramidPixelSize(e),{x:f,y}=d,j=(m.y-h.y)/y/u,g=(h.x-m.x)/f/c,x=Math.min(u-1,Math.floor((j-Math.floor(j))*u)),b=Math.min(c-1,Math.floor((g-Math.floor(g))*c));return{pyramidLevel:e,row:Math.floor(j),col:Math.floor(g),rowOffset:x,colOffset:b,blockWidth:c,srcLocation:h}}getTileExtent(t,e,s,r,i,o){const[n,a]=o,l=r.x+s*n*t.x,m=l+n*t.x,p=r.y-e*a*t.y,c=p-a*t.y;return new et({xmin:l,xmax:m,ymin:c,ymax:p,spatialReference:i})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,s){const r=this.rasterInfo.storageInfo.blockBoundary[t];return!r||r.maxRow<e||r.maxCol<s||r.minRow>e||r.minCol>s}async _fetchPixels(t,e,s,r={}){let i=G(t);if(i>=2)return{extent:t,pixelBlock:null};const a=this._getSourceDataInfo(t,e,s,r),{pyramidLevel:l,pyramidResolution:m,srcResolution:p,srcExtent:c,srcWidth:u,srcHeight:h}=a;if(0===u||0===h)return{extent:t,srcExtent:c,pixelBlock:null};const d=n(this.rasterInfo.transform),f="gcs-shift"===d?.type,y=o(V(t.spatialReference));!f&&y||(i=G(a.srcExtent,f));const j=this.rasterInfo.storageInfo,g={x:Math.floor((c.xmin-j.origin.x)/m.x+.1),y:Math.floor((j.origin.y-c.ymax)/m.y+.1)},x=await this._fetchRawTiles(l,g,{width:u,height:h,wrapCount:i},r);if(!x)return{extent:t,srcExtent:c,pixelBlock:null};const b=l>0?j.pyramidBlockWidth:j.blockWidth,I=l>0?j.pyramidBlockHeight:j.blockHeight,k=b===u&&I===h&&g.x%b==0&&g.y%I==0,R=new st({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),S=!t.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:w}=r;if(!S&&k&&1===x.pixelBlocks.length&&b===e&&I===s&&p.x===R.x&&p.y===R.y)return{extent:t,srcExtent:c,pixelBlock:x.pixelBlocks[0]};const v=y&&o(V(c.spatialReference)),T=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");T&&!this.rasterJobHandler&&await W();const P=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:R.toJSON(),datumTransformation:w,rasterTransform:d,hasWrapAround:i>0||v,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:T},r):Q({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:R,datumTransformation:w,rasterTransform:d,hasWrapAround:i>0||v,isAdaptive:!1,includeGCSGrid:T});let C;const _=!r.requestRawData,D={rows:P.spacing[0],cols:P.spacing[1]},M=n(this._getRasterTileAlignmentInfo(l,x.extent.xmin)),{pixelBlocks:F,mosaicSize:J,isPartiallyFilled:H}=x;let B=null;if(this.rasterJobHandler){const t=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:J,destDimension:_?{width:e,height:s}:null,coefs:_?P.coefficients:null,sampleSpacing:_?D:null,projectDirections:T,gcsGrid:T?P.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:r.interpolation,alignmentInfo:M,blockWidths:null},r);({pixelBlock:C,localNorthDirections:B}=t)}else{const t=L(F,J,{alignmentInfo:M});C=_?z(t,{width:e,height:s},P.coefficients,D,r.interpolation):t,T&&P.gcsGrid&&(B=O({width:e,height:s},P.gcsGrid),C=Y(C,this.rasterInfo.dataType,B))}return r.requestRawData||T?{srcExtent:c,pixelBlock:C,transformGrid:P,localNorthDirections:B,extent:t,isPartiallyFilled:H}:{srcExtent:c,extent:t,pixelBlock:C}}async _fetchRawTiles(t,e,s,r){const{origin:i,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(t);let{x:m,y:p}=e,{width:c,height:u,wrapCount:h}=s;const d=this._getRasterTileAlignmentInfo(t,0);r.buffer&&(m-=r.buffer.cols,p-=r.buffer.rows,c+=2*r.buffer.cols,u+=2*r.buffer.rows);let f=0,y=0,j=0;h&&o(d)&&(({worldColumnCountFromOrigin:y,originColumnOffset:j,rightPadding:f}=d),y*d.blockWidth-f>=m+c&&(f=0));const g=Math.floor(m/a),x=Math.floor(p/l),b=Math.floor((m+c+f-1)/a),I=Math.floor((p+u+f-1)/l),k=n[t];if(!k)return null;const{minRow:R,minCol:S,maxCol:w,maxRow:v}=k;if(0===h&&(I<R||b<S||x>v||g>w))return null;const T=new Array;let P=!1;const C=null==this.ioConfig.allowPartialFill?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let e=x;e<=I;e++)for(let s=g;s<=b;s++){let i=s;if(!r.disableWrapAround&&h&&o(d)&&y<=s&&(i=s-y-j),e>=R&&i>=S&&v>=e&&w>=i){const s=this._fetchRawTile(t,e,i,r);C?T.push(new Promise((t=>{s.then((e=>t(e))).catch((()=>{P=!0,t(null)}))}))):T.push(s)}else T.push(Promise.resolve(null))}if(0===T.length)return null;const _=await Promise.all(T),D={height:(I-x+1)*l,width:(b-g+1)*a},{spatialReference:M}=this.rasterInfo,F=this.getPyramidPixelSize(t),{x:J,y:H}=F;return{extent:new et({xmin:i.x+g*a*J,xmax:i.x+(b+1)*a*J,ymin:i.y-(I+1)*l*H,ymax:i.y-x*l*H,spatialReference:M}),pixelBlocks:_,mosaicSize:D,isPartiallyFilled:P}}_fetchRawTile(t,e,s,r){const i=this.rasterInfo.storageInfo.blockBoundary[t];if(!i)return Promise.resolve(null);const{minRow:o,minCol:n,maxCol:l,maxRow:m}=i;if(e<o||s<n||e>m||s>l)return Promise.resolve(null);const p=M(this.url,r.sliceId),c=`${t}/${e}/${s}`;let u=F(p,r.registryId,c);if(a(u)){const i=new AbortController;u=this.fetchRawTile(t,e,s,{...r,signal:i.signal}),J(p,r.registryId,c,u,i),u.catch((()=>H(p,r.registryId,c)))}return r.signal&&R(r,(()=>{B(p,r.registryId,c)})),u}_computeMagDirValues(t){const{bandCount:e,dataType:s}=this.rasterInfo;if((2!==e||"vector-magdir"!==s)&&"vector-uv"!==s||2!==t?.length||!t[0]?.length)return null;const r=t[0].length;if("vector-magdir"===s){const e=t[1].map((t=>(t+360)%360));return[t[0],e]}const[i,o]=t,n=[],a=[];for(let t=0;t<r;t++){const[e,s]=Z([i[t],o[t]]);n.push(e),a.push(s)}return[n,a]}_getRasterTileAlignmentInfo(t,e){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=K(this.rasterInfo)),a(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:e,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,s,r={}){const i={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};r.srcResolution&&(i.srcResolution=r.srcResolution,this._updateSourceDataInfo(t,i));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=i,m=n/e,p=a/s,c=l<o&&m*p>=16;if(c||l===o&&(m>8||p>8)||0===n||0===a){const n=new st({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let a=X(n,this.rasterInfo.spatialReference,t,i.datumTransformation);const u=!a||r.srcResolution&&a.x+a.y<r.srcResolution.x+r.srcResolution.y;if(c&&r.srcResolution&&u){const t=Math.round(Math.log(Math.max(m,p))/Math.LN2)-1;if(o-l+3>=t){const e=2**t;a={x:r.srcResolution.x*e,y:r.srcResolution.y*e}}}a&&(i.srcResolution=a,this._updateSourceDataInfo(t,i))}return(i.srcWidth/e>8||i.srcHeight/s>8)&&(i.srcWidth=0,i.srcHeight=0),i}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const s=this.rasterInfo.spatialReference,{srcResolution:r,datumTransformation:i}=e,{pyramidLevel:o,pyramidResolution:a,excessiveReading:l}=N(r,this.rasterInfo,this.ioConfig.sampling);if(l)return;let m=e.srcExtent||$(t,s,i);if(null==m)return;const p=n(this.rasterInfo.transform);p&&(m=p.inverseTransform(m)),e.srcExtent=m;const c=Math.ceil((m.xmax-m.xmin)/a.x-.1),u=Math.ceil((m.ymax-m.ymin)/a.y-.1);e.pyramidLevel=o,e.pyramidResolution=a,e.srcWidth=c,e.srcHeight=u}_getRequestOptionsWithSliceId(t){return o(this.rasterInfo.multidimensionalInfo)&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:s,position:r,pyramidLevel:i,useTransposedTile:o}=e,l=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[r])return{location:s,value:null};const{multidimensionalInfo:m}=this.rasterInfo;if(a(m)||!o){const e=t.pixels.map((t=>t[r])),o={location:s,value:e,pyramidLevel:i},n=this._computeMagDirValues(e.map((t=>[t])));return n?.length&&(o.magdirValue=n.map((t=>t[0]))),o}let p=t.pixels.map((t=>Array.prototype.slice.call(t,r*l,r*l+l))),c=this._computeMagDirValues(p);const{requestSomeSlices:u,identifyOptions:h}=e;let d=T(m,h.transposedVariableName);if(u){const t=P(d,n(h.multidimensionalDefinition),n(h.timeExtent));p=p.map((e=>t.map((t=>e[t])))),c=c?.map((e=>t.map((t=>e[t])))),d=t.map((t=>d[t]))}return{location:s,value:null,dataSeries:d.map(((t,e)=>{const s={value:p.map((t=>t[e])),multidimensionalDefinition:t.multidimensionalDefinition.map((t=>new y({...t,isSlice:!0})))};return c?.length&&(s.magdirValue=[c[0][e],c[1][e]]),s})),pyramidLevel:i}}};t([m()],mt.prototype,"_rasterTileAlighmentInfo",void 0),t([m({readOnly:!0})],mt.prototype,"_isGlobalWrappableSource",null),t([m(f)],mt.prototype,"url",null),t([m({type:String,json:{write:!0}})],mt.prototype,"datasetName",void 0),t([m({type:String,json:{write:!0}})],mt.prototype,"datasetFormat",void 0),t([m()],mt.prototype,"rasterInfo",void 0),t([m()],mt.prototype,"ioConfig",void 0),t([m()],mt.prototype,"sourceJSON",void 0),mt=t([c("esri.layers.support.rasterDatasets.BaseRaster")],mt);const pt=mt;let ct=class extends pt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._primaryRasters=null}async open(t){await this.init();const{rasterFunction:e}=this,{rasters:s,rasterIds:i}=e.getPrimaryRasters(),o=s.map((e=>e.rasterInfo?void 0:e.open(t)));await Promise.all(o);const n=s.map((({rasterInfo:t})=>t)),a=e.bind({rasterInfos:n,rasterIds:i});if(!a.success)throw new r("raster-function:open",`cannot bind the function: ${a.error??""}`);await this.syncJobHandler(),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",e.rasterInfo)}async syncJobHandler(){const{rasterFunction:t}=this;if(this._primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler)return this.rasterJobHandler.updateRasterFunction(t)}async fetchPixels(t,e,s,r={}){const{rasters:i,rasterIds:n}=this._primaryRasters,l=i.map((i=>i.fetchPixels(t,e,s,r))),m=await Promise.all(l),p=m.map((t=>t.pixelBlock));if(p.every((t=>a(t))))return m[0];const c=m.find((t=>o(t.pixelBlock)))?.extent??t,u=this.rasterJobHandler?await this.rasterJobHandler.process({extent:c,primaryPixelBlocks:p,primaryRasterIds:n}):this.rasterFunction.process({extent:c,primaryPixelBlocks:p,primaryRasterIds:n});return{...m[0],pixelBlock:u}}};t([m({type:String,json:{write:!0}})],ct.prototype,"datasetFormat",void 0),t([m()],ct.prototype,"tileType",void 0),t([m()],ct.prototype,"rasterFunction",void 0),ct=t([c("esri.layers.support.rasterDatasets.FunctionRaster")],ct);const ut=ct,ht=i.getLogger("esri.layers.mixins.ImageryTileMixin"),dt=i=>{let n=class extends i{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalDefinition=null,this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.sourceJSON=null,this.symbolizer=null}get fullExtent(){return this.rasterInfo?.extent}get rasterInfo(){return this.raster?.rasterInfo}get spatialReference(){return this.rasterInfo?.spatialReference??u.WGS84}get tileInfo(){return this.rasterInfo?.storageInfo.tileInfo}set url(t){this._set("url",d(t,ht))}set renderer(t){this._set("renderer",t),this.updateRenderer()}async convertVectorFieldData(t,e){if(a(t)||!this.rasterInfo)return null;const s=this._rasterJobHandler.instance,r=this.rasterInfo.dataType;return s?s.convertVectorFieldData({pixelBlock:t,dataType:r},e):tt(t,r)}async createFlowMesh(t,e){const s=this._rasterJobHandler.instance;return s?s.createFlowMesh(t,e):lt(t.meshType,t.simulationSettings,t.flowData,o(e.signal)?e.signal:(new AbortController).signal)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.rasterInfo??{};if(a(e))return t;let s=t.multidimensionalDefinition||this.multidimensionalDefinition;!a(s)&&s.length||(s=C(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const r=t.timeExtent||this.timeExtent;if(o(s)&&o(r)&&(o(r.start)||o(r.end))){s=s.map((t=>t.clone()));const i=e.variables.find((({name:t})=>t===s[0].variableName))?.dimensions?.find((({name:t})=>"StdTime"===t)),n=s.find((({dimensionName:t})=>"StdTime"===t));if(!i||!n)return{...t,multidimensionalDefinition:null};const{start:l,end:m}=r,p=a(l)?null:l.getTime(),c=a(m)?null:m.getTime(),u=p??c,h=c??p;if(o(i.values)){const t=i.values.filter((t=>{if(Array.isArray(t)){if(u===h)return t[0]<=u&&t[1]>=u;const e=t[0]<=u&&t[1]>u||t[0]<h&&t[1]>=h,s=t[0]>=u&&t[1]<=h||t[0]<u&&t[1]>h;return e||s}return u===h?t===u:t>=u&&t<=h}));if(t.length){const e=t.sort(((t,e)=>u===h?(t[0]??t)-(e[0]??e):Math.abs((t[1]??t)-h)-Math.abs((e[1]??e)-h)))[0];n.values=[e]}else s=null}else if(i.hasRegularIntervals&&i.extent){const[t,e]=i.extent;u>e||h<t?s=null:n.values=u===h?[u]:[Math.max(t,u),Math.min(e,h)]}}return o(s)&&_(s,this.multidimensionalSubset)?{...t,multidimensionalDefinition:null}:{...t,multidimensionalDefinition:s}}async updateRenderer(){const{loaded:t,symbolizer:e}=this;if(!t||!e)return;if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const s=this._rasterJobHandler.instance;s&&(e.rendererJSON=it(this.renderer.toJSON()),e.bind(),await s.updateSymbolizer(e),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(t,e){const s=t&&t.pixelBlock;if(!(o(s)&&s.pixels&&s.pixels.length>0))return null;let r;await this.updateRenderer();const i=this._rasterJobHandler.instance,n=this.bandIds??[];return r=i?await i.symbolize({...t,simpleStretchParams:e,bandIds:n}):this.symbolizer.symbolize({...t,simpleStretchParams:e,bandIds:n}),r}getTileUrl(t,e,s){return"RasterTileServer"===this.raster?.datasetFormat?`${this.url}/tile/${t}/${e}/${s}`:""}getCompatibleTileInfo(t,e,s=!1){if(!this.loaded||a(e))return null;if(s&&t.equals(this.spatialReference))return this.tileInfo;const r=h(t);return b.create({size:256,spatialReference:t,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,e,r,i={}){if(l(this),i.requestAsImageElement){const o=this.getTileUrl(t,e,r);return s(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:i.signal}).then((t=>t.data))}if(o(this.rasterInfo.multidimensionalInfo)&&(i=this.normalizeRasterFetchOptions(i),a(i.multidimensionalDefinition))){const s=i.tileInfo||this.rasterInfo.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,e,r,s),pixelBlock:null}}return await this._initJobHandler(),await this._updateRasterFunction(),"raster-shaded-relief"===this.renderer.type&&(i={...i,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,e,r,i)}async fetchPixels(t,e,s,r={}){return o(this.rasterInfo.multidimensionalInfo)&&(r=this.normalizeRasterFetchOptions(r),a(r.multidimensionalDefinition))?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this._updateRasterFunction(),this.raster.fetchPixels(t,e,s,r))}async identify(t,e={}){return l(this),!o(this.rasterInfo.multidimensionalInfo)||this.rasterInfo.hasMultidimensionalTranspose&&(w(e.multidimensionalDefinition)||e.transposedVariableName||e.timeExtent)||(e=this.normalizeRasterFetchOptions(e),!a(e.multidimensionalDefinition))?this.raster.identify(t,e):{location:t,value:null}}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const t=this.rasterInfo?.multidimensionalInfo;if(a(t)||"standard-time"!==this.rasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,s=e?.[0]?.variableName;return t.variables.some((t=>t.name===s&&(!e?.[0].dimensionName||t.dimensions.some((t=>"StdTime"===t.name)))))}getStandardTimeValue(t){return new Date(24*(t-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(t){const e=t??this.rasterInfo.multidimensionalInfo;return D(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=C(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const t=new x;return this._rasterJobHandler.connectionPromise=t.initialize().then((()=>{l(this),this._rasterJobHandler.instance=t,this.raster.rasterJobHandler=t,this.renderer&&this.updateRenderer(),"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){l(this);const t=ot(this.rasterInfo,this.raster.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(){l(this);const t=this.raster.rasterInfo;if(this.bandIds||(this.bandIds=nt(t)),!this.renderer){const e=at(t,{bandIds:this.bandIds,variableName:o(this.multidimensionalDefinition)?this.multidimensionalDefinition[0]?.variableName:null});"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===e.type&&((t.statistics?.[0].max??0)>1e24||(t.statistics?.[0].min??0)<-1e24)&&(e.dynamicRangeAdjustment=!0,e.statistics=null,"none"===e.stretchType&&(e.stretchType="min-max")),this.renderer=e}this.symbolizer?(this.symbolizer.rendererJSON=it(this.renderer.toJSON()),this.symbolizer.rasterInfo=t):this.symbolizer=new E({rendererJSON:this.renderer.toJSON(),rasterInfo:t});const e=this.symbolizer.bind();e.success||ht.warn("imagery-tile-mixin",e.error||"The given renderer is not supported by the layer.")}async _updateRasterFunction(){if("imagery-tile"!==this.type||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;let t=this.raster;if("Function"===t?.datasetFormat){const e=t.rasterFunction.getPrimaryRasters();t=e.rasters[0]}const{rasterFunction:e}=this;if(e){const s=rt(e.toJSON(),{raster:t}),r=new ut({rasterFunction:s});r.rasterJobHandler=this._rasterJobHandler.instance,await r.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=r}else this.raster=t}};function l(t){if(!t.raster||!t.rasterInfo)throw new r("imagery-tile","no raster")}return t([m()],n.prototype,"_cachedRendererJson",void 0),t([m()],n.prototype,"_cachedRasterFunctionJson",void 0),t([m()],n.prototype,"_compatibleFullExtent",void 0),t([m()],n.prototype,"_rasterJobHandler",void 0),t([m()],n.prototype,"bandIds",void 0),t([m({json:{origins:{service:{read:{source:"copyrightText"}}}}})],n.prototype,"copyright",void 0),t([m({json:{read:!1}})],n.prototype,"fullExtent",null),t([m()],n.prototype,"interpolation",void 0),t([m()],n.prototype,"ioConfig",void 0),t([m({type:[y]})],n.prototype,"multidimensionalDefinition",void 0),t([m({type:j,json:{write:!0}})],n.prototype,"multidimensionalSubset",void 0),t([m()],n.prototype,"raster",void 0),t([m({type:g})],n.prototype,"rasterFunction",void 0),t([m()],n.prototype,"rasterInfo",null),t([m()],n.prototype,"sourceJSON",void 0),t([m({json:{read:!1}})],n.prototype,"spatialReference",null),t([m({json:{read:!1}})],n.prototype,"tileInfo",null),t([m(f)],n.prototype,"url",null),t([m({types:e})],n.prototype,"renderer",null),t([m()],n.prototype,"symbolizer",void 0),n=t([c("esri.layers.ImageryTileMixin")],n),n};export{pt as B,ut as F,dt as ImageryTileMixin};
