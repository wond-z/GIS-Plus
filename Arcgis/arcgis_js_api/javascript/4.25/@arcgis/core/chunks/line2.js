/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{i as e,p as t,a as r,u as s,k as a,e as i}from"./maybe.js";import{g as o,s as n}from"./watch.js";import{k as d,m as c,A as l,c as h,p as u,t as m,f as p,j as g}from"./mat4.js";import{c as f,I as _}from"./mat4f64.js";import{d as v,f as y,b as w,j as C,c as R,D as T,e as S,s as x}from"./vec3.js";import{f as D,c as b}from"./vec4f64.js";import{b as E}from"./mathUtils2.js";import{V as I,P as M,R as O,U as A,O as P}from"./basicInterfaces.js";import{a6 as F,a7 as N,M as H,f as L,e as z,L as j,F as G,N as U,as as V,d as B,b as W,S as k,a as q,s as Z,a9 as X,m as Q,r as $,j as Y,C as K,D as J,R as ee,c as te,ag as re,P as se,G as ae,Q as ie,at as oe,au as ne,ap as de,W as ce,av as le}from"./bufferWriterUtils.js";import{R as he,W as ue,O as me,D as pe,P as ge,S as fe,q as _e}from"./DefaultBufferWriter.js";import{V as ve}from"./VertexAttribute.js";import{c as ye,a as we,r as Ce}from"./utils20.js";import{projectBuffer as Re}from"../geometry/projection.js";import{C as Te,p as Se}from"./triangulationUtils.js";import{M as xe,g as De}from"./MultipassGeometryTest.glsl.js";import{_ as be}from"./tslib.es6.js";import Ee from"../core/Accessor.js";import Ie from"../core/Evented.js";import Me from"../core/Handles.js";import{s as Oe}from"./ensureType.js";import{M as Ae,P as Pe,s as Fe}from"../core/scheduling.js";import{watch as Ne,syncAndInitial as He,on as Le}from"../core/reactiveUtils.js";import{property as ze}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{subclass as je}from"../core/accessorSupport/decorators/subclass.js";import{V as Ge}from"./ViewingMode.js";import{d as Ue}from"./debugFlags.js";import{R as Ve,O as Be}from"./interfaces4.js";import{c as We,f as ke,s as qe,t as Ze,g as Xe,h as Qe}from"./mathUtils.js";import{c as $e,p as Ye,a as Ke}from"./aaBoundingRect.js";import{c as Je}from"./vec2f32.js";import{g as et,h as tt,T as rt,P as st,a as at,b as it,c as ot,j as nt,U as dt,B as ct,e as lt}from"./enums3.js";import{F as ht,a as ut,B as mt,v as pt}from"./FramebufferObject.js";import{h as gt}from"./object.js";import{R as ft,S as _t}from"./RenderSlot.js";import{N as vt}from"./NestedMap.js";import{S as yt,p as wt}from"./ShaderTechniqueConfiguration.js";import{C as Ct}from"./Camera.js";import{L as Rt}from"./Logger.js";import{a as Tt,l as St,v as xt,e as Dt,s as bt}from"./Util2.js";import{g as Et,R as It,D as Mt,M as Ot,i as At,a as Pt}from"./Material.js";import{a as Ft,f as Nt}from"./vec2f64.js";import{B as Ht,b as Lt,d as zt,o as jt,p as Gt,q as Ut,M as Vt,E as Bt,P as Wt,R as kt,S as qt,A as Zt}from"./SSAOHelper.js";import{c as Xt}from"./mat3f64.js";import{s as Qt,j as $t,h as Yt,l as Kt,a as Jt,b as er,e as tr,i as rr,n as sr,k as ar}from"./vec2.js";import{T as ir}from"./Texture.js";import{S as or,c as nr,I as dr}from"./Intersector.js";import{g as cr}from"./glUtil.js";import{T as lr,m as hr,e as ur,o as mr,a as pr,d as gr,b as fr,c as _r,g as vr,h as yr,s as wr}from"./OrderIndependentTransparency.js";import{T as Cr,O as Rr}from"./OutputHighlight.glsl.js";import{e as Tr}from"./Ellipsoid.js";import{C as Sr}from"./context-util.js";import{R as xr,b as Dr}from"./MemCache.js";import{T as br,n as Er}from"./Scheduler.js";function Ir(e){e.fragment.code.add(Et`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}var Mr,Or,Ar,Pr,Fr,Nr,Hr,Lr;function zr(t){return e(t)&&e(t.cubeMap)}function jr(t){return e(t)&&!t.running}!function(e){e[e.RENDERING=0]="RENDERING",e[e.FINISHED_RENDERING=1]="FINISHED_RENDERING",e[e.FADING_TEXTURE_CHANNELS=2]="FADING_TEXTURE_CHANNELS",e[e.SWITCH_CHANNELS=3]="SWITCH_CHANNELS",e[e.FINISHED=4]="FINISHED"}(Mr||(Mr={})),function(e){e[e.RG=0]="RG",e[e.BA=1]="BA"}(Or||(Or={}));class Gr{constructor(){this.readChannels=Or.RG,this.renderingStage=Mr.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=v(),this.isCameraPositionFinal=!0,this.parallax=new Ur,this.parallaxNew=new Ur,this.crossFade={enabled:!1,factor:1,distanceThresholdFactor:.3},this.fadeInOut={stage:Pr.FINISHED,factor:1,distanceThresholdFactor:.6},this.fadeIn={stage:Ar.FINISHED,factor:1,distanceThresholdFactor:2},this.fadeInOutHeight={stage:Fr.FINISHED,factor:-1}}get isFading(){return this.fadeInOut.stage===Pr.FADE_OUT||this.fadeInOut.stage===Pr.FADE_IN||this.fadeIn.stage===Ar.FADE_IN||this.fadeInOutHeight.stage!==Fr.FINISHED||this.renderingStage===Mr.FADING_TEXTURE_CHANNELS}}!function(e){e[e.FINISHED=0]="FINISHED",e[e.CHANGE_ANCHOR=1]="CHANGE_ANCHOR",e[e.FADE_IN=2]="FADE_IN"}(Ar||(Ar={})),function(e){e[e.FINISHED=0]="FINISHED",e[e.FADE_OUT=1]="FADE_OUT",e[e.SWITCH=2]="SWITCH",e[e.FADE_IN=3]="FADE_IN"}(Pr||(Pr={})),function(e){e[e.FINISHED=0]="FINISHED",e[e.HEIGHT_FADE=1]="HEIGHT_FADE"}(Fr||(Fr={}));class Ur{constructor(){this.anchorPointClouds=v(),this.cloudsHeight=1e5,this.radiusCurvatureCorrectionFactor=0,this.transform=f()}}class Vr extends F{constructor(e,t){super(e,"samplerCube",N.Pass,((r,s,a)=>r.bindTexture(e,t(s,a))))}}function Br(t){const r=t.fragment;r.uniforms.add([new H("rotationMatrixClouds",((e,t)=>t.cloudsFade.parallax.transform)),new H("rotationMatrixCloudsCrossFade",((e,t)=>t.cloudsFade.parallaxNew.transform)),new L("anchorPosition",((e,t)=>t.cloudsFade.parallax.anchorPointClouds)),new L("anchorPositionCrossFade",((e,t)=>t.cloudsFade.parallaxNew.anchorPointClouds)),new z("cloudsHeight",((e,t)=>t.cloudsFade.parallax.cloudsHeight)),new z("radiusCurvatureCorrectionFactor",((e,t)=>t.cloudsFade.parallax.radiusCurvatureCorrectionFactor)),new z("totalFadeInOut",((e,t)=>t.cloudsFade.fadeInOut.stage===Pr.FINISHED?t.cloudsFade.fadeInOutHeight.factor+1-t.cloudsFade.fadeIn.factor:t.cloudsFade.fadeInOutHeight.factor+1-t.cloudsFade.fadeInOut.factor)),new z("crossFadeAnchorFactor",((e,t)=>We(t.cloudsFade.crossFade.factor,0,1))),new Vr("cubeMap",((t,r)=>e(r.cloudsFade.data)&&e(r.cloudsFade.data.cubeMap)?r.cloudsFade.data.cubeMap.colorTexture:null)),new Ht("crossFade",((e,t)=>t.cloudsFade.crossFade.enabled)),new Ht("readChannelsRG",((e,t)=>t.cloudsFade.readChannels===Or.RG)),new Ht("fadeTextureChannels",((e,t)=>t.cloudsFade.renderingStage===Mr.FADING_TEXTURE_CHANNELS))]),r.constants.add("planetRadius","float",Tr.radius),r.code.add(Et`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),r.code.add(Et`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),r.code.add(Et`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),Lt(r),zt(r),r.code.add(Et`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),r.code.add(Et`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = textureCube(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),r.code.add(Et`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),r.code.add(Et`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),r.code.add(Et`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}function Wr(e,t){const r=e.fragment;r.include(j),r.uniforms.add(new G("nearFar",((e,t)=>t.camera.nearFar))),r.uniforms.add(new U("depthMap",((e,t)=>t.linearDepthTexture))),r.uniforms.add(new H("proj",((e,t)=>t.ssr.camera.projectionMatrix))),r.uniforms.add(new z("invResolutionHeight",((e,t)=>1/t.ssr.camera.height))),r.uniforms.add(new H("reprojectionMatrix",((e,t)=>t.ssr.reprojectionMatrix))),r.code.add(Et`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${t.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}class kr{constructor(){this.reprojectionMatrix=f()}}class qr{constructor(e,t,r){this.shadowMap=e,this.ssaoHelper=t,this.slicePlane=r,this.slot=ft.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this._inverseViewport=Ft(),this.oldLighting=new jt,this.newLighting=new jt,this._fadedLighting=new jt,this._lighting=this.newLighting,this.ssr=new kr,this.multipassTerrain=new V,this.multipassGeometry=new xe,this.overlays=[],this.cloudsFade=new Gr}get camera(){return this._camera}set camera(e){this._camera=this.ssr.camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(e){const{oldLighting:t,newLighting:r}=this;e>=1?this._lighting=r:(this._fadedLighting.lerpLighting(t,r,e),this._lighting=this._fadedLighting)}}class Zr{constructor(){this.enabled=!0,this._time=Ae(0)}get time(){return this._time}advance(e){return this._time!==e.time&&(this._time=e.time,!0)}}!function(e){e[e.RasterImage=0]="RasterImage",e[e.Features=1]="Features"}(Nr||(Nr={})),function(e){e[e.WithRasterImage=0]="WithRasterImage",e[e.WithoutRasterImage=1]="WithoutRasterImage"}(Hr||(Hr={}));class Xr{constructor(e,t){this.vec3=e,this.id=t}}function Qr(e,t,r,s){return new Xr(y(e,t,r),s)}!function(e){e[e.None=0]="None",e[e.ColorAndWater=1]="ColorAndWater",e[e.Highlight=2]="Highlight",e[e.Occluded=3]="Occluded",e[e.ObjectAndLayerIdColor=4]="ObjectAndLayerIdColor"}(Lr||(Lr={}));class $r{constructor(e,t){this.index=e,this.renderTargets=t,this._extent=$e(),this.resolution=0,this.renderLocalOrigin=Qr(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new Kr,this.validTargets=null,this.hasDrapedFeatureSource=!1,this.hasDrapedRasterSource=!1,this.hasTargetWithoutRasterImage=!1,this.index=e,this.validTargets=new Array(t.renderTargets.length).fill(!1)}get extent(){return this._extent}getValidTexture(e){return this.validTargets[e]?this.renderTargets.getTarget(e).getTexture():null}get _needsColorWithoutRasterImage(){return this.hasDrapedRasterSource&&this.hasDrapedFeatureSource&&this.hasTargetWithoutRasterImage}getColorTexture(e){const t=e===Lr.ColorAndWater?this.renderTargets.getTarget(Ve.Color):e===Lr.Highlight?this.renderTargets.getTarget(Ve.Highlight):e===Lr.ObjectAndLayerIdColor?this.renderTargets.getTarget(Ve.ObjectAndLayerIdColor):this.renderTargets.getTarget(Ve.Occluded);return t?t.getTexture():null}getColorTextureNoRasterImage(){return this._needsColorWithoutRasterImage?this.getValidTexture(Ve.ColorNoRasterImage):this.hasDrapedFeatureSource?this.getValidTexture(Ve.Color):null}getNormalTexture(e){const t=e===Lr.ColorAndWater?this.renderTargets.getTarget(Ve.Water):null;return t?t.getTexture():null}draw(e,t){const r=this.computeRenderTargetValidityBitfield();for(const r of this.renderTargets.renderTargets)r.type!==Ve.ColorNoRasterImage||this._needsColorWithoutRasterImage?this.validTargets[r.type]=e.drawTarget(this,r,t):this.validTargets[r.type]=!1;return r^this.computeRenderTargetValidityBitfield()?I.CHANGED:I.UNCHANGED}computeRenderTargetValidityBitfield(){const e=this.validTargets;return+e[Ve.Color]|+e[Ve.ColorNoRasterImage]<<1|+e[Ve.Highlight]<<2|+e[Ve.Water]<<3|+e[Ve.Occluded]<<4}setupGeometryViewsCyclical(e){this.setupGeometryViewsDirect();const t=.001*e.range;if(this._extent[0]-t<=e.min){const t=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Ye(this._extent,e.range,0,t)}if(this._extent[2]+t>=e.max){const t=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Ye(this._extent,-e.range,0,t)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,Ke(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let e=0;e<this.canvasGeometries.numViews;e++){const t=this.canvasGeometries.extents[e];if(t[0]!==t[2]&&t[1]!==t[3])return!0}return!1}applyViewport(e){e.setViewport(this.index===Be.INNER?0:this.resolution,0,this.resolution,this.resolution)}}function Yr(e,t,r){return Math.min(ke(Math.max(e,t)+256),r)}class Kr{constructor(){this.extents=[$e(),$e(),$e()],this.numViews=0}}class Jr{constructor(e,t){this._size=Je(),this._fbo=null,this._fbo=new ht(e,{colorTarget:et.TEXTURE,depthStencilTarget:tt.NONE},{target:rt.TEXTURE_2D,pixelFormat:st.RGBA,dataType:at.UNSIGNED_BYTE,wrapMode:it.CLAMP_TO_EDGE,samplingMode:ot.LINEAR_MIPMAP_LINEAR,hasMipmap:t,maxAnisotropy:8,width:0,height:0})}dispose(){this._fbo=t(this._fbo)}getTexture(){return this._fbo?this._fbo.colorTexture:null}isValid(){return null!==this._fbo}resize(e,t){this._size[0]=e,this._size[1]=t,this._fbo.resize(this._size[0],this._size[1])}bind(e){e.bindFramebuffer(this._fbo)}generateMipMap(){const e=this._fbo.colorTexture;e.descriptor.hasMipmap&&e.generateMipmap()}disposeRenderTargetMemory(){this._fbo?.resize(0,0)}get gpuMemoryUsage(){return this._fbo?.gpuMemoryUsage??0}}class es{constructor(e,t,r,s=!0){this.output=t,this.type=r,this.valid=!1,this.lastUsed=1/0,this.fbo=new Jr(e,s)}}class ts{constructor(e){this.renderTargets=[new es(e,_t.Color,Ve.Color),new es(e,_t.Color,Ve.ColorNoRasterImage),new es(e,_t.Highlight,Ve.Highlight,!1),new es(e,_t.Normal,Ve.Water),new es(e,_t.Color,Ve.Occluded)],gt("enable-feature:objectAndLayerId-rendering")&&this.renderTargets.push(new es(e,_t.ObjectAndLayerIdColor,Ve.ObjectAndLayerIdColor))}getTarget(e){return this.renderTargets[e].fbo}dispose(){for(const e of this.renderTargets)e.fbo.dispose()}disposeRenderTargetMemory(){for(const e of this.renderTargets)e.fbo.disposeRenderTargetMemory()}validateUsageForTarget(e,t,r){if(e)t.lastUsed=r;else if(r-t.lastUsed>rs)t.fbo.disposeRenderTargetMemory(),t.lastUsed=1/0;else if(t.lastUsed<1/0)return!0;return!1}get gpuMemoryUsage(){return this.renderTargets.reduce(((e,t)=>e+t.fbo.gpuMemoryUsage),0)}}const rs=1e3;class ss{constructor(e){this._context=e,this._perConstructorInstances=new vt,this._frameCounter=0,this._keepAliveFrameCount=is}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}dispose(){this._perConstructorInstances.forEach((e=>e.forEach((e=>e.technique.destroy())))),this._perConstructorInstances.clear()}acquire(e,t=os){const s=t.key;let a=this._perConstructorInstances.get(e,s);if(r(a)){const r=new e(this._context,t,(()=>this.release(r)));a=new as(r),this._perConstructorInstances.set(e,s,a)}return++a.refCount,a.technique}releaseAndAcquire(t,r,s){if(e(s)){if(r.key===s.key)return s;this.release(s)}return this.acquire(t,r)}release(e){if(r(e)||this._perConstructorInstances.empty)return;const t=this._perConstructorInstances.get(e.constructor,e.key);r(t)||(--t.refCount,0===t.refCount&&(t.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==is&&this._perConstructorInstances.forEach(((e,t)=>{e.forEach(((e,r)=>{0===e.refCount&&e.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(e.technique.destroy(),this._perConstructorInstances.delete(t,r))}))}))}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach(((t,r)=>{e.push((async(e,t)=>{const r=t.shader;r&&(await r.reload(),e.forEach((e=>e.technique.reload(this._context))))})(t,r))})),await Promise.all(e)}}class as{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}}const is=-1,os=new yt,ns=e=>class extends e{constructor(){super(...arguments),this._isDisposed=!1}dispose(){for(const e of this._managedDisposables??[]){const t=this[e];this[e]=null,t&&"function"==typeof t.dispose&&t.dispose()}this._isDisposed=!0}get isDisposed(){return this._isDisposed}};class ds extends(ns(class{})){}function cs(){return(e,t)=>{e.hasOwnProperty("_managedDisposables")||(e._managedDisposables=e._managedDisposables?.slice()??[]),e._managedDisposables?.unshift(t)}}class ls{constructor(e,t,r,s){this._textureRepository=e,this._techniqueRepository=t,this.materialChanged=r,this.requestRender=s,this._id2glMaterialRef=new vt}dispose(){this._textureRepository.dispose()}acquire(e,t,s){if(this._ownMaterial(e),!e.requiresSlot(t,s))return null;let a=this._id2glMaterialRef.get(s,e.id);if(r(a)){const t=e.createGLMaterial({material:e,techniqueRep:this._techniqueRepository,textureRep:this._textureRepository,output:s});a=new hs(t),this._id2glMaterialRef.set(s,e.id,a)}return a.ref(),a.glMaterial}release(r,s){const a=this._id2glMaterialRef.get(s,r.id);e(a)&&(a.unref(),a.referenced||(t(a.glMaterial),this._id2glMaterialRef.delete(s,r.id)))}_ownMaterial(t){e(t.repository)&&t.repository!==this&&Rt.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),t.repository=this}}class hs{constructor(e){this.glMaterial=e,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,Tt(this._refCnt>=0)}get referenced(){return this._refCnt>0}}const us={orderedRepackingEnabled:!1};class ms{constructor(e){this._originSR=e,this._origins=new Map,this._objects=new Map,this._gridSize=5e5,this._rootOriginId="root/"+o()}getOrigin(t){const r=this._origins.get(this._rootOriginId);if(null==r){const r=null;if(e(r))return this._origins.set(this._rootOriginId,Qr(r[0],r[1],r[2],this._rootOriginId)),this.getOrigin(t);const s=Qr(t[0]+Math.random()-.5,t[1]+Math.random()-.5,t[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,s),s}const s=this._gridSize,a=Math.round(t[0]/s),i=Math.round(t[1]/s),o=Math.round(t[2]/s),n=`${a}/${i}/${o}`;let d=this._origins.get(n);const c=.5*s;if(w(ps,t,r.vec3),ps[0]=Math.abs(ps[0]),ps[1]=Math.abs(ps[1]),ps[2]=Math.abs(ps[2]),ps[0]<c&&ps[1]<c&&ps[2]<c){if(d){const e=Math.max(...ps);if(w(ps,t,d.vec3),ps[0]=Math.abs(ps[0]),ps[1]=Math.abs(ps[1]),ps[2]=Math.abs(ps[2]),Math.max(...ps)<e)return d}return r}return d||(d=Qr(a*s,i*s,o*s,n),this._origins.set(n,d)),d}_drawOriginBox(e,t=D(1,1,0,1)){const r=window.view,s=r._stage,a=t.toString();if(!this._objects.has(a)){this._material=new he({width:2,color:t}),s.add(this._material);const e=new ue({isPickable:!1}),r=new me({castShadow:!1});s.add(r),e.add(r),s.add(e),this._objects.set(a,r)}const i=this._objects.get(a),o=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],n=o.length,d=new Array(3*n),c=new Array,l=.5*this._gridSize;for(let t=0;t<n;t++)d[3*t+0]=e[0]+(1&o[t]?l:-l),d[3*t+1]=e[1]+(2&o[t]?l:-l),d[3*t+2]=e[2]+(4&o[t]?l:-l),t>0&&c.push(t-1,t);Re(d,this._originSR,0,d,r.renderSpatialReference,0,n);const h=new B([[ve.POSITION,{size:3,data:d,exclusive:!0}]],[[ve.POSITION,c]],M.Line);s.add(h),i.addGeometry(h,this._material,_)}get test(){const e=this;return{set gridSize(t){e._gridSize=t}}}}const ps=v();class gs{constructor(t,r,s,a=null){this.rctx=t,this.sliceHelper=a,this.lastFrameCamera=new Ct,this.output=_t.Color,this.renderOccludedMask=_s,this.bindParameters=new qr(r,s,e(a)?a.plane:null)}resetRenderOccludedMask(){this.renderOccludedMask=_s}}class fs extends gs{constructor(e,t,r,s,a){super(e,r,s,a),this.offscreenRenderingHelper=t,this.sliceHelper=a}}const _s=It.Occlude|It.OccludeAndTransparent|It.OccludeAndTransparentStencil;var vs;!function(e){e[e.Highlight=0]="Highlight",e[e.Default=1]="Default"}(vs||(vs={}));class ys{constructor(){this.camera=new Ct,this.lightMat=f()}}class ws{constructor(e,t){this._rctx=e,this._viewingMode=t,this._enabled=!1,this._snapshots=new Array,this._textureSize=0,this._numCascades=1,this._maxNumCascades=4,this._splitSchemeLambda=0,this._warp=!0,this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=b(),this._cascades=[new ys,new ys,new ys,new ys],this._maxTextureSize=Math.min(gt("esri-mobile")?2048:8192,this._rctx.parameters.maxTextureSize)}get depthTexture(){return this._depthTexture}get textureSize(){return this._textureSize}get numCascades(){return this._numCascades}get cascadeDistances(){return qe(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}dispose(){this._discardDepthTexture(),this._discardAllSnapshots()}set maxCascades(e){this._maxNumCascades=We(Math.floor(e),1,4)}get maxCascades(){return this._maxNumCascades}set enabled(e){this._enabled=e,e||(this._discardDepthTexture(),this._discardAllSnapshots())}get enabled(){return this._enabled}get ready(){return this._enabled&&e(this._depthTexture)}getSnapshot(e){return this.enabled?this._snapshots[e]:null}getCascades(){for(let e=0;e<this._numCascades;++e)Ns[e]=this._cascades[e];return Ns.length=this._numCascades,Ns}start(e,t,r){Tt(this.enabled),this._textureSize=this._computeTextureSize(e.fullWidth,e.fullHeight),this._ensureDepthTexture();const{near:s,far:a}=this._clampNearFar(r);this._computeCascadeDistances(a,s),this._setupMatrices(e,t);const i=e.viewMatrix,o=e.projectionMatrix;for(let e=0;e<this._numCascades;++e)this._constructCascade(e,o,i,t);this._lastOrigin=null,this.clear()}finish(e){Tt(this.enabled),this._rctx.bindFramebuffer(e)}getShadowMapMatrices(e){if(!this._lastOrigin||!C(e,this._lastOrigin)){this._lastOrigin=this._lastOrigin||v(),R(this._lastOrigin,e);for(let t=0;t<this._numCascades;++t){d(Hs,this._cascades[t].lightMat,e);for(let e=0;e<16;++e)Ls[16*t+e]=Hs[e]}}return Ls}takeCascadeSnapshotTo(e,t){Tt(this.enabled);const r=this._ensureSnapshot(t);this._bindFbo();const s=this._rctx,a=s.bindTexture(r,ir.TEXTURE_UNIT_FOR_UPDATES);s.gl.copyTexSubImage2D(rt.TEXTURE_2D,0,e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[0],e.camera.viewport[1],e.camera.viewport[2],e.camera.viewport[3]),s.bindTexture(a,ir.TEXTURE_UNIT_FOR_UPDATES)}clear(){const e=this._rctx;this._bindFbo(),e.setClearColor(1,1,1,1),e.clearSafe(nt.COLOR_BUFFER_BIT|nt.DEPTH_BUFFER_BIT)}_computeTextureSize(e,t){const r=.5*Math.log(e*e+t*t)*Math.LOG2E,s=2**Math.round(r+.35);return Math.min(this._maxTextureSize,2*s)}_ensureDepthTexture(){if(e(this._depthTexture)&&this._depthTexture.descriptor.width===this._textureSize)return;this._discardDepthTexture();const t={target:rt.TEXTURE_2D,pixelFormat:st.RGBA,dataType:at.UNSIGNED_BYTE,wrapMode:it.CLAMP_TO_EDGE,samplingMode:ot.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize};this._depthTexture=new ir(this._rctx,t),this._fbo=new ht(this._rctx,{colorTarget:et.TEXTURE,depthStencilTarget:tt.DEPTH_RENDER_BUFFER,width:this._textureSize,height:this._textureSize},this._depthTexture)}_ensureSnapshot(t){let r=this._snapshots[t];if(e(r)&&r.descriptor.width===this._textureSize)return r;this._discardSnapshot(t);const s={target:rt.TEXTURE_2D,pixelFormat:st.RGBA,dataType:at.UNSIGNED_BYTE,wrapMode:it.CLAMP_TO_EDGE,samplingMode:ot.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize};return r=new ir(this._rctx,s),this._snapshots[t]=r,r}_discardDepthTexture(){this._fbo=t(this._fbo),this._depthTexture=t(this._depthTexture)}_discardSnapshot(e){this._snapshots[e]=t(this._snapshots[e])}_discardAllSnapshots(){for(let e=0;e<this._snapshots.length;++e)this._discardSnapshot(e);this._snapshots.length=0}_bindFbo(){const e=this._rctx;e.unbindTexture(this._depthTexture),e.bindFramebuffer(this._fbo)}_constructCascade(e,t,r,s){const a=this._cascades[e],i=-this._cascadeDistances[e],o=-this._cascadeDistances[e+1],n=(t[10]*i+t[14])/Math.abs(t[11]*i+t[15]),l=(t[10]*o+t[14])/Math.abs(t[11]*o+t[15]);Tt(n<l);for(let e=0;e<8;++e){qe(Ss,e%4==0||e%4==3?-1:1,e%4==0||e%4==1?-1:1,e<4?n:l,1),Ze(xs[e],Ss,Ts);for(let t=0;t<3;++t)xs[e][t]/=xs[e][3]}T(Fs,xs[0]),d(Cs,Ps,Fs),a.camera.viewMatrix=Cs;for(let e=0;e<8;++e)S(xs[e],xs[e],a.camera.viewMatrix);R(Ds,xs[0]),R(bs,xs[0]);for(let e=1;e<8;++e)for(let t=0;t<3;++t)Ds[t]=Math.min(Ds[t],xs[e][t]),bs[t]=Math.max(bs[t],xs[e][t]);Ds[2]-=200,bs[2]+=200,a.camera.near=-bs[2],a.camera.far=-Ds[2],this._warp?this._constructTrapezoidalProjection(r,s,a):this._constructOrthogonalProjection(a),c(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const h=this._textureSize/2;a.camera.viewport[0]=e%2==0?0:h,a.camera.viewport[1]=0===Math.floor(e/2)?0:h,a.camera.viewport[2]=h,a.camera.viewport[3]=h}_constructOrthogonalProjection(e){l(e.camera.projectionMatrix,Ds[0],bs[0],Ds[1],bs[1],e.camera.near,e.camera.far)}_constructTrapezoidalProjection(e,t,r){const s=1/xs[0][3],a=1/xs[4][3];Tt(s<a);let i=s+Math.sqrt(s*a);const o=Math.sin(Xe(e[2]*t[0]+e[6]*t[1]+e[10]*t[2]));i/=o,function(e,t,r,s,a,i,o,n){Qt(zs,0,0);for(let t=0;t<4;++t)$t(zs,zs,e[t]);Yt(zs,zs,.25),Qt(js,0,0);for(let t=4;t<8;++t)$t(js,js,e[t]);Yt(js,js,.25),Kt(Gs[0],e[4],e[5],.5),Kt(Gs[1],e[5],e[6],.5),Kt(Gs[2],e[6],e[7],.5),Kt(Gs[3],e[7],e[4],.5);let d=0,c=Jt(Gs[0],zs);for(let e=1;e<4;++e){const t=Jt(Gs[e],zs);t<c&&(c=t,d=e)}er(Us,Gs[d],e[d+4]);const l=Us[0];let h,u;Us[0]=-Us[1],Us[1]=l,er(Vs,js,zs),tr(Vs,Us)<0&&rr(Us,Us),Kt(Us,Us,Vs,r),sr(Us,Us),h=u=tr(er(Bs,e[0],zs),Us);for(let t=1;t<8;++t){const r=tr(er(Bs,e[t],zs),Us);r<h?h=r:r>u&&(u=r)}ar(s,zs),Yt(Bs,Us,h-t),$t(s,s,Bs);let m=-1,p=1,g=0,f=0;for(let t=0;t<8;++t){er(Ws,e[t],s),sr(Ws,Ws);const r=Us[0]*Ws[1]-Us[1]*Ws[0];r>0?r>m&&(m=r,g=t):r<p&&(p=r,f=t)}xt(m>0,"leftArea"),xt(p<0,"rightArea"),Yt(ks,Us,h),$t(ks,ks,zs),Yt(qs,Us,u),$t(qs,qs,zs),Zs[0]=-Us[1],Zs[1]=Us[0];const _=Dt(s,e[f],qs,$t(Bs,qs,Zs),1,a),v=Dt(s,e[g],qs,Bs,1,i),y=Dt(s,e[g],ks,$t(Bs,ks,Zs),1,o),w=Dt(s,e[f],ks,Bs,1,n);xt(_,"rayRay"),xt(v,"rayRay"),xt(y,"rayRay"),xt(w,"rayRay")}(xs,i,o,Es,Is,Ms,Os,As),function(e,t,r,s,a){er(Ys,r,s),Yt(Ys,Ys,.5),Ks[0]=Ys[0],Ks[1]=Ys[1],Ks[2]=0,Ks[3]=Ys[1],Ks[4]=-Ys[0],Ks[5]=0,Ks[6]=Ys[0]*Ys[0]+Ys[1]*Ys[1],Ks[7]=Ys[0]*Ys[1]-Ys[1]*Ys[0],Ks[8]=1,Ks[Xs(0,2)]=-tr($s(Ks,0),e),Ks[Xs(1,2)]=-tr($s(Ks,1),e);let i=tr($s(Ks,0),r)+Ks[Xs(0,2)],o=tr($s(Ks,1),r)+Ks[Xs(1,2)],n=tr($s(Ks,0),s)+Ks[Xs(0,2)],d=tr($s(Ks,1),s)+Ks[Xs(1,2)];i=-(i+n)/(o+d),Ks[Xs(0,0)]+=Ks[Xs(1,0)]*i,Ks[Xs(0,1)]+=Ks[Xs(1,1)]*i,Ks[Xs(0,2)]+=Ks[Xs(1,2)]*i,i=1/(tr($s(Ks,0),r)+Ks[Xs(0,2)]),o=1/(tr($s(Ks,1),r)+Ks[Xs(1,2)]),Ks[Xs(0,0)]*=i,Ks[Xs(0,1)]*=i,Ks[Xs(0,2)]*=i,Ks[Xs(1,0)]*=o,Ks[Xs(1,1)]*=o,Ks[Xs(1,2)]*=o,Ks[Xs(2,0)]=Ks[Xs(1,0)],Ks[Xs(2,1)]=Ks[Xs(1,1)],Ks[Xs(2,2)]=Ks[Xs(1,2)],Ks[Xs(1,2)]+=1,i=tr($s(Ks,1),t)+Ks[Xs(1,2)],o=tr($s(Ks,2),t)+Ks[Xs(2,2)],n=tr($s(Ks,1),r)+Ks[Xs(1,2)],d=tr($s(Ks,2),r)+Ks[Xs(2,2)],i=-.5*(i/o+n/d),Ks[Xs(1,0)]+=Ks[Xs(2,0)]*i,Ks[Xs(1,1)]+=Ks[Xs(2,1)]*i,Ks[Xs(1,2)]+=Ks[Xs(2,2)]*i,i=tr($s(Ks,1),t)+Ks[Xs(1,2)],o=tr($s(Ks,2),t)+Ks[Xs(2,2)],n=-o/i,Ks[Xs(1,0)]*=n,Ks[Xs(1,1)]*=n,Ks[Xs(1,2)]*=n,a[0]=Ks[0],a[1]=Ks[1],a[2]=0,a[3]=Ks[2],a[4]=Ks[3],a[5]=Ks[4],a[6]=0,a[7]=Ks[5],a[8]=0,a[9]=0,a[10]=1,a[11]=0,a[12]=Ks[6],a[13]=Ks[7],a[14]=0,a[15]=Ks[8]}(Es,Is,Os,As,r.camera.projectionMatrix),r.camera.projectionMatrix[10]=2/(Ds[2]-bs[2]),r.camera.projectionMatrix[14]=-(Ds[2]+bs[2])/(Ds[2]-bs[2])}_setupMatrices(e,t){c(Rs,e.projectionMatrix,e.viewMatrix),h(Ts,Rs);const r=this._viewingMode===Ge.Global?e.eye:x(Fs,0,0,1);u(Ps,[0,0,0],[-t[0],-t[1],-t[2]],r)}_clampNearFar(e){let{near:t,far:r}=e;return t<2&&(t=2),r<2&&(r=2),t>=r&&(t=2,r=4),{near:t,far:r}}_computeCascadeDistances(e,t){this._numCascades=Math.min(1+Math.floor(St(e/t,4)),this._maxNumCascades);const r=(e-t)/this._numCascades,s=(e/t)**(1/this._numCascades);let a=t,i=t;for(let e=0;e<this._numCascades+1;++e)this._cascadeDistances[e]=Qe(a,i,this._splitSchemeLambda),a*=s,i+=r}get gpuMemoryUsage(){return this._snapshots.reduce(((e,t)=>e+ut(t)),this._fbo?.gpuMemoryUsage??0)}get test(){const e=this;return{maxNumCascades:this._maxNumCascades,cascades:this._cascades,textureSize:this._textureSize,set splitSchemeLambda(t){e._splitSchemeLambda=t},get splitSchemeLambda(){return e._splitSchemeLambda},set warp(t){e._warp=t},get warp(){return e._warp}}}}const Cs=f(),Rs=f(),Ts=f(),Ss=b(),xs=[];for(let e=0;e<8;++e)xs.push(b());const Ds=v(),bs=v(),Es=Ft(),Is=Ft(),Ms=Ft(),Os=Ft(),As=Ft(),Ps=f(),Fs=v(),Ns=[],Hs=f(),Ls=new Float32Array(64),zs=Ft(),js=Ft(),Gs=[Ft(),Ft(),Ft(),Ft()],Us=Ft(),Vs=Ft(),Bs=Ft(),Ws=Ft(),ks=Ft(),qs=Ft(),Zs=Ft();function Xs(e,t){return 3*t+e}const Qs=Ft();function $s(e,t){return Qt(Qs,e[t],e[t+3]),Qs}const Ys=Ft(),Ks=Xt();class Js{constructor(){this.adds=new Pe,this.removes=new Pe,this.updates=new Pe({allocator:e=>e||new ea,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}}class ea{}class ta{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}}var ra,sa;function aa(e){const t=new Map,r=e=>{let r=t.get(e);return r||(r=new ta,t.set(e,r)),r};return e.removes.forAll((e=>{ia(e)&&r(e.material).removes.push(e)})),e.adds.forAll((e=>{ia(e)&&r(e.material).adds.push(e)})),e.updates.forAll((e=>{ia(e.renderGeometry)&&r(e.renderGeometry.material).updates.push(e)})),t}function ia(e){return e.data.indexCount>=1}!function(e){e[e.ADD=0]="ADD",e[e.UPDATE=1]="UPDATE",e[e.REMOVE=2]="REMOVE"}(ra||(ra={})),function(e){e[e.NONE=0]="NONE",e[e.VISIBILITIES=1]="VISIBILITIES",e[e.VERTEXATTRS=2]="VERTEXATTRS",e[e.TRANSFORMATION=4]="TRANSFORMATION",e[e.HIGHLIGHTS=8]="HIGHLIGHTS",e[e.OCCLUDEES=16]="OCCLUDEES"}(sa||(sa={}));class oa{constructor(e,t){this._material=e,this._repository=t,this._map=new Map}destroy(){this._map.forEach(((t,r)=>{e(t)&&this._repository.release(this._material,r)}))}load(t,r,s){if(!this._material.requiresSlot(r,s))return null;this._map.has(s)||this._map.set(s,this._repository.acquire(this._material,r,s));const a=this._map.get(s);if(e(a)){if(a.ensureResources(t)===O.LOADED)return a;this._repository.requestRender()}return null}}class na extends Gt{constructor(e=v()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}}function da(e){e.fragment.code.add(Et`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function ca(e){e.fragment.code.add(Et`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function la(e){e.fragment.uniforms.add(new U("texWaveNormal",(e=>e.waveNormal))),e.fragment.uniforms.add(new U("texWavePerturbation",(e=>e.wavePertubation))),e.fragment.uniforms.add([new W("waveParams",(e=>qe(ha,e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset))),new G("waveDirection",(e=>Qt(ua,e.waveDirection[0]*e.waveVelocity,e.waveDirection[1]*e.waveVelocity)))]),e.include(da),e.fragment.code.add(Et`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture2D(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}const ha=b(),ua=Ft();function ma(e,t){t.spherical?e.vertex.code.add(Et`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`):e.vertex.code.add(Et`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`),t.spherical?e.vertex.code.add(Et`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`):e.vertex.code.add(Et`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)}function pa(e,t){e.include(Ut,t),e.include(Ir),e.include(ca),t.hasCloudsReflections&&e.include(Br,t),t.hasScreenSpaceReflections&&e.include(Wr,t);const r=e.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(Et`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add([new z("lightingSpecularStrength",((e,t)=>t.lighting.mainLight.specularStrength)),new z("lightingEnvironmentStrength",((e,t)=>t.lighting.mainLight.environmentStrength))]),r.code.add(Et`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),t.hasCloudsReflections&&r.code.add(Et`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y*cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),t.hasScreenSpaceReflections?(r.uniforms.add(new H("view",((e,t)=>t.ssr.camera.viewMatrix))),r.uniforms.add(new U("lastFrameColorMap",((e,t)=>t.ssr.lastFrameColorTexture))),r.code.add(Et`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3*dCoords.y), 0.0, 1.0) * heightMod;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture2D(lastFrameColorMap, reprojectedCoordinate).xyz)* reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod*0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor + reflSea * seaColorMod + specular  + foam);`)):r.code.add(Et`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),t.hasCloudsReflections?t.hasScreenSpaceReflections?r.code.add(Et`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(Et`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(Et`return waterRenderedColor;
}`)}const ga=Object.freeze(Object.defineProperty({__proto__:null,build:function(e){const t=new k,{vertex:r,fragment:s}=t;q(r,e),t.include(Cr,e),t.attributes.add(ve.POSITION,"vec3"),t.attributes.add(ve.UV0,"vec2");const a=new W("waterColor",(e=>e.color));if(e.output===_t.Color&&e.isDraped)return t.varyings.add("vpos","vec3"),r.uniforms.add(a),r.code.add(Et`
        void main(void) {
          if (waterColor.a < ${Et.float(Z)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),s.uniforms.add(a),s.code.add(Et`void main() {
gl_FragColor = waterColor;
}`),t;switch(e.output!==_t.Color&&e.output!==_t.Alpha||(t.include(ma,e),t.include(X,e),t.varyings.add("vuv","vec2"),t.varyings.add("vpos","vec3"),t.varyings.add("vnormal","vec3"),t.varyings.add("vtbnMatrix","mat3"),e.hasMultipassTerrain&&t.varyings.add("depth","float"),r.uniforms.add(a),r.code.add(Et`
      void main(void) {
        if (waterColor.a < ${Et.float(Z)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${e.hasMultipassTerrain?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${e.output===_t.Color?"forwardLinearDepth();":""}
      }
    `)),t.include(Q,e),e.output){case _t.Alpha:t.include($,e),s.uniforms.add(a),s.code.add(Et`
        void main() {
          discardBySlice(vpos);
          ${e.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}

          gl_FragColor = vec4(waterColor.a);
        }
      `);break;case _t.Color:t.include(Vt,e),t.include(Bt,{pbrMode:Wt.Disabled,lightingSphericalHarmonicsOrder:2}),t.include(la),t.include($,e),t.include(kt,e),t.include(pa,e),s.uniforms.add([a,new z("timeElapsed",(e=>e.timeElapsed)),r.uniforms.get("view"),r.uniforms.get("localOrigin")]),Y(s,e),s.include(K),Lt(s),zt(s),s.code.add(Et`
      void main() {
        discardBySlice(vpos);
        ${e.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${e.receiveShadows?Et`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        gl_FragColor = delinearizeGamma(final);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${e.transparencyPassType===lr.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `);break;case _t.Normal:t.include(ma,e),t.include(la,e),t.include($,e),t.varyings.add("vpos","vec3"),t.varyings.add("vuv","vec2"),r.uniforms.add(a),r.code.add(Et`
        void main(void) {
          if (waterColor.a < ${Et.float(Z)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),s.uniforms.add(new z("timeElapsed",(e=>e.timeElapsed))),s.code.add(Et`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
gl_FragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`);break;case _t.Highlight:t.include(Rr,e),t.varyings.add("vpos","vec3"),r.uniforms.add(a),r.code.add(Et`
      void main(void) {
        if (waterColor.a < ${Et.float(Z)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),t.include($,e),s.code.add(Et`void main() {
discardBySlice(vpos);
outputHighlight();
}`)}return t}},Symbol.toStringTag,{value:"Module"}));class fa extends te{initializeConfiguration(e,t){t.hasWebGL2Context=e.rctx.type===Sr.WEBGL2,t.spherical=e.viewingMode===Ge.Global,t.doublePrecisionRequiresObfuscation=re(e.rctx)}initializeProgram(e){return new se(e.rctx,fa.shader.get().build(this.configuration),Mt)}_setPipelineState(e){const t=this.configuration,r=e===lr.NONE,s=e===lr.FrontFace;return hr({blending:t.output!==_t.Normal&&t.output!==_t.Highlight&&t.transparent?r?ur:mr(e):null,depthTest:{func:pr(e)},depthWrite:r?t.writeDepth&&gr:fr(e),colorWrite:_r,polygonOffset:r||s?null:vr(t.enableOffset)})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}fa.shader=new ee(ga,(()=>Promise.resolve().then((()=>ga))));class _a extends J{constructor(){super(...arguments),this.output=_t.Color,this.transparencyPassType=lr.NONE,this.spherical=!1,this.receiveShadows=!1,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.hasScreenSpaceReflections=!1,this.doublePrecisionRequiresObfuscation=!1,this.hasCloudsReflections=!1,this.isDraped=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}be([wt({count:_t.COUNT})],_a.prototype,"output",void 0),be([wt({count:lr.COUNT})],_a.prototype,"transparencyPassType",void 0),be([wt()],_a.prototype,"spherical",void 0),be([wt()],_a.prototype,"receiveShadows",void 0),be([wt()],_a.prototype,"hasSlicePlane",void 0),be([wt()],_a.prototype,"transparent",void 0),be([wt()],_a.prototype,"enableOffset",void 0),be([wt()],_a.prototype,"writeDepth",void 0),be([wt()],_a.prototype,"hasScreenSpaceReflections",void 0),be([wt()],_a.prototype,"doublePrecisionRequiresObfuscation",void 0),be([wt()],_a.prototype,"hasCloudsReflections",void 0),be([wt()],_a.prototype,"isDraped",void 0),be([wt()],_a.prototype,"hasMultipassTerrain",void 0),be([wt()],_a.prototype,"cullAboveGround",void 0),be([wt({constValue:Wt.Water})],_a.prototype,"pbrMode",void 0),be([wt({constValue:!0})],_a.prototype,"useCustomDTRExponentForWater",void 0),be([wt({constValue:!0})],_a.prototype,"highStepCount",void 0),be([wt({constValue:!1})],_a.prototype,"useFillLights",void 0);class va extends ae{_updateShadowState(e){e.shadowMap.enabled!==this._material.parameters.receiveShadows&&this._material.setParameters({receiveShadows:e.shadowMap.enabled})}_updateSSRState(e){e.ssr.enabled!==this._material.parameters.hasScreenSpaceReflections&&this._material.setParameters({hasScreenSpaceReflections:e.ssr.enabled})}_updateCloudsReflectionState(t){const r=e(t.cloudsFade.data);r!==this._material.parameters.hasCloudsReflections&&this._material.setParameters({hasCloudsReflections:r})}ensureResources(e){return this._techniqueRepository.constructionContext.waterTextureRepository.ensureResources(e)}beginSlot(e){return this._output===_t.Color&&(this._updateShadowState(e),this._updateSSRState(e),this._updateCloudsReflectionState(e)),this._material.setParameters(this._techniqueRepository.constructionContext.waterTextureRepository.passParameters),this.ensureTechnique(fa,e)}}class ya extends Ot{constructor(e){super(e,new wa),this._configuration=new _a,this.animation=new Zr}getConfiguration(e,t){return this._configuration.output=e,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.receiveShadows=this.parameters.receiveShadows,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.hasScreenSpaceReflections=this.parameters.hasScreenSpaceReflections,this._configuration.hasCloudsReflections=this.parameters.hasCloudsReflections,this._configuration.isDraped=this.parameters.isDraped,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.enableOffset=t.camera.relativeElevation<yr,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}update(e){const t=Math.min(e.camera.relativeElevation,e.camera.distance);this.animation.enabled=Math.sqrt(this.parameters.waveTextureRepeat/this.parameters.waveStrength)*t<Ca;const r=this.animation.advance(e);return this.setParameters({timeElapsed:Fe(this.animation.time)*this.parameters.animationSpeed},!1),this.animation.enabled&&r}intersect(e,t,r,s,a,i,o){At(e,t,s,a,i,void 0,o)}requiresSlot(e,t){switch(t){case _t.Normal:return e===ft.DRAPED_WATER;case _t.Color:if(this.parameters.isDraped)return e===ft.DRAPED_MATERIAL;break;case _t.Alpha:break;case _t.Highlight:return e===ft.OPAQUE_MATERIAL||e===ft.DRAPED_MATERIAL;default:return!1}let r=ft.OPAQUE_MATERIAL;return this.parameters.transparent&&(r=this.parameters.writeDepth?ft.TRANSPARENT_MATERIAL:ft.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL),e===r}createGLMaterial(e){return new va(e)}createBufferWriter(){return new pe(ge)}}class wa extends Pt{constructor(){super(...arguments),this.waveStrength=.06,this.waveTextureRepeat=32,this.waveDirection=Nt(1,0),this.waveVelocity=.05,this.flowStrength=.015,this.flowOffset=-.5,this.animationSpeed=.35,this.timeElapsed=0,this.color=D(0,0,0,0),this.transparent=!0,this.writeDepth=!0,this.hasSlicePlane=!1,this.isDraped=!1,this.receiveShadows=!0,this.hasScreenSpaceReflections=!1,this.hasCloudsReflections=!1}}const Ca=35e3;class Ra{constructor(){this.first=0,this.count=0}}class Ta{constructor(e=0,t=0){this.from=e,this.to=t}}class Sa extends Ta{constructor(e,t,r,s,a,i){super(t,r),this.id=e,this.isVisible=s,this.hasHighlights=a,this.hasOccludees=i}}function xa(e){return Array.from(e.values()).sort(Da)}function Da(e,t){return e.from===t.from?e.to-t.to:e.from-t.from}function ba(e,t){const r=e.back();if(null==r){const r=e.pushNew();return r.first=t.from,void(r.count=t.to-t.from)}if(a=t,(s=r).first+s.count>=a.from){const e=t.from-r.first+t.to-t.from;r.count=e}else{const r=e.pushNew();r.first=t.from,r.count=t.to-t.from}var s,a}class Ea{constructor(e,t){this._pool=e,this._size=0,this._buffer=e.newBuffer(Ia(t))}dispose(){this._buffer=this._pool.deleteBuffer(this._buffer),this._size=0}release(){this.erase(0,this._size),this.dispose()}get buffer(){return this._buffer}get size(){return this._size}grow(e){this._resize(this._size+e,!0).dispose()}allocate(e){return this._resize(e,!1)}_resize(e,t){let r;const s=function(e,t,r){return t<=r?e>=r?e:Ia(Math.max(2*e,r)):e<=2*r?e:Ia(r)}(this._buffer.length,this._size,e);if(this._buffer.length!==s){const e=this._pool.newBuffer(s);t&&(e.array.set(this._buffer.array.subarray(0,Math.min(this._size,s))),e.vao.vertexBuffers.geometry.setSubData(e.array,0,0,e.array.length)),r=this._buffer,this._buffer=e}const a=this._size;return this._size=e,r?{dispose:()=>{r.array.fill(0,0,a),this._pool.deleteBuffer(r)},copy:(e,t,s)=>this._buffer.array.set(r.array.subarray(t,s),e),hasNewBuffer:!0}:{dispose:()=>{},copy:(e,t,r)=>{e!==t&&this._buffer.array.copyWithin(e,t,r)},hasNewBuffer:!1}}erase(e,t){this._buffer.array.fill(0,e,t)}}function Ia(e){return 65536*Math.ceil(e/65536)}class Ma{constructor(e,t,r,s){this.vao=new ie(e,t,{geometry:r},{geometry:mt.createVertex(e,dt.STATIC_DRAW)}),this.array=new Float32Array(s),this.vao.vertexBuffers.geometry.setSize(this.array.byteLength)}dispose(){this.vao.dispose(!0)}get length(){return this.array.length}}const Oa=Dr+1;class Aa{constructor(e,t,r){this._rctx=e,this._locations=t,this._layout=r,this._cache=e.newCache(`MergedRenderer pool ${o()}`,Pa)}dispose(){this._cache.destroy()}newBuffer(t){const r=t.toString(),s=this._cache.pop(r);if(e(s)){const e=s.pop();return s.length>0&&this._cache.put(r,s,e.array.byteLength*s.length,Oa),e}return new Ma(this._rctx,this._locations,this._layout,t)}deleteBuffer(t){const r=t.array.byteLength,s=t.array.length.toString(),a=this._cache.pop(s);return e(a)?(a.push(t),this._cache.put(s,a,r*a.length,-1)):this._cache.put(s,[t],r,-1),null}}function Pa(e,t){if(t===xr.ALL)return void e.forEach((e=>e.dispose()));const r=e.pop(),s=e.length*r.array.byteLength;return r.dispose(),s}class Fa{constructor(e,t,r){this._rctx=e,this._materialRepository=t,this._material=r,this.type="MergedRenderer",this._dataByOrigin=new Map,this._renderCommandData=new Pe,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new oa(this._material,this._materialRepository),this._bufferWriter=r.createBufferWriter(),this._bufferPool=new Aa(e,r.vertexAttributeLocations,cr(this._bufferWriter.vertexBufferLayout))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach((e=>e.geometry.dispose())),this._dataByOrigin.clear(),this._bufferPool.dispose()}get isEmpty(){return 0===this._dataByOrigin.size}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this._material instanceof ya}get rendersOccluded(){return!this.isEmpty&&this._material.renderOccluded!==It.Occlude}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_addAndRemoveGeometries(e,t){const r=this._bufferWriter,s=r.vertexBufferLayout.stride/4,a=this._dataByOrigin,i=function(e,t){const r=new Map;for(const t of e)Ha(r,t,!0);for(const e of t)Ha(r,e,!1);return r}(e,t);i.forEach(((e,t)=>{i.delete(t);const o=e.add.reduce(((e,t)=>e+r.elementCount(t.data)),0);let n=a.get(t);if(null==n)Tt(0===e.remove.length),n=new Ga(e.origin,new Ea(this._bufferPool,o*s)),a.set(t,n);else if(0===e.add.length&&n.instances.size===e.remove.length)return n.geometry.dispose(),void a.delete(t);let d=0;n.instances.forEach((e=>d+=e.to-e.from));const c=e.remove.reduce(((e,t)=>e+r.elementCount(t.data)),0),l=n.geometry.size,h=(d+o-c)*s,u=Va;if(h>65536&&(h<l/2||l-h>1048576)?this._removeAndRebuild(n,e.remove,s,h,u):e.remove.length>0&&this._remove(n,e.remove,s,u),e.add.length>0){const t=Ba;bt(t,-e.origin[0],-e.origin[1],-e.origin[2]),this._add(n,e.add,s,t,u)}const m=n.geometry.buffer.vao.vertexBuffers.geometry;ja(u),u.forAll((({from:e,to:t})=>{if(e<t){const r=n.geometry.buffer.array;m.setSubData(r,e,e,t)}})),u.clear(),n.drawCommandsDirty=!0}))}_updateGeometries(e){const t=this._bufferWriter,r=t.vertexBufferLayout.stride/4;for(const s of e){const e=s.renderGeometry,a=this._dataByOrigin.get(e.origin.id),i=a&&a.instances.get(e.id);if(!i)return;const o=s.updateType;if(o&sa.VISIBILITIES&&(i.isVisible=e.instanceParameters.visible),o&(sa.HIGHLIGHTS|sa.VISIBILITIES)){const t=e.instanceParameters.visible;i.hasHighlights=!!e.instanceParameters.highlights&&t}if(o&sa.OCCLUDEES&&(i.hasOccludees=!!e.instanceParameters.occludees),o&(sa.VERTEXATTRS|sa.TRANSFORMATION)){const{array:s,vao:o}=a.geometry.buffer;ye(e,Wa,ka),t.write(Wa,ka,e.data,t.vertexBufferLayout.createView(s.buffer),i.from),Tt(i.from+t.elementCount(e.data)===i.to,"material VBO layout has changed"),o.vertexBuffers.geometry.setSubData(s,i.from*r,i.from*r,i.to*r)}a.drawCommandsDirty=!0}}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((e=>{e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,Oe(e.instances,(t=>(t.isVisible?(t.hasHighlights&&(this._hasHighlights=!0,e.hasHighlights=!0),t.hasOccludees&&(this._hasOccludees=!0,e.hasOccludees=!0)):e.hasHiddenInstances=!0,e.hasHiddenInstances&&e.hasHighlights&&e.hasOccludees)))})),this._dataByOrigin.forEach((e=>{e.drawCommandsDirty&&((e=>{if(e.drawCommandsDefault.clear(),e.drawCommandsHighlight.clear(),e.drawCommandsOccludees.clear(),e.drawCommandsShadowHighlightRest.clear(),0===e.instances.size)return;if(!La(e)){const t=e.drawCommandsDefault.pushNew();return t.first=1/0,t.count=0,e.instances.forEach((e=>{t.first=Math.min(t.first,e.from),t.count=Math.max(t.count,e.to)})),void(t.count-=t.first)}const t=xa(e.instances);for(const r of t)r.isVisible&&(r.hasOccludees?ba(e.drawCommandsOccludees,r):ba(e.drawCommandsDefault,r),r.hasHighlights?ba(e.drawCommandsHighlight,r):ba(e.drawCommandsShadowHighlightRest,r))})(e),e.drawCommandsDirty=!1)}))}updateAnimation(e){return this._material.update(e)}requiresSlot(e,t){return this._material.requiresSlot(e,t)}render(t,s){if(!this.requiresSlot(s.slot,t))return!1;const a=t===_t.Highlight||t===_t.ShadowHighlight;if(a&&!this._hasHighlights)return!1;const i=t===_t.ShadowExludeHighlight,o=!(a||i);if(this._dataByOrigin.forEach((e=>{if(a&&!e.hasHighlights)return;const t=(a?e.drawCommandsHighlight:i&&La(e)?e.drawCommandsShadowHighlightRest:e.drawCommandsDefault)||null,r=o&&e.drawCommandsOccludees||null;(t?.length||r?.length)&&this._renderCommandData.push(new Ua(e.origin,e.geometry,t,r))})),0===this._renderCommandData.length)return!1;const n=this._rctx,d=this._glMaterials.load(n,s.slot,t);if(r(d))return this._renderCommandData.clear(),!1;const c=d.beginSlot(s),l=n.bindTechnique(c,this._material.parameters,s);return this._renderCommandData.forAll((t=>{l.bindDraw(t,s,this._material.parameters);const{geometry:r,renderCommands:a,occludeeCommands:i}=t;c.ensureAttributeLocations(r.buffer.vao),n.bindVAO(r.buffer.vao);const o=c.primitiveType;e(a)&&a.length>0&&(c.bindPipelineState(n,s.slot,!1),a.forAll((e=>n.drawArrays(o,e.first,e.count)))),e(i)&&i.length>0&&(c.bindPipelineState(n,s.slot,!0),i.forAll((e=>n.drawArrays(o,e.first,e.count))))})),this._renderCommandData.clear(),!0}_removeAndRebuild(e,t,r,s,a){for(const r of t)e.instances.delete(r.id);const i=xa(e.instances);e.instances.clear();const o=e.geometry.size,n=e.geometry.allocate(s);let d=0;for(const t of i){const s=t.from*r,a=t.to*r;n.copy(d,s,a),t.from=d/r,d+=a-s,t.to=d/r,e.instances.set(t.id,t)}a.push(new Ta(0,n.hasNewBuffer?e.geometry.buffer.array.length:o)),n.dispose(),e.geometry.erase(d,a.back().to),e.holes.clear()}_remove(e,t,r,s){for(const a of t){const t=a.id,i=e.instances.get(t),o=i.from*r,n=i.to*r;e.geometry.erase(o,n),e.holes.push(new Ta(i.from,i.to)),e.instances.delete(t),s.push(new Ta(o,n))}ja(e.holes)}_add(t,s,a,i,o){if(0===s.length)return;const n=this._bufferWriter;let d=n.vertexBufferLayout.createView(t.geometry.buffer.array.buffer);const l=t.holes.length>0;let u=Number.MAX_SAFE_INTEGER,p=Number.MIN_SAFE_INTEGER;for(const g of s){const s=e(g.transformation)?c(Wa,i,g.transformation):i;h(ka,s);const f=m(ka,ka),_=n.elementCount(g.data),v=_*a;let y=za(t.holes,_);r(y)&&(y=t.geometry.size/a,t.geometry.grow(v),d=n.vertexBufferLayout.createView(t.geometry.buffer.array.buffer)),n.write(s,f,g.data,d,y);const w=g.instanceParameters.visible,C=!!g.instanceParameters.highlights&&w,R=!!g.instanceParameters.occludees,T=new Sa(g.id,y,y+_,w,C,R);Tt(null==t.instances.get(g.id)),t.instances.set(g.id,T),l?o.push(new Ta(T.from*a,T.to*a)):(u=Math.min(T.from,u),p=Math.max(T.to,p))}l||o.push(new Ta(u*a,p*a))}get test(){return{material:this._material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}}class Na{constructor(e){this.origin=e,this.add=new Array,this.remove=new Array}}function Ha(e,t,s){const a=t.origin;if(r(a))return;let i=e.get(a.id);null==i&&(i=new Na(a.vec3),e.set(a.id,i)),s?i.add.push(t):i.remove.push(t)}function La(e){return e.hasOccludees||e.hasHighlights||e.hasHiddenInstances}function za(e,t){let r;if(!e.some((e=>!(e.to-e.from<t||(r=e,0)))))return null;const s=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),s}function ja(e){const t=new Map;e.forAll((e=>t.set(e.from,e)));let r=!0;for(;r;)r=!1,e.forEach((s=>{const a=t.get(s.to);a&&(s.to=a.to,t.delete(a.from),e.removeUnordered(a),r=!0)}))}class Ga{constructor(e,t){this.origin=e,this.geometry=t,this.instances=new Map,this.holes=new Pe({deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!1,this.drawCommandsDefault=new Pe({allocator:e=>e||new Ra,deallocator:e=>e}),this.drawCommandsHighlight=new Pe({allocator:e=>e||new Ra,deallocator:e=>e}),this.drawCommandsOccludees=new Pe({allocator:e=>e||new Ra,deallocator:e=>e}),this.drawCommandsShadowHighlightRest=new Pe({allocator:e=>e||new Ra,deallocator:e=>e})}}class Ua extends na{constructor(e,t,r,s){super(e),this.geometry=t,this.renderCommands=r,this.occludeeCommands=s}}const Va=new Pe({deallocator:null}),Ba=f(),Wa=f(),ka=f();let qa=class extends Ee{constructor(e){super(e),this._pending=new Za,this._changes=new Js,this._materialRenderers=new Map,this._sortedMaterialRenderers=new Pe,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forEach((e=>e.dispose())),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return Oe(this._materialRenderers,(e=>e.rendersOccluded))}get isEmpty(){return!this.updating&&0===this._materialRenderers.size&&0===this._geometries.size}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const e=aa(this._changes);let t=!1,r=!1,s=!1;return e.forEach(((e,a)=>{let i=this._materialRenderers.get(a);if(!i&&e.adds.length>0&&(i=new Fa(this.rctx,this._materialRepository,a),this._materialRenderers.set(a,i),t=!0,r=!0,s=!0),!i)return;const o=r||i.hasHighlights,n=s||i.hasWater;i.modify(e),r=r||o!==i.hasHighlights,s=s||n!==i.hasWater,i.isEmpty&&(this._materialRenderers.delete(a),i.dispose(),t=!0)})),this._changes.clear(),t&&this._updateSortedMaterialRenderers(),r&&(this._hasHighlights=Oe(this._materialRenderers,(e=>e.hasHighlights))),s&&(this._hasWater=Oe(this._materialRenderers,(e=>e.hasWater))),this.notifyChange("updating"),!0}addGeometries(e,t){if(0===e.length)return;const r=this._validateRenderGeometries(e);for(const e of r)this._geometries.set(e.id,e);const s=this._pending.empty;for(const e of r)this._pending.adds.add(e);s&&this.notifyChange("updating"),t===ra.UPDATE&&this._notifyGraphicGeometryChanged(e)}removeGeometries(e,t){const r=this._pending.empty,a=this._pending.adds;for(const t of e)a.has(t)?(this._pending.removed.add(t),a.delete(t)):this._pending.removed.has(t)||this._pending.removes.add(t),this._geometries.delete(s(t.id));r&&!this._pending.empty&&this.notifyChange("updating"),t===ra.UPDATE&&this._notifyGraphicGeometryChanged(e)}modifyGeometries(e,t){const r=0===this._changes.updates.length;for(const r of e){const e=this._changes.updates.pushNew();e.renderGeometry=this._validateRenderGeometry(r),e.updateType=t}switch(r&&this._changes.updates.length>0&&this.notifyChange("updating"),t){case sa.TRANSFORMATION:case sa.VERTEXATTRS:return this._notifyGraphicGeometryChanged(e);case sa.VISIBILITIES:return this._notifyGraphicVisibilityChanged(e)}}updateAnimation(e){let t=!1;return this._sortedMaterialRenderers.forAll((({materialRenderer:r})=>t=r.updateAnimation(e)||t)),t}render(e,t){for(let r=0;r<this._sortedMaterialRenderers.length;r++){const s=this._sortedMaterialRenderers.data[r];s.material.shouldRender(e)&&s.materialRenderer.render(e.output,t)}}intersect(e,t,r,s,a){return this._geometries.forEach((i=>{if(s&&!s(i))return;this._intersectRenderGeometry(i,r,t,0,e,a);const o=this.rendererContext.longitudeCyclical;o&&(i.boundingSphere[0]-i.boundingSphere[3]<o.min&&this._intersectRenderGeometry(i,r,t,o.range,e,a),i.boundingSphere[0]+i.boundingSphere[3]>o.max&&this._intersectRenderGeometry(i,r,t,-o.range,e,a)),a++})),a}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let e=0;this._materialRenderers.forEach(((t,r)=>{r.insertOrder=e++,this._sortedMaterialRenderers.push({material:r,materialRenderer:t})})),this._sortedMaterialRenderers.sort(((e,t)=>{const r=t.material.renderPriority-e.material.renderPriority;return 0!==r?r:e.material.insertOrder-t.material.insertOrder}))}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let e=0;e<this._changes.updates.length;){const t=this._changes.updates.data[e];this._pending.has(t.renderGeometry)?this._changes.updates.removeUnorderedIndex(e):e++}this._pending.clear()}_intersectRenderGeometry(t,r,s,a,i,o){if(!t.instanceParameters.visible)return;let n=0;e(t.transformation)&&(a+=t.transformation[12],n=t.transformation[13]),Xa[0]=s[0]-a,Xa[1]=s[1]-n,Xa[2]=1,Qa[0]=s[0]-a,Qa[1]=s[1]-n,Qa[2]=0,t.screenToWorldRatio=this.rendererContext.screenToWorldRatio,t.material.intersect(t,null,t.getShaderTransformation(),i,Xa,Qa,((e,s,a)=>{!function(e,t,r,s,a,i,o){const n={layerUid:i,graphicUid:o,triangleNr:t},d=t=>{t.set(dr.OVERLAY,n,e.dist,e.normal,e.transformation,r,s)};if((null==a.results.min.drapedLayerOrder||r>=a.results.min.drapedLayerOrder)&&(null==a.results.min.dist||a.results.ground.dist<=a.results.min.dist)&&d(a.results.min),a.options.store!==or.MIN&&(null==a.results.max.drapedLayerOrder||r<a.results.max.drapedLayerOrder)&&(null==a.results.max.dist||a.results.ground.dist>a.results.max.dist)&&d(a.results.max),a.options.store===or.ALL){const e=nr(a.ray);d(e),a.results.all.push(e)}}(r,a,t.material.renderPriority,o,i,t.layerUid,t.graphicUid)}),t.calculateShaderTransformation,r)}_notifyGraphicGeometryChanged(t){if(r(this.drapeSource.notifyGraphicGeometryChanged))return;let s;for(const r of t){const t=r.graphicUid;e(t)&&t!==s&&(this.drapeSource.notifyGraphicGeometryChanged(t),s=t)}}_notifyGraphicVisibilityChanged(t){if(r(this.drapeSource.notifyGraphicVisibilityChanged))return;let s;for(const r of t){const t=r.graphicUid;e(t)&&t!==s&&(this.drapeSource.notifyGraphicVisibilityChanged(t),s=t)}}_validateRenderGeometries(e){for(const t of e)this._validateRenderGeometry(t);return e}_validateRenderGeometry(e){return r(e.origin)&&(e.origin=this._localOriginFactory.getOrigin(e.boundingSphere)),e}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};be([ze()],qa.prototype,"drapeSource",void 0),be([ze()],qa.prototype,"updating",null),be([ze()],qa.prototype,"rctx",null),be([ze()],qa.prototype,"rendererContext",void 0),be([ze()],qa.prototype,"_materialRepository",null),be([ze()],qa.prototype,"_localOriginFactory",null),qa=be([je("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],qa);class Za{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return 0===this.adds.size&&0===this.removes.size&&0===this.removed.size}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}const Xa=v(),Qa=v();class $a extends te{initializeProgram(e){return new se(e.rctx,$a.shader.get().build(),Mt)}initializePipeline(){return this.configuration.hasAlpha?hr({blending:wr(ct.SRC_ALPHA,ct.ONE,ct.ONE_MINUS_SRC_ALPHA,ct.ONE_MINUS_SRC_ALPHA),colorWrite:_r}):hr({colorWrite:_r})}}$a.shader=new ee(oe,(()=>import("./bufferWriterUtils.js").then((e=>e.at))));class Ya extends yt{constructor(){super(...arguments),this.hasAlpha=!1}}be([wt()],Ya.prototype,"hasAlpha",void 0);let Ka=class extends(ns(Ee)){constructor(e){super(e),this._overlays=null,this._overlayRenderTarget=null,this._hasHighlights=!1,this._rendersOccluded=!1,this._hasWater=!1,this._handles=new Me,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new Pe,this._passParameters=new ne,this._rctx=null,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this.worldToPCSRatio=1,this.events=new Ie,this.longitudeCyclical=null}get _bindParameters(){return this._renderContext.bindParameters}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}initialize(){const e=this.view._stage.renderView;this._rctx=e.renderingContext;const t=e.waterTextureRepository;this._stippleTextureRepository=new fe(e.renderingContext),this._shaderTechniqueRepository=new ss({rctx:this._rctx,viewingMode:Ge.Local,stippleTextureRepository:this._stippleTextureRepository,waterTextureRepository:t}),this._renderContext=new gs(this._rctx,new ws(this._rctx,this.view.state.viewingMode),new qt(this._shaderTechniqueRepository,this._rctx,(()=>{}))),this._handles.add([Ne((()=>t.updating),(()=>this.events.emit("content-changed")),He),Ne((()=>this.spatialReference),(e=>this._localOriginFactory=new ms(e)),He),Le((()=>this.view.allLayerViews),"after-changes",(()=>this._sortedDrapeSourceRenderersDirty=!0))]),this._materialRepository=new ls(e.textureRepository,this._shaderTechniqueRepository,(e=>{(e.renderOccluded&ai)>0!==this._rendersOccluded&&this._updateRendersOccluded(),this.events.emit("content-changed"),this.notifyChange("updating")}),(()=>this.events.emit("content-changed"))),this._bindParameters.slot=ft.DRAPED_MATERIAL,this._bindParameters.highlightDepthTexture=de(this._rctx),this._bindParameters.camera=ri,this._bindParameters.transparencyPassType=lr.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new Zt(y(1,1,1))]),this._handles.add(this.view.resourceController.scheduler.registerTask(br.STAGE,this))}dispose(){this._handles.destroy(),this._renderers.forEach((e=>e.destroy())),this._renderers.clear(),this._debugTextureTechnique=a(this._debugTextureTechnique),this._passParameters.texture=t(this._passParameters.texture),this._bindParameters.highlightDepthTexture=t(this._bindParameters.highlightDepthTexture),this._shaderTechniqueRepository=t(this._shaderTechniqueRepository),this._temporaryFBO=t(this._temporaryFBO),this._quadVAO=t(this._quadVAO),this.disposeOverlays()}get updating(){return this._sortedDrapeSourceRenderersDirty||Oe(this._renderers,(e=>e.updating))}get hasOverlays(){return e(this._overlays)&&e(this._overlayRenderTarget)}get gpuMemoryUsage(){return e(this._overlayRenderTarget)?this._overlayRenderTarget.gpuMemoryUsage:0}createGeometryDrapeSourceRenderer(e){return this.createDrapeSourceRenderer(e,qa)}createDrapeSourceRenderer(t,r,s){const a=this._renderers.get(t);e(a)&&a.destroy();const i=new r({...s,rendererContext:this,drapeSource:t});return this._renderers.set(t,i),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in t&&this._handles.add(Ne((()=>t.fullOpacity),(()=>this.events.emit("content-changed"))),t),i}removeDrapeSourceRenderer(e){if(r(e))return;const t=this._renderers.get(e);r(t)||(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(e),this._handles.remove(e),t.destroy())}collectUnusedRenderTargetMemory(t){let r=!1;if(e(this._overlayRenderTarget))for(const e of this._overlayRenderTarget.renderTargets){const s=this.overlays[0].validTargets[e.type]||!this.overlays[1].validTargets[e.type];r=this._overlayRenderTarget.validateUsageForTarget(s,e,t)||r}return r}get overlays(){return i(this._overlays,[])}ensureDrapeTargets(t){e(this._overlays)&&this._overlays.forEach((e=>e.hasTargetWithoutRasterImage=n(t,(e=>e.drapeTargetType===Hr.WithoutRasterImage))))}ensureDrapeSources(t){e(this._overlays)&&this._overlays.forEach((e=>{e.hasDrapedFeatureSource=n(t,(e=>e.drapeSourceType===Nr.Features)),e.hasDrapedRasterSource=n(t,(e=>e.drapeSourceType===Nr.RasterImage))}))}ensureOverlays(e,t){r(this._overlays)&&(this._overlayRenderTarget=new ts(this._rctx),this._overlays=[new $r(Be.INNER,this._overlayRenderTarget),new $r(Be.OUTER,this._overlayRenderTarget)]),this.ensureDrapeTargets(e),this.ensureDrapeSources(t)}disposeOverlays(){this._overlays=null,this._overlayRenderTarget=t(this._overlayRenderTarget),this.events.emit("textures-disposed")}get running(){return this.updating}runTask(e){this._processDrapeSources(e,(()=>!0))}_processDrapeSources(t,r){let s=!1;for(const[e,a]of this._renderers){if(t.done)break;(e.destroyed||r(e))&&a.commitChanges()&&(s=!0,t.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,s=!0,this._updateSortedDrapeSourceRenderers()),s&&(e(this._overlays)&&0===this._renderers.size&&this.disposeOverlays(),this.notifyChange("updating"),this.events.emit("content-changed"),this._updateHasHighlights(),this._updateRendersOccluded(),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(Er,(e=>e.updatePolicy===A.SYNC))}isEmpty(){if(Ue.OVERLAY_DRAW_DEBUG_TEXTURE)return!1;for(const e of this._renderers.values())if(!e.isEmpty)return!1;return!0}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return this._rendersOccluded}updateAnimation(e){let t=!1;return this._renderers.forEach((r=>t=r.updateAnimation(e)||t)),t}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawTarget(t,r,s){const a=t.canvasGeometries;if(0===a.numViews)return!1;this._screenToWorldRatio=s*t.mapUnitsPerPixel;const i=r.output;if(this.isEmpty()||i===_t.Highlight&&!this.hasHighlights||i===_t.Normal&&!this.hasWater||!t.hasSomeSizedView())return!1;const o=r.fbo;if(!o.isValid())return!1;const n=2*t.resolution,d=t.resolution;o.resize(n,d);const c=this._rctx;ri.pixelRatio=t.pixelRatio*s,this._renderContext.output=i,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=i===_t.Normal?ft.DRAPED_WATER:ft.DRAPED_MATERIAL,t.applyViewport(this._rctx),o.bind(c),t.index===Be.INNER&&(c.setClearColor(0,0,0,0),c.clearSafe(nt.COLOR_BUFFER_BIT));const l=r.type===Ve.ColorNoRasterImage?Ja.ExcludeRasterImage:r.type===Ve.Occluded?Ja.OccludedOnly:Ja.Normal;if(l===Ja.OccludedOnly&&(this._renderContext.renderOccludedMask=ai),Ue.OVERLAY_DRAW_DEBUG_TEXTURE&&l!==Ja.OccludedOnly)for(let e=0;e<a.numViews;e++)this._setViewParameters(a.extents[e],t,ri),this._drawDebugTexture(t.resolution,ti[t.index]);return this._renderers.size>0&&this._sortedRenderers.forAll((({drapeSource:r,renderer:s})=>{if(l===Ja.ExcludeRasterImage&&r.drapeSourceType===Nr.RasterImage)return;const{fullOpacity:h}=r,u=e(h)&&h<1&&i===_t.Color;u&&(this.bindTemporaryFramebuffer(this._rctx,n,d),c.clearSafe(nt.COLOR_BUFFER_BIT));for(let e=0;e<a.numViews;e++)this._setViewParameters(a.extents[e],t,ri),s.render(this._renderContext,this._bindParameters);u&&e(this._temporaryFBO)&&(o.bind(c),this.view._stage.renderView.compositingHelper.compositeOverlay(this._renderContext.bindParameters,this._temporaryFBO.getTexture(),h,t.index))})),c.bindFramebuffer(null),o.generateMipMap(),this._renderContext.resetRenderOccludedMask(),!0}bindTemporaryFramebuffer(e,t,s){r(this._temporaryFBO)&&(this._temporaryFBO=new Jr(e,!1)),this._temporaryFBO.resize(t,s),this._temporaryFBO.bind(e)}async reloadShaders(){await this._shaderTechniqueRepository.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(e,t,r,s){let a=0;for(const i of this._renderers.values())a=i.intersect?.(e,t,r,s,a)??a}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),0===this._renderers.size)return;const e=this.view.map.allLayers;this._renderers.forEach(((t,r)=>{const s=e.indexOf(r.layer);this._sortedRenderers.push(new ei(r,t,s<0?1/0:s))})),this._sortedRenderers.sort(((e,t)=>e.index-t.index))}_setViewParameters(e,t,r){r.viewport[0]=r.viewport[1]=0,r.viewport[2]=r.viewport[3]=t.resolution,l(r.projectionMatrix,0,e[2]-e[0],0,e[3]-e[1],r.near,r.far),p(r.viewMatrix,[-e[0],-e[1],0]),this._bindParameters.camera=r}_updateHasWater(){const e=Oe(this._renderers,(e=>e.hasWater));e!==this._hasWater&&(this._hasWater=e,this.events.emit("has-water",e))}_updateHasHighlights(){const e=Oe(this._renderers,(e=>e.hasHighlights));e!==this._hasHighlights&&(this._hasHighlights=e,this.events.emit("has-highlights",e))}_updateRendersOccluded(){const e=Oe(this._renderers,(e=>e.rendersOccluded));e!==this._rendersOccluded&&(this._rendersOccluded=e,this.events.emit("renders-occluded",e))}_drawDebugTexture(e,t){this._ensureDebugPatternResources(e,e,t);const r=this._rctx;r.bindTechnique(this._debugTextureTechnique,this._passParameters,null),r.bindVAO(this._quadVAO),r.drawArrays(lt.TRIANGLE_STRIP,0,pt(this._quadVAO,"geometry"))}_ensureDebugPatternResources(e,t,r){if(x(this._passParameters.color,r[0],r[1],r[2]),this._passParameters.texture)return;const s=new Uint8Array(e*t*4);let a=0;for(let r=0;r<t;r++)for(let i=0;i<e;i++){const o=Math.floor(i/10),n=Math.floor(r/10);o<2||n<2||10*o>e-20||10*n>t-20?(s[a++]=255,s[a++]=255,s[a++]=255,s[a++]=255):(s[a++]=255,s[a++]=255,s[a++]=255,s[a++]=1&o&&1&n?1&i^1&r?0:255:1&o^1&n?0:128)}this._passParameters.texture=new ir(this._rctx,{target:rt.TEXTURE_2D,pixelFormat:st.RGBA,dataType:at.UNSIGNED_BYTE,samplingMode:ot.NEAREST,width:e,height:t},s);const i=new Ya;i.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniqueRepository.acquire($a,i),this._quadVAO=ce(this._rctx)}get test(){return{drapeSourceRenderers:this._renderers,getDrapeSourceRenderer:e=>this._renderers.get(e)}}};var Ja;be([ze()],Ka.prototype,"_sortedDrapeSourceRenderersDirty",void 0),be([(e,t)=>{e.hasOwnProperty("_managedDisposables")||(e._managedDisposables=e._managedDisposables?.slice()??[]),e._managedDisposables?.unshift(t)}],Ka.prototype,"_shaderTechniqueRepository",void 0),be([(e,t)=>{e.hasOwnProperty("_managedDisposables")||(e._managedDisposables=e._managedDisposables?.slice()??[]),e._managedDisposables?.unshift(t)}],Ka.prototype,"_stippleTextureRepository",void 0),be([ze({constructOnly:!0})],Ka.prototype,"view",void 0),be([ze()],Ka.prototype,"worldToPCSRatio",void 0),be([ze()],Ka.prototype,"spatialReference",void 0),be([ze({type:Boolean,readOnly:!0})],Ka.prototype,"updating",null),Ka=be([je("esri.views.3d.terrain.OverlayRenderer")],Ka),function(e){e[e.Normal=0]="Normal",e[e.OccludedOnly=1]="OccludedOnly",e[e.ExcludeRasterImage=2]="ExcludeRasterImage"}(Ja||(Ja={}));class ei{constructor(e,t,r){this.drapeSource=e,this.renderer=t,this.index=r}}const ti=[[1,.5,.5],[.5,.5,1]],ri=new Ct;ri.near=1,ri.far=1e4,ri.relativeElevation=null;const si=-2,ai=It.OccludeAndTransparent;class ii{constructor(){this.visible=!0}}class oi{constructor(e,t,r={}){this.data=e,this.material=t,this.boundingSphere=b(),this.instanceParameters=new ii,this._transformation=f(),this._shaderTransformationDirty=!0,this.layerUid=i(r.layerUid,null),this.graphicUid=i(r.graphicUid,null),this.id=r.id?r.id:o(),this.boundingInfo=i(r.boundingInfo,null),this.calculateShaderTransformation=i(r.calculateShaderTransformation,null),this.castShadow=!!r.castShadow&&r.castShadow}get transformation(){return this._transformation}updateTransformation(e){e(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(e,t,s=E(e)){r(this.boundingInfo)||(S(t,this.boundingInfo.getCenter(),e),t[3]=this.boundingInfo.getBSRadius()*s)}get hasShaderTransformation(){return e(this.calculateShaderTransformation)}get primitiveType(){return this.data.primitiveType}getShaderTransformation(){return r(this.calculateShaderTransformation)?i(this.transformation,_):(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=f()),g(this._shaderTransformation,this.calculateShaderTransformation(i(this.transformation,_))),this._shaderTransformationDirty=!1),this._shaderTransformation)}computeAttachmentOrigin(t){if(this.material.computeAttachmentOrigin)return!!this.material.computeAttachmentOrigin(this,t)&&(e(this._transformation)&&S(t,t,this._transformation),!0);const r=this.indices.get(ve.POSITION),s=this.vertexAttributes.get(ve.POSITION);return!!le(s,r,t)&&(e(this._transformation)&&S(t,t,this._transformation),!0)}get indices(){return this.data.indices}get vertexAttributes(){return this.data.vertexAttributes}addHighlight(){const e=new _e(P.Highlight),t=this.instanceParameters;return t.highlights=we(t.highlights,e),e}removeHighlight(e){const t=this.instanceParameters;t.highlights=Ce(t.highlights,e)}}function ni(e,t,r,s){const a="polygon"===e.type?Te.CCW_IS_HOLE:Te.NONE,i="polygon"===e.type?e.rings:e.paths,{position:o,outlines:n}=Se(i,e.hasZ,a),d=new Float64Array(o.length),c=De(o,e.spatialReference,0,d,0,o,0,o.length/3,t,r,s),l=null!=c;return{lines:l?ci(n,o,d):[],projectionSuccess:l,sampledElevation:c}}function di(e,t){const r="polygon"===e.type?Te.CCW_IS_HOLE:Te.NONE,s="polygon"===e.type?e.rings:e.paths,{position:a,outlines:i}=Se(s,!1,r),o=Re(a,e.spatialReference,0,a,t,0,a.length/3);for(let e=2;e<a.length;e+=3)a[e]=-2;return{lines:o?ci(i,a):[],projectionSuccess:o}}function ci(e,t,r){const s=new Array;for(const{index:a,count:i}of e){if(i<=1)continue;const e=3*a,o=e+3*i;s.push({position:t.subarray(e,o),mapPosition:r?r.subarray(e,o):void 0})}return s}export{Zr as A,qr as B,Br as C,na as D,ni as E,Ar as F,Ir as G,di as H,oa as I,wa as J,ya as K,Nr as L,Fa as M,ma as N,Ka as O,Hr as P,oi as R,qa as S,$a as T,pa as W,Or as a,Mr as b,Pr as c,Fr as d,jr as e,Yr as f,Qr as g,Lr as h,zr as i,ra as j,sa as k,ms as l,ds as m,cs as n,ai as o,ws as p,vs as q,fs as r,aa as s,us as t,Ya as u,ns as v,ss as w,ls as x,Js as y,si as z};
