/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{g as i}from"./assets.js";import{h as t}from"./object.js";import{k as s}from"./definitions.js";import{P as h,G as e}from"./Geometry.js";import{b as n}from"./GeometryUtils2.js";let _=null,l=null;async function a(){return _||(_=async function(){const s=t("esri-csp-restrictions")?await import("./libtess-asm.js").then((i=>i.l)):await import("./libtess.js").then((i=>i.l));l=await s.load({locateFile:t=>i(`esri/core/libs/libtess/${t}`)})}()),_}function x(i,t){const s=Math.max(i.length,128e3);return l.triangulate(i,t,s)}class o{constructor(i,t,s){this.ratio=i,this.x=t,this.y=s}}class y{constructor(i,t,h,e=8,n=8){this._lines=[],this._starts=[],this.validateTessellation=!0,this._pixelRatio=e,this._pixelMargin=n,this._tileSize=s*e,this._dz=i,this._yPos=t,this._xPos=h}setPixelMargin(i){i!==this._pixelMargin&&(this._pixelMargin=i,this.setExtent(this._extent))}setExtent(i){this._extent=i,this._finalRatio=this._tileSize/i*(1<<this._dz);let t=this._pixelRatio*this._pixelMargin;t/=this._finalRatio;const s=i>>this._dz;t>s&&(t=s),this._margin=t,this._xmin=s*this._xPos-t,this._ymin=s*this._yPos-t,this._xmax=this._xmin+s+2*t,this._ymax=this._ymin+s+2*t}reset(i){this._type=i,this._lines=[],this._starts=[],this._line=null,this._start=0}moveTo(i,t){this._pushLine(),this._prevIsIn=this._isIn(i,t),this._moveTo(i,t,this._prevIsIn),this._prevPt=new h(i,t),this._firstPt=new h(i,t),this._dist=0}lineTo(i,t){const s=this._isIn(i,t),e=new h(i,t),n=h.distance(this._prevPt,e);let _,l,a,x,y,r,m,p;if(s)this._prevIsIn?this._lineTo(i,t,!0):(_=this._prevPt,l=e,a=this._intersect(l,_),this._start=this._dist+n*(1-this._r),this._lineTo(a.x,a.y,!0),this._lineTo(l.x,l.y,!0));else if(this._prevIsIn)l=this._prevPt,_=e,a=this._intersect(l,_),this._lineTo(a.x,a.y,!0),this._lineTo(_.x,_.y,!1);else{const i=this._prevPt,t=e;if(i.x<=this._xmin&&t.x<=this._xmin||i.x>=this._xmax&&t.x>=this._xmax||i.y<=this._ymin&&t.y<=this._ymin||i.y>=this._ymax&&t.y>=this._ymax)this._lineTo(t.x,t.y,!1);else{const s=[];if((i.x<this._xmin&&t.x>this._xmin||i.x>this._xmin&&t.x<this._xmin)&&(x=(this._xmin-i.x)/(t.x-i.x),p=i.y+x*(t.y-i.y),p<=this._ymin?r=!1:p>=this._ymax?r=!0:s.push(new o(x,this._xmin,p))),(i.x<this._xmax&&t.x>this._xmax||i.x>this._xmax&&t.x<this._xmax)&&(x=(this._xmax-i.x)/(t.x-i.x),p=i.y+x*(t.y-i.y),p<=this._ymin?r=!1:p>=this._ymax?r=!0:s.push(new o(x,this._xmax,p))),(i.y<this._ymin&&t.y>this._ymin||i.y>this._ymin&&t.y<this._ymin)&&(x=(this._ymin-i.y)/(t.y-i.y),m=i.x+x*(t.x-i.x),m<=this._xmin?y=!1:m>=this._xmax?y=!0:s.push(new o(x,m,this._ymin))),(i.y<this._ymax&&t.y>this._ymax||i.y>this._ymax&&t.y<this._ymax)&&(x=(this._ymax-i.y)/(t.y-i.y),m=i.x+x*(t.x-i.x),m<=this._xmin?y=!1:m>=this._xmax?y=!0:s.push(new o(x,m,this._ymax))),0===s.length)y?r?this._lineTo(this._xmax,this._ymax,!0):this._lineTo(this._xmax,this._ymin,!0):r?this._lineTo(this._xmin,this._ymax,!0):this._lineTo(this._xmin,this._ymin,!0);else if(s.length>1&&s[0].ratio>s[1].ratio)this._start=this._dist+n*s[1].ratio,this._lineTo(s[1].x,s[1].y,!0),this._lineTo(s[0].x,s[0].y,!0);else{this._start=this._dist+n*s[0].ratio;for(let i=0;i<s.length;i++)this._lineTo(s[i].x,s[i].y,!0)}this._lineTo(t.x,t.y,!1)}}this._dist+=n,this._prevIsIn=s,this._prevPt=e}close(){if(this._line.length>2){const i=this._firstPt,t=this._prevPt;i.x===t.x&&i.y===t.y||this.lineTo(i.x,i.y);const s=this._line;let h=s.length;for(;h>=4&&(s[0].x===s[1].x&&s[0].x===s[h-2].x||s[0].y===s[1].y&&s[0].y===s[h-2].y);)s.pop(),s[0].x=s[h-2].x,s[0].y=s[h-2].y,--h}}result(i=!0){return this._pushLine(),0===this._lines.length?null:(this._type===e.Polygon&&i&&p.simplify(this._tileSize,this._margin*this._finalRatio,this._lines),this._lines)}resultWithStarts(){if(this._type!==e.LineString)throw new Error("Only valid for lines");this._pushLine();const i=this._lines,t=i.length;if(0===t)return null;const s=[];for(let h=0;h<t;h++)s.push({line:i[h],start:this._starts[h]||0});return s}_isIn(i,t){return i>=this._xmin&&i<=this._xmax&&t>=this._ymin&&t<=this._ymax}_intersect(i,t){let s,e,n;if(t.x>=this._xmin&&t.x<=this._xmax)e=t.y<=this._ymin?this._ymin:this._ymax,n=(e-i.y)/(t.y-i.y),s=i.x+n*(t.x-i.x);else if(t.y>=this._ymin&&t.y<=this._ymax)s=t.x<=this._xmin?this._xmin:this._xmax,n=(s-i.x)/(t.x-i.x),e=i.y+n*(t.y-i.y);else{e=t.y<=this._ymin?this._ymin:this._ymax,s=t.x<=this._xmin?this._xmin:this._xmax;const h=(s-i.x)/(t.x-i.x),_=(e-i.y)/(t.y-i.y);h<_?(n=h,e=i.y+h*(t.y-i.y)):(n=_,s=i.x+_*(t.x-i.x))}return this._r=n,new h(s,e)}_pushLine(){this._line&&(this._type===e.Point?this._line.length>0&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===e.LineString?this._line.length>1&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===e.Polygon&&this._line.length>3&&(this._lines.push(this._line),this._starts.push(this._start))),this._line=[],this._start=0}_moveTo(i,t,s){this._type!==e.Polygon?s&&(i=Math.round((i-(this._xmin+this._margin))*this._finalRatio),t=Math.round((t-(this._ymin+this._margin))*this._finalRatio),this._line.push(new h(i,t))):(s||(i<this._xmin&&(i=this._xmin),i>this._xmax&&(i=this._xmax),t<this._ymin&&(t=this._ymin),t>this._ymax&&(t=this._ymax)),i=Math.round((i-(this._xmin+this._margin))*this._finalRatio),t=Math.round((t-(this._ymin+this._margin))*this._finalRatio),this._line.push(new h(i,t)),this._isH=!1,this._isV=!1)}_lineTo(i,t,s){let n,_;if(this._type!==e.Polygon)if(s){if(i=Math.round((i-(this._xmin+this._margin))*this._finalRatio),t=Math.round((t-(this._ymin+this._margin))*this._finalRatio),this._line.length>0&&(n=this._line[this._line.length-1],n.equals(i,t)))return;this._line.push(new h(i,t))}else this._line&&this._line.length>0&&this._pushLine();else if(s||(i<this._xmin&&(i=this._xmin),i>this._xmax&&(i=this._xmax),t<this._ymin&&(t=this._ymin),t>this._ymax&&(t=this._ymax)),i=Math.round((i-(this._xmin+this._margin))*this._finalRatio),t=Math.round((t-(this._ymin+this._margin))*this._finalRatio),this._line&&this._line.length>0){n=this._line[this._line.length-1];const s=n.x===i,e=n.y===t;if(s&&e)return;this._isH&&s||this._isV&&e?(n.x=i,n.y=t,_=this._line[this._line.length-2],_.x===i&&_.y===t?(this._line.pop(),this._line.length<=1?(this._isH=!1,this._isV=!1):(_=this._line[this._line.length-2],this._isH=_.x===i,this._isV=_.y===t)):(this._isH=_.x===i,this._isV=_.y===t)):(this._line.push(new h(i,t)),this._isH=s,this._isV=e)}else this._line.push(new h(i,t))}}class r{setExtent(i){this._ratio=4096===i?1:4096/i}get validateTessellation(){return this._ratio<1}reset(i){this._lines=[],this._line=null}moveTo(i,t){this._line&&this._lines.push(this._line),this._line=[];const s=this._ratio;this._line.push(new h(i*s,t*s))}lineTo(i,t){const s=this._ratio;this._line.push(new h(i*s,t*s))}close(){const i=this._line;i&&!i[0].isEqual(i[i.length-1])&&i.push(i[0])}result(){return this._line&&this._lines.push(this._line),0===this._lines.length?null:this._lines}}var m;!function(i){i[i.sideLeft=0]="sideLeft",i[i.sideRight=1]="sideRight",i[i.sideTop=2]="sideTop",i[i.sideBottom=3]="sideBottom"}(m||(m={}));class p{static simplify(i,t,s){if(!s)return;const h=-t,e=i+t,n=-t,_=i+t,l=[],a=[],x=s.length;for(let i=0;i<x;++i){const t=s[i];if(!t||t.length<2)continue;let x,o=t[0];const y=t.length;for(let s=1;s<y;++s)x=t[s],o.x===x.x&&(o.x<=h&&(o.y>x.y?(l.push(i),l.push(s),l.push(m.sideLeft),l.push(-1)):(a.push(i),a.push(s),a.push(m.sideLeft),a.push(-1))),o.x>=e&&(o.y<x.y?(l.push(i),l.push(s),l.push(m.sideRight),l.push(-1)):(a.push(i),a.push(s),a.push(m.sideRight),a.push(-1)))),o.y===x.y&&(o.y<=n&&(o.x<x.x?(l.push(i),l.push(s),l.push(m.sideTop),l.push(-1)):(a.push(i),a.push(s),a.push(m.sideTop),a.push(-1))),o.y>=_&&(o.x>x.x?(l.push(i),l.push(s),l.push(m.sideBottom),l.push(-1)):(a.push(i),a.push(s),a.push(m.sideBottom),a.push(-1)))),o=x}if(0===l.length||0===a.length)return;p.fillParent(s,a,l),p.fillParent(s,l,a);const o=[];p.calcDeltas(o,a,l),p.calcDeltas(o,l,a),p.addDeltas(o,s)}static fillParent(i,t,s){const h=s.length,e=t.length;for(let _=0;_<e;_+=4){const e=t[_],l=t[_+1],a=t[_+2],x=i[e][l-1],o=i[e][l];let y=8092,r=-1;for(let t=0;t<h;t+=4){if(s[t+2]!==a)continue;const h=s[t],e=s[t+1],_=i[h][e-1],l=i[h][e];switch(a){case m.sideLeft:case m.sideRight:if(n(x.y,_.y,l.y)&&n(o.y,_.y,l.y)){const i=Math.abs(l.y-_.y);i<y&&(y=i,r=t)}break;case m.sideTop:case m.sideBottom:if(n(x.x,_.x,l.x)&&n(o.x,_.x,l.x)){const i=Math.abs(l.x-_.x);i<y&&(y=i,r=t)}}}t[_+3]=r}}static calcDeltas(i,t,s){const h=t.length;for(let e=0;e<h;e+=4){const h=[],n=p.calcDelta(e,t,s,h);i.push(t[e]),i.push(t[e+1]),i.push(t[e+2]),i.push(n)}}static calcDelta(i,t,s,h){const e=t[i+3];if(-1===e)return 0;const n=h.length;return n>1&&h[n-2]===e?0:(h.push(e),p.calcDelta(e,s,t,h)+1)}static addDeltas(i,t){const s=i.length;let h=0;for(let t=0;t<s;t+=4){const s=i[t+3];s>h&&(h=s)}for(let e=0;e<s;e+=4){const s=t[i[e]],n=i[e+1],_=h-i[e+3];switch(i[e+2]){case m.sideLeft:s[n-1].x-=_,s[n].x-=_,1===n&&(s[s.length-1].x-=_),n===s.length-1&&(s[0].x-=_);break;case m.sideRight:s[n-1].x+=_,s[n].x+=_,1===n&&(s[s.length-1].x+=_),n===s.length-1&&(s[0].x+=_);break;case m.sideTop:s[n-1].y-=_,s[n].y-=_,1===n&&(s[s.length-1].y-=_),n===s.length-1&&(s[0].y-=_);break;case m.sideBottom:s[n-1].y+=_,s[n].y+=_,1===n&&(s[s.length-1].y+=_),n===s.length-1&&(s[0].y+=_)}}}}export{r as S,y as T,a as l,x as t};
