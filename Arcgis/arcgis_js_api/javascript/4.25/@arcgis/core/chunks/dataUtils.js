/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../geometry.js";import{h as t}from"./object.js";import{L as e}from"./Logger.js";import{d as n}from"./mathUtils.js";import{a as r,i as o}from"./maybe.js";import{throwIfAborted as a}from"../core/promiseUtils.js";import{R as l}from"../core/lang.js";import{g as i}from"../geometry/SpatialReference.js";import s from"../geometry/Extent.js";const c=e.getLogger("esri.views.2d.engine.flow.dataUtils");async function f(e,n,r,o){const i=performance.now(),s=function(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),a=new Array(2*o+1);let l=0;for(let t=-o;t<=o;t++){const e=Math.exp(-t*t/(r*r));a[t+o]=e,l+=e}for(let t=-o;t<=o;t++)a[t+o]/=l;const i=new Float32Array(t.length);for(let r=0;r<n;r++)for(let n=0;n<e;n++){let l=0,s=0;for(let i=-o;i<=o;i++){if(n+i<0||n+i>=e)continue;const c=a[i+o];l+=c*t[2*(r*e+(n+i))+0],s+=c*t[2*(r*e+(n+i))+1]}i[2*(r*e+n)+0]=l,i[2*(r*e+n)+1]=s}const s=new Float32Array(t.length);for(let t=0;t<e;t++)for(let r=0;r<n;r++){let l=0,c=0;for(let s=-o;s<=o;s++){if(r+s<0||r+s>=n)continue;const f=a[s+o];l+=f*i[2*((r+s)*e+t)+0],c+=f*i[2*((r+s)*e+t)+1]}s[2*(r*e+t)+0]=l,s[2*(r*e+t)+1]=c}return s}(e.data,e.width,e.height,t.smoothing);return t.interpolate?(t,r)=>{const o=Math.floor(t),a=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(a<0||a>=e.height)return[0,0];const l=t-o,i=r-a,s=o,c=a,f=o<e.width-1?o+1:o,h=a<e.height-1?a+1:a,u=n[2*(c*e.width+s)],m=n[2*(c*e.width+f)],d=n[2*(h*e.width+s)],w=n[2*(h*e.width+f)],p=n[2*(c*e.width+s)+1],g=n[2*(c*e.width+f)+1];return[(u*(1-i)+d*i)*(1-l)+(m*(1-i)+w*i)*l,(p*(1-i)+n[2*(h*e.width+s)+1]*i)*(1-l)+(g*(1-i)+n[2*(h*e.width+f)+1]*i)*l]}:(t,r)=>{const o=Math.round(t),a=Math.round(r);return o<0||o>=e.width||a<0||a>=e.height?[0,0]:[n[2*(a*e.width+o)+0],n[2*(a*e.width+o)+1]]}}(n,r),f=performance.now(),u=function(t,e,n,r){const o=[],a=new l,i=1/Math.max(t.lineCollisionWidth,1),s=Math.round(n*i),c=Math.round(r*i),f=new Int32Array(s*c);for(let t=0;t<f.length;t++)f[t]=-1;const u=[];for(let e=0;e<r;e+=t.lineSpacing)for(let r=0;r<n;r+=t.lineSpacing)u.push({x:r,y:e,sort:a.getFloat()});u.sort(((t,e)=>t.sort-e.sort));for(const{x:n,y:r}of u)if(a.getFloat()<t.density){const a=h(t,e,n,r,o.length,f,s,c,i);if(a.length<2)continue;o.push(a)}return o}(n,s,r.width,r.height),m=performance.now(),d=function(t,e){const n=new l,r=t.reduce(((t,e)=>t+e.length),0),o=new Float32Array(4*r),a=new Array(t.length);let i=0,s=0;for(const e of t){const t=i;for(const t of e)o[4*i+0]=t.x,o[4*i+1]=t.y,o[4*i+2]=t.t,o[4*i+3]=t.speed,i++;a[s++]={startVertex:t,numberOfVertices:e.length,totalTime:e[e.length-1].t,timeSeed:n.getFloat()}}return{lineVertices:o,lineDescriptors:a}}(u),w=performance.now(),p="Streamlines"===e?function(t,e){const{lineVertices:n,lineDescriptors:r}=t;let o=0,a=0;for(const t of r)o+=2*t.numberOfVertices,a+=6*(t.numberOfVertices-1);const l=new Float32Array(9*o),i=new Uint32Array(a);let s=0,c=0;function f(t,e,n,r,o,a,i,c){const f=9*s;let h=0;l[f+h++]=t,l[f+h++]=e,l[f+h++]=1,l[f+h++]=n,l[f+h++]=a,l[f+h++]=i,l[f+h++]=r/2,l[f+h++]=o/2,l[f+h++]=c,s++,l[f+h++]=t,l[f+h++]=e,l[f+h++]=-1,l[f+h++]=n,l[f+h++]=a,l[f+h++]=i,l[f+h++]=-r/2,l[f+h++]=-o/2,l[f+h++]=c,s++}for(const t of r){const{totalTime:e,timeSeed:r}=t;let o=null,a=null,l=null,h=null,u=null,m=null;for(let d=0;d<t.numberOfVertices;d++){const w=n[4*(t.startVertex+d)+0],p=n[4*(t.startVertex+d)+1],g=n[4*(t.startVertex+d)+2],y=n[4*(t.startVertex+d)+3];let x=null,M=null,A=null,I=null;if(d>0){x=w-o,M=p-a;const t=Math.sqrt(x*x+M*M);if(x/=t,M/=t,d>1){let t=x+u,e=M+m;const n=Math.sqrt(t*t+e*e);t/=n,e/=n;const r=Math.min(1/(t*x+e*M),10);t*=r,e*=r,A=-e,I=t}else A=-M,I=x;null!==A&&null!==I&&(f(o,a,l,A,I,e,r,y),i[c++]=s-2,i[c++]=s,i[c++]=s-1,i[c++]=s,i[c++]=s+1,i[c++]=s-1)}o=w,a=p,l=g,u=x,m=M,h=y}f(o,a,l,-m,u,e,r,h)}return{vertexData:l,indexData:i}}(d):function(t){const{lineVertices:e,lineDescriptors:n}=t;let r=0,o=0;for(const t of n){const e=t.numberOfVertices-1;r+=4*e*2,o+=6*e*2}const a=new Float32Array(16*r),l=new Uint32Array(o);let i,s,c,f,h,u,m,d,w,p,g,y,x,M,A=0,I=0;function V(t,e){let n=w+g,r=p+y;const o=Math.sqrt(n*n+r*r);n/=o,r/=o;const V=w*n+p*r;n/=V,r/=V;let F=g+x,b=y+M;const D=Math.sqrt(F*F+b*b);F/=D,b/=D;const v=g*F+y*b;F/=v,b/=v,function(t,e,n,r,o,l,i,s,c,f,h,u,m,d){const w=16*A;let p=0;for(const g of[1,2])for(const y of[1,2,3,4])a[w+p++]=t,a[w+p++]=e,a[w+p++]=n,a[w+p++]=r,a[w+p++]=i,a[w+p++]=s,a[w+p++]=c,a[w+p++]=f,a[w+p++]=g,a[w+p++]=y,a[w+p++]=m,a[w+p++]=d,a[w+p++]=o/2,a[w+p++]=l/2,a[w+p++]=h/2,a[w+p++]=u/2,A++}(i,s,c,f,-r,n,h,u,m,d,-b,F,t,e),l[I++]=A-8,l[I++]=A-7,l[I++]=A-6,l[I++]=A-7,l[I++]=A-5,l[I++]=A-6,l[I++]=A-4,l[I++]=A-3,l[I++]=A-2,l[I++]=A-3,l[I++]=A-1,l[I++]=A-2}function F(t,e,n,r,o,a){if(w=g,p=y,g=x,y=M,null==w&&null==p&&(w=g,p=y),null!=h&&null!=u){x=t-h,M=e-u;const n=Math.sqrt(x*x+M*M);x/=n,M/=n}null!=w&&null!=p&&V(o,a),i=h,s=u,c=m,f=d,h=t,u=e,m=n,d=r}function b(t,e){w=g,p=y,g=x,y=M,null==w&&null==p&&(w=g,p=y),null!=w&&null!=p&&V(t,e)}for(const t of n){i=null,s=null,c=null,f=null,h=null,u=null,m=null,d=null,w=null,p=null,g=null,y=null,x=null,M=null;const{totalTime:n,timeSeed:r}=t;for(let o=0;o<t.numberOfVertices;o++)F(e[4*(t.startVertex+o)+0],e[4*(t.startVertex+o)+1],e[4*(t.startVertex+o)+2],e[4*(t.startVertex+o)+3],n,r);b(n,r)}return{vertexData:a,indexData:l}}(d),g=performance.now();return t("esri-2d-profiler")&&(c.info("I.1","_createFlowFieldFromData (ms)",Math.round(f-i)),c.info("I.2","_getStreamlines (ms)",Math.round(m-f)),c.info("I.3","createAnimatedLinesData (ms)",Math.round(w-m)),c.info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(g-w)),c.info("I.5","createFlowMesh (ms)",Math.round(g-i)),c.info("I.6","Mesh size (bytes)",p.vertexData.buffer.byteLength+p.indexData.buffer.byteLength)),await Promise.resolve(),a(o),p}function h(t,e,n,r,o,a,l,i,s){const c=[];let f=n,h=r,u=0,[m,d]=e(f,h);m*=t.velocityScale,d*=t.velocityScale;const w=Math.sqrt(m*m+d*d);let p,g;c.push({x:f,y:h,t:u,speed:w});for(let n=0;n<t.verticesPerLine;n++){let[n,r]=e(f,h);n*=t.velocityScale,r*=t.velocityScale;const m=Math.sqrt(n*n+r*r);if(m<t.minSpeedThreshold)return c;const d=n/m,w=r/m;if(f+=d*t.segmentLength,h+=w*t.segmentLength,u+=t.segmentLength/m,Math.acos(d*p+w*g)>t.maxTurnAngle)return c;if(t.collisions){const t=Math.round(f*s),e=Math.round(h*s);if(t<0||t>l-1||e<0||e>i-1)return c;const n=a[e*l+t];if(-1!==n&&n!==o)return c;a[e*l+t]=o}c.push({x:f,y:h,t:u,speed:m}),p=d,g=w}return c}function u(t,e){const r=e.pixels,{width:o,height:a}=e,l=new Float32Array(o*a*2),i=e.mask||new Uint8Array(o*a*2);if(e.mask||i.fill(255),"vector-uv"===t)for(let t=0;t<o*a;t++)l[2*t+0]=r[0][t],l[2*t+1]=-r[1][t];else if("vector-magdir"===t)for(let t=0;t<o*a;t++){const e=r[0][t],o=n(r[1][t]),a=Math.cos(o-Math.PI/2),i=Math.sin(o-Math.PI/2);l[2*t+0]=a*e,l[2*t+1]=i*e}return{data:l,mask:i,width:o,height:a}}async function m(e,n,r,o,a,l){const f=performance.now(),h=i(n.spatialReference);if(!h){const i=await d(e,n,r,o,a,l);return t("esri-2d-profiler")&&c.info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-f)),t("esri-2d-profiler")&&c.info("I.9","Number of parts",1),i}const[u,m]=h.valid,w=m-u,p=Math.ceil(n.width/w),g=n.width/p,y=Math.round(r/p);let x=n.xmin;const M=[],A=performance.now();for(let t=0;t<p;t++){const t=new s({xmin:x,xmax:x+g,ymin:n.ymin,ymax:n.ymax,spatialReference:n.spatialReference});M.push(d(e,t,y,o,a,l)),x+=g}const I=await Promise.all(M);t("esri-2d-profiler")&&c.info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-A)),t("esri-2d-profiler")&&c.info("I.9","Number of parts",I.length);const V={data:new Float32Array(r*o*2),mask:new Uint8Array(r*o),width:r,height:o};let F=0;for(const t of I){for(let e=0;e<t.height;e++)for(let n=0;n<t.width;n++)F+n>=r||(V.data[2*(e*r+F+n)+0]=t.data[2*(e*t.width+n)+0],V.data[2*(e*r+F+n)+1]=t.data[2*(e*t.width+n)+1],V.mask[e*r+F+n]=t.mask[e*t.width+n]);F+=t.width}return t("esri-2d-profiler")&&c.info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-f)),V}async function d(t,e,n,a,l,i){const s={requestProjectedLocalDirections:!0,signal:i};if(o(l)&&(s.timeExtent=l),"imagery"===t.type){await t.load({signal:i});const o=t.rasterInfo.dataType,l=await t.fetchImage(e,n,a,s);return!l||r(l.pixelData)||r(l.pixelData.pixelBlock)?{data:new Float32Array(n*a*2),mask:new Uint8Array(n*a),width:n,height:a}:u(o,l.pixelData.pixelBlock)}await t.load({signal:i});const c=t.rasterInfo.dataType,f=await t.fetchPixels(e,n,a,s);return!f||r(f.pixelBlock)?{data:new Float32Array(n*a*2),mask:new Uint8Array(n*a),width:n,height:a}:u(c,f.pixelBlock)}export{f as c,m as l};
