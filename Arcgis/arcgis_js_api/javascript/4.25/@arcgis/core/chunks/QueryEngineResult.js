/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{a as e,i as t}from"./maybe.js";import{e as i,f as s}from"../geometry/Polygon.js";import{g as a,e as r}from"./extentUtils.js";import{t as n}from"./quantizationUtils.js";import{j as o,e as l}from"../geometry/SpatialReference.js";import u from"../core/Error.js";import{I as c}from"./ItemCache.js";import{WhereClause as d}from"../core/sql/WhereClause.js";import{b as h,d as f,i as m,e as g,f as p,p as y,h as x,c as F,j as I,r as V,k as _,l as T,m as D}from"./utils13.js";import{p as v}from"./projectionSupport.js";import{a as S,m as b}from"./SnappingCandidate.js";import{c as z,g as A,t as w}from"./utils21.js";import{isStringField as E}from"../layers/support/fieldUtils.js";import{l as C}from"./arcadeOnDemand.js";const R=new class{constructor(e,t){this._cache=new c(e),this._invalidCache=new c(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(void 0!==this._invalidCache.get(i))return null;try{const s=d.create(e,t);return this._cache.put(i,s),s}catch{return this._invalidCache.put(i,null),null}}}(50,500),N="feature-store:unsupported-query",q=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function M(e,t){if(!t)return!0;const i=R.get(t,e);if(!i)throw new u(N,"invalid SQL expression",{where:t});if(!i.isStandardized)throw new u(N,"where clause is not standard",{where:t});return P(e,i.fieldNames,"where clause contains missing fields"),!0}function j(e,t,i){if(!t)return!0;const s=R.get(t,e);if(!s)throw new u(N,"invalid SQL expression",{having:t});if(!s.isAggregate)throw new u(N,"having does not contain a valid aggregate function",{having:t});const a=s.fieldNames;if(P(e,a,"having contains missing fields"),!s.getExpressions().every((t=>{const{aggregateType:s,field:a}=t,r=e.has(a)&&e.get(a).name;return i.some((t=>{const{onStatisticField:i,statisticType:a}=t;return(e.has(i)&&e.get(i).name)===r&&a.toLowerCase().trim()===s}))})))throw new u(N,"expressions in having should also exist in outStatistics",{having:t});return!0}function G(e,t){return e?R.get(e,t):null}function P(e,t,i,s=!0){const a=[];for(const i of t)if("*"!==i&&!e.has(i))if(s){const t=O(i);try{const i=G(t,e);if(!i)throw new u(N,"invalid SQL expression",{where:t});if(!i.isStandardized)throw new u(N,"expression is not standard",{clause:i});P(e,i.fieldNames,"expression contains missing fields")}catch(e){const t=e&&e.details;if(t&&(t.clause||t.where))throw e;t&&t.missingFields?a.push(...t.missingFields):a.push(i)}}else a.push(i);if(a.length)throw new u(N,i,{missingFields:a})}function O(e){return e.split(" as ")[0]}function Q(e,t){const i=t.get(e);return!!i&&!q.has(i.type)}class Z{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let e=0;for(const t of s){const s=O(t),a=this.fieldsIndex.get(s),r=a?null:G(s,i),n=a?a.name:t.split(" as ")[1]||"FIELD_EXP_"+e++;this._fieldDataCache.set(t,{alias:n,clause:r})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach((e=>this.getAttributes(e))),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let a=null;return this._fieldDataCache.has(s)?a=this._fieldDataCache.get(s).clause:i||(a=G(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:a})),i?this.featureAdapter.getAttribute(e,s):a.calculateValue(e,this.featureAdapter)}getDataValue(e,t){const i=t.normalizationType,s=t.normalizationTotal;let a=this.getFieldValue(e,t.field,this.fieldsIndex.get(t.field));if(t.field2&&(a=`${h(a)}${t.fieldDelimiter}${h(this.getFieldValue(e,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(a=`${a}${t.fieldDelimiter}${h(this.getFieldValue(e,t.field3,this.fieldsIndex.get(t.field3)))}`)),i&&Number.isFinite(a)){const r="field"===i&&t.normalizationField?this.getFieldValue(e,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;a=f(a,i,r,s)}return a}getExpressionValue(e,t,i,s){const a={attributes:this.featureAdapter.getAttributes(e),layer:{fields:this.fieldsIndex.fields}},r=s.createExecContext(a,i);return s.executeFunction(t,r)}getExpressionValues(e,t,i,s){const a={fields:this.fieldsIndex.fields};return e.map((e=>{const r={attributes:this.featureAdapter.getAttributes(e),layer:a},n=s.createExecContext(r,i);return s.executeFunction(t,n)}))}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:G(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:G(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:t,clause:a}=this._fieldDataCache.get(s);i[t]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,t)}return i}_processAttributesForDistinctValues(t){if(e(t)||!this.returnDistinctValues)return t;const i=this.outFields,s=[];if(i)for(const e of i){const{alias:i}=this._fieldDataCache.get(e);s.push(t[i])}else for(const e in t)s.push(t[e]);const a=`${(i||["*"]).join(",")}=${s.join(",")}`;let r=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++r),r>1?null:t}}class L{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new Z(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!a)return 1;const r=new Map,n=new Map,o=new Set;for(const a of s){const{statisticType:s}=a,l="exceedslimit"!==s?a.onStatisticField:void 0;if(!n.has(l)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,r);i.push(t)}n.set(l,this._calculateUniqueValues(i,e.returnDistinctValues))}const u=n.get(l);for(const t in u){const{data:s,items:a}=u[t],r=s.join(",");i&&!e.validateItems(a,i)||o.add(r)}}return o.size}async createQueryResponse(){let e;return e=this.query.outStatistics?this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&(o(this.query.outSR)&&!l(this.query.geometry.spatialReference,this.query.outSR)?e.queryGeometry=z({spatialReference:this.query.outSR,...v(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR)}):e.queryGeometry=z({spatialReference:this.query.outSR,...this.query.geometry})),e}createSnappingResponse(t,i){const s=this.featureAdapter,a=B(this.hasZ,this.hasM),{point:r}=t,n="number"==typeof t.distance?t.distance:t.distance.x,o="number"==typeof t.distance?t.distance:t.distance.y,l={candidates:[]},u="esriGeometryPolygon"===this.geometryType,c=null!=r.z,d=null!=r.m,h=this._getPointCreator(r,c,d,this.spatialReference,i),f=new Y(null,0),m=new Y(null,0),g={x:0,y:0,z:0};for(const i of this.items){const c=s.getGeometry(i);if(e(c))continue;const{coords:d,lengths:p}=c;if(f.coords=d,m.coords=d,t.types&U.EDGE){let e=0;for(let t=0;t<p.length;t++){const u=p[t];for(let t=0;t<u;t++,e+=a){const c=f;if(c.coordsIndex=e,t!==u-1){const t=m;t.coordsIndex=e+a;const u=g;$(g,r,c,t);const d=(r.x-u.x)/n,f=(r.y-u.y)/o,p=d*d+f*f;p<=1&&l.candidates.push(S(s.getObjectId(i),h(u),Math.sqrt(p),h(c),h(t)))}}}}if(t.types&U.VERTEX){const e=u?d.length-a:d.length;for(let t=0;t<e;t+=a){const e=f;e.coordsIndex=t;const a=(r.x-e.x)/n,u=(r.y-e.y)/o,c=a*a+u*u;c<=1&&l.candidates.push(b(s.getObjectId(i),h(e),Math.sqrt(c)))}}}return l.candidates.sort(((e,t)=>e.distance-t.distance)),l}_getPointCreator(e,i,s,a,r){const n=t(r)&&!l(a,r)?e=>v(e,a,r):e=>e,{hasZ:o}=this,u=e.m;return i&&s?o?({x:e,y:t,z:i})=>n({x:e,y:t,z:i,m:u}):({x:e,y:t})=>n({x:e,y:t,z:0,m:u}):i?o?({x:e,y:t,z:i})=>n({x:e,y:t,z:i}):({x:e,y:t})=>n({x:e,y:t,z:0}):s?({x:e,y:t})=>n({x:e,y:t,m:u}):({x:e,y:t})=>n({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l}=e,u=this.fieldsIndex.isDateField(t),c=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:l}),d=m({normalizationType:a,normalizationField:s,minValue:n,maxValue:o}),h=this.fieldsIndex.get(t),f={value:.5,fieldType:h?.type},x=E(h)?g({values:c,supportsNullCount:d,percentileParams:f}):p({values:c,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:d,percentileParams:f});return y(x,u)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r}=e,n=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r}),o=x(n);return F(o,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:d}),f=I(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return V(f,n)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:d});return _(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=t[1]&&"desc"===t[1].toLowerCase(),o=T(r?.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:h,returnZ:f,returnM:m}=e,g=null!=d&&t.length>(h||0)+d,p=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:g,features:this._createFeatures(e,t),fields:p,geometryType:i,hasM:s&&m,hasZ:a&&f,objectIdFieldName:r,spatialReference:z(u||o),transform:c&&n(c)||null}}_createFeatures(e,t){const i=new Z(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:d,resultRecordCount:h,returnZ:f=!1,returnM:m=!1}=e,g=a&&f,p=s&&m;let y=[],x=0;const F=[...t];if(this._sortFeatures(F,r,((e,t,s)=>i.getFieldValue(e,t,s))),l||u){const e=n(o);if(l&&!u)for(const t of F)y[x++]={attributes:i.getAttributes(t),geometry:A(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),c,e,g,p)};else if(!l&&u)for(const t of F)y[x++]={attributes:i.getAttributes(t),centroid:w(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)y[x++]={attributes:i.getAttributes(t),centroid:w(this,this.featureAdapter.getCentroid(t,this),e),geometry:A(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),c,e,g,p)}}else for(const e of F){const t=i.getAttributes(e);t&&(y[x++]={attributes:t})}const I=d||0;if(null!=h){const e=I+h;y=y.slice(I,Math.min(y.length,e))}return y}_createExceedsLimitQueryResponse(e){let i=!1,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const t of e.outStatistics)if("exceedslimit"===t.statisticType){s=null!=t.maxPointCount?t.maxPointCount:Number.POSITIVE_INFINITY,a=null!=t.maxRecordCount?t.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=t.maxVertexCount?t.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>s;else if(this.items.length>a)i=!0;else{const e=B(this.hasZ,this.hasM),s=this.featureAdapter;i=this.items.reduce(((e,i)=>{const a=s.getGeometry(i);return e+(t(a)&&a.coords.length||0)}),0)/e>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,r=new Map,n=new Map,o=new Z(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:u,having:c,orderByFields:d}=e,h=u&&u.length,f=!!h,m=f&&u[0],g=f&&!this.fieldsIndex.get(m);for(const e of l){const{outStatisticFieldName:l,statisticType:d}=e,p=e,y="exceedslimit"!==d?e.onStatisticField:void 0,x="percentile_disc"===d||"percentile_cont"===d,F="EnvelopeAggregate"===d||"CentroidAggregate"===d||"ConvexHullAggregate"===d,I=f&&1===h&&(y===m||g)&&"count"===d;if(f){if(!r.has(y)){const e=[];for(const t of u){const i=this._getAttributeValues(o,t,s);e.push(i)}r.set(y,this._calculateUniqueValues(e,!F&&o.returnDistinctValues))}const e=r.get(y);for(const t in e){const{count:i,data:a,items:r,itemPositions:d}=e[t],h=a.join(",");if(!c||o.validateItems(r,c)){const e=n.get(h)||{attributes:{}};if(F){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:t,outStatisticFieldName:i}=await this._getAggregateGeometry(p,r);e.aggregateGeometries[i]=t}else{let t=null;if(I)t=i;else{const e=this._getAttributeValues(o,y,s),i=d.map((t=>e[t]));t=x&&"statisticParameters"in p?this._getPercentileValue(p,i):this._getStatisticValue(p,i,null,o.returnDistinctValues)}e.attributes[l]=t}let t=0;u.forEach(((i,s)=>e.attributes[this.fieldsIndex.get(i)?i:"EXPR_"+ ++t]=a[s])),n.set(h,e)}}}else if(F){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(p,this.items);t.aggregateGeometries[i]=e}else{const e=this._getAttributeValues(o,y,s);t.attributes[l]=x&&"statisticParameters"in p?this._getPercentileValue(p,e):this._getStatisticValue(p,e,a,o.returnDistinctValues)}i.push({name:l,alias:l,type:"esriFieldTypeDouble"})}const p=f?Array.from(n.values()):[t];return this._sortFeatures(p,d,((e,t)=>e.attributes[t])),{fields:i,features:p}}async _getAggregateGeometry(e,t){const n=await import("./geometryEngineJSON.js").then((e=>e.g)),{statisticType:o,outStatisticFieldName:l}=e,{featureAdapter:u,spatialReference:c,geometryType:d,hasZ:h,hasM:f}=this,m=t.map((e=>A(d,h,f,u.getGeometry(e)))),g=n.convexHull(c,m,!0)[0],p={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=g?a(g):r(n.union(c,m));p.aggregateGeometries={...e,spatialReference:c},p.outStatisticFieldName=l||"extent"}else if("CentroidAggregate"===o){const e=g?i(g):s(r(n.union(c,m)));p.aggregateGeometries={x:e[0],y:e[1],spatialReference:c},p.outStatisticFieldName=l||"centroid"}else"ConvexHullAggregate"===o&&(p.aggregateGeometries=g,p.outStatisticFieldName=l||"convexHull");return p}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;return n=i?.has(a)?i.get(a):E(this.fieldsIndex.get(a))?g({values:t,returnDistinct:s}):p({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n),n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i);return D(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:"percentile_disc"===a})}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a}_getAttributeDataValues(e,t){return this.items.map((i=>e.getDataValue(i,{field:t.field,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:t.normalizationField,normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await C(),a=s.createFunction(t),r=i&&s.getViewInfo(i);return e.getExpressionValues(this.items,a,r,s)}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let r=0;r<a;r++){const a=s[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");t?null==i[o]&&(i[o]={count:1,data:n,items:[a],itemPositions:[r]}):null==i[o]?i[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i[o].count++,i[o].items.push(a),i[o].itemPositions.push(r))}return i}async _getDataValues(e){const t=new Z(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:o}=e,l=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(t,i,l):this._getAttributeDataValues(t,{field:s,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:a,normalizationType:r,normalizationTotal:n})}}function $(e,t,i,s){const a=s.x-i.x,r=s.y-i.y,n=a*a+r*r,o=(t.x-i.x)*a+(t.y-i.y)*r,l=Math.min(1,Math.max(0,o/n));e.x=i.x+a*l,e.y=i.y+r*l}function B(e,t){return e?t?4:3:t?3:2}var U;!function(e){e[e.NONE=0]="NONE",e[e.EDGE=1]="EDGE",e[e.VERTEX=2]="VERTEX"}(U||(U={}));class Y{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{L as Q,U as S,M as a,j as b,G as g,Q as h,P as v};
