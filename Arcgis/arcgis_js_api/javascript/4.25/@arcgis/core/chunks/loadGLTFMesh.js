/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import t from"../Color.js";import r from"../request.js";import{o as e}from"./ensureType.js";import{D as o}from"./mathUtils.js";import{i as s,u as i,g as n,a}from"./maybe.js";import{n as m}from"./mat3.js";import{c as p}from"./mat3f64.js";import{f as c}from"./vec3.js";import{f as l}from"./vec4f64.js";import u,{M as f}from"../geometry/support/MeshComponent.js";import j from"../geometry/support/MeshMaterialMetallicRoughness.js";import g from"../geometry/support/MeshTexture.js";import{b as d,c as x,s as y,u as T,a as h,v as b,B as v,d as w}from"./BufferView.js";import{t as M,a as A,n as C,f as E,s as R,c as S,b as U}from"./vec32.js";import{D as B,l as I,c as O,t as P,g as $,f as G,n as L,h as N,s as D,a as _,i as F,b as q,d as k,e as z,C as V}from"./DefaultMaterial_COLOR_GAMMA.js";import{a as H}from"./georeference.js";import{a as J}from"./Indices.js";import{e as K,b as Q}from"./enums3.js";import"./colorUtils.js";import"./common.js";import"./object.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"./string.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/Error.js";import"../core/promiseUtils.js";import"./tslib.es6.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"./ArrayPool.js";import"../core/accessorSupport/decorators/subclass.js";import"./tracking.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/MeshMaterial.js";import"./imageUtils.js";import"./reader.js";import"./writer.js";import"./persistableUrlUtils.js";import"./vec2.js";import"./types.js";import"./asyncUtils.js";import"./mat4f64.js";import"./Version.js";import"./mat4.js";import"./quat.js";import"./quatf64.js";import"./compilerUtils.js";import"./unitUtils.js";import"./jsonMap.js";import"./projectionEllipsoid.js";import"../geometry/SpatialReference.js";import"./Ellipsoid.js";import"../geometry/projection.js";import"./SimpleObservable.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"../geometry/Point.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"./pe.js";import"./assets.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./aaBoundingRect.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./axisAngleDegrees.js";import"./projection.js";async function W(o,a,m){const p=new B(function(t){const e=t?.resolveFile;return e?{busy:!1,request:async(t,o,i)=>{const n=e(t),a="image"===o?"image":"binary"===o?"array-buffer":"json";return(await r(n,{responseType:a,signal:s(i)?i.signal:null})).data}}:null}(m)),u=(await I(p,a,m,!0)).model,y=u.lods.shift(),T=new Map,b=new Map;u.textures.forEach(((t,r)=>{return T.set(r,new g({data:(o=t).data,wrap:(e=o.parameters.wrap,{horizontal:tt(e.s),vertical:tt(e.t)})}));var e,o})),u.materials.forEach(((r,e)=>b.set(e,function(r,e){const o=new t((a=r.color,m=r.opacity,l(rt(a[0]),rt(a[1]),rt(a[2]),m))),s=r.emissiveFactor?new t(function(t){return c(rt(t[0]),rt(t[1]),rt(t[2]))}(r.emissiveFactor)):null;var a,m;return new j({color:o,colorTexture:i(n(r.textureColor,(t=>e.get(t)))),normalTexture:i(n(r.textureNormal,(t=>e.get(t)))),emissiveColor:s,emissiveTexture:i(n(r.textureEmissive,(t=>e.get(t)))),occlusionTexture:i(n(r.textureOcclusion,(t=>e.get(t)))),alphaMode:Z(r.alphaMode),alphaCutoff:r.alphaCutoff,doubleSided:r.doubleSided,metallic:r.metallicFactor,roughness:r.roughnessFactor,metallicRoughnessTexture:i(n(r.textureMetallicRoughness,(t=>e.get(t)))),colorTextureTransform:r.colorTextureTransform,normalTextureTransform:r.normalTextureTransform,occlusionTextureTransform:r.occlusionTextureTransform,emissiveTextureTransform:r.emissiveTextureTransform,metallicRoughnessTextureTransform:r.metallicRoughnessTextureTransform})}(r,T))));const M=function(t){let r=0;const o={color:!1,tangent:!1,normal:!1,texCoord0:!1},i=new Map,n=new Map,a=[];for(const p of t.parts){const{attributes:{position:t,normal:c,color:l,tangent:u,texCoord0:f}}=p,j=`\n      ${X(t,i)}/\n      ${X(c,i)}/\n      ${X(l,i)}/\n      ${X(u,i)}/\n      ${X(f,i)}/\n      ${m=p.transform,s(m)?m.toString():"-"}\n    `;let g=!1;const d=e(n,j,(()=>(g=!0,{start:r,length:t.count})));g&&(r+=t.count),c&&(o.normal=!0),l&&(o.color=!0),u&&(o.tangent=!0),f&&(o.texCoord0=!0),a.push({gltf:p,writeVertices:g,region:d})}var m;return{vertexAttributes:{position:O(v,r),normal:o.normal?O(h,r):null,tangent:o.tangent?O(d,r):null,color:o.color?O(x,r):null,texCoord0:o.texCoord0?O(w,r):null},parts:a,components:[]}}(y);for(const t of M.parts)Y(M,t,b);const{position:A,normal:C,tangent:E,color:R,texCoord0:S}=M.vertexAttributes,U={position:A.typedBuffer,normal:s(C)?C.typedBuffer:null,tangent:s(E)?E.typedBuffer:null,uv:s(S)?S.typedBuffer:null,color:s(R)?R.typedBuffer:null},P=H(U,o,m);return{transform:P.transform,components:M.components,spatialReference:o.spatialReference,vertexAttributes:new f({position:P.vertexAttributes.position,normal:P.vertexAttributes.normal,tangent:P.vertexAttributes.tangent,color:U.color,uv:U.uv})}}function X(t,r){if(a(t))return"-";const o=t.typedBuffer;return`${e(r,o.buffer,(()=>r.size))}/${o.byteOffset}/${o.byteLength}`}function Y(t,r,e){r.writeVertices&&function(t,r){const{position:e,normal:i,tangent:n,color:a,texCoord0:c}=t.vertexAttributes,l=r.region.start,{attributes:u,transform:f}=r.gltf,j=u.position.count;if(M(e.slice(l,j),u.position,f),s(u.normal)&&s(i)){const t=m(p(),f),r=i.slice(l,j);A(r,u.normal,t),o(t)&&C(r,r)}else s(i)&&E(i,0,0,1,{dstIndex:l,count:j});if(s(u.tangent)&&s(n)){const t=m(p(),f),r=n.slice(l,j);P(r,u.tangent,t),o(t)&&$(r,r)}else s(n)&&G(n,0,0,1,1,{dstIndex:l,count:j});if(s(u.texCoord0)&&s(c)?L(c.slice(l,j),u.texCoord0):s(c)&&N(c,0,0,{dstIndex:l,count:j}),s(u.color)&&s(a)){const t=u.color,r=a.slice(l,j);if(4===t.elementCount)t instanceof d?D(r,t,255):t instanceof x?_(r,t):t instanceof y&&F(r,t,8);else{G(r,255,255,255,255);const e=T.fromTypedArray(r.typedBuffer,r.typedBufferStride);t instanceof h?R(e,t,255):t instanceof T?S(e,t):t instanceof b&&U(e,t,8)}}else s(a)&&G(a.slice(l,j),255,255,255,255)}(t,r);const i=r.gltf,n=function(t,r){switch(r){case K.TRIANGLES:return z(t,J);case K.TRIANGLE_STRIP:return k(t);case K.TRIANGLE_FAN:return q(t)}}(i.indices||i.attributes.position.count,i.primitiveType),a=r.region.start;if(a)for(let t=0;t<n.length;t++)n[t]+=a;t.components.push(new u({faces:n,material:e.get(i.material),trustSourceNormals:!0}))}function Z(t){switch(t){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function tt(t){switch(t){case Q.CLAMP_TO_EDGE:return"clamp";case Q.MIRRORED_REPEAT:return"mirror";case Q.REPEAT:return"repeat"}}function rt(t){return t**(1/V)*255}export{W as loadGLTFMesh};
