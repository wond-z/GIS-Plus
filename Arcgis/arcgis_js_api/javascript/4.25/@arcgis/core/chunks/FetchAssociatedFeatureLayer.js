/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{id as t}from"../kernel.js";import r from"../request.js";import{a as e,i as a}from"./maybe.js";import{throwIfAbortError as s}from"../core/promiseUtils.js";import i from"../layers/FeatureLayer.js";import n from"../portal/Portal.js";import o from"../portal/PortalItem.js";class l{constructor(t,r,e,a){this._parsedUrl=t,this._portalItem=r,this._apiKey=e,this.signal=a,this._rootDocument=null;const s=this._parsedUrl?.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);s&&(this._urlParts={root:s[1],layerId:parseInt(s[2],10)})}async fetch(){if(!this._urlParts)return null;const t=this._portalItem??await this._portalItemFromServiceItemId();if(e(t))return this._loadFromUrl();const r=await this._findAndLoadRelatedPortalItem(t);return e(r)?null:this._loadFeatureLayerFromPortalItem(r)}async fetchPortalItem(){if(!this._urlParts)return null;const t=this._portalItem??await this._portalItemFromServiceItemId();return e(t)?null:this._findAndLoadRelatedPortalItem(t)}async _fetchRootDocument(){if(a(this._rootDocument))return this._rootDocument;if(e(this._urlParts))return this._rootDocument={},{};const t={query:{f:"json",token:this._apiKey},responseType:"json",signal:this.signal},s=`${this._urlParts.root}/SceneServer`;try{const e=await r(s,t);this._rootDocument=e.data}catch{this._rootDocument={}}return this._rootDocument}async _fetchServiceOwningPortalUrl(){const e=this._parsedUrl?.path,a=e?t?.findServerInfo(e):null;if(a?.owningSystemUrl)return a.owningSystemUrl;const i=e?e.replace(/(.*\/rest)\/.*/i,"$1")+"/info":null;try{const t=(await r(i,{query:{f:"json"},responseType:"json",signal:this.signal})).data.owningSystemUrl;if(t)return t}catch(t){s(t)}return null}async _findAndLoadRelatedPortalItem(t){try{return(await t.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:this.signal})).find((t=>"Feature Service"===t.type))||null}catch(t){return s(t),null}}async _loadFeatureLayerFromPortalItem(t){await t.load({signal:this.signal});const r=await this._findMatchingAssociatedSublayerUrl(t.url??"");return new i({url:r,portalItem:t}).load({signal:this.signal})}async _loadFromUrl(){const t=await this._findMatchingAssociatedSublayerUrl(`${this._urlParts?.root}/FeatureServer`);return new i({url:t}).load({signal:this.signal})}async _findMatchingAssociatedSublayerUrl(t){const e=t.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i,"$1"),a={query:{f:"json"},responseType:"json",authMode:"no-prompt",signal:this.signal},s=this._urlParts?.layerId,i=this._fetchRootDocument(),n=r(e,a),[o,l]=await Promise.all([n,i]),c=l&&l.layers,u=o.data&&o.data.layers;if(!Array.isArray(u))throw new Error("expected layers array");if(Array.isArray(c)){for(let t=0;t<Math.min(c.length,u.length);t++)if(c[t].id===s)return`${e}/${u[t].id}`}else if(null!=s&&s<u.length)return`${e}/${u[s].id}`;throw new Error("could not find matching associated sublayer")}async _portalItemFromServiceItemId(){const t=(await this._fetchRootDocument()).serviceItemId;if(!t)return null;const r=new o({id:t,apiKey:this._apiKey}),e=await this._fetchServiceOwningPortalUrl();a(e)&&(r.portal=new n({url:e}));try{return r.load({signal:this.signal})}catch(t){return s(t),null}}}export{l as F};
