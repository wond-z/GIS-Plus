/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{h as t}from"./object.js";import{a as e,i as a,c as s}from"./maybe.js";class r{constructor(t){if(this.next=null,!Array.isArray(t))return void(this.data=t);this.data=t[0];let e=this;for(let a=1;a<t.length;a++)e.next=new r([t[a]]),e=e.next}*values(){let t=this;for(;t;)yield t.data,t=t.next}forEach(t){let e=this;for(;e;)t(e.data),e=e.next}find(t){return t(this.data)?this:this.next?.find(t)}max(t,e=this){const a=t(this.data)>t(e.data)?this:e;return this.next?this.next.max(t,a):a}remove(t,e=null){return this===t?e?(e.next=this.next,e):this.next:this.next?.remove(t,this)??null}get last(){return this.next?this.next.last:this}}class n{constructor(t){this._head=null,e(t)||(this._head=new r(t))}get head(){return this._head}maxAvailableSpace(){if(e(this._head))return 0;const t=this._head.max((t=>t.end-t.start));return t.data.end-t.data.start}firstFit(t){if(e(this._head))return null;let a=null,s=this._head;for(;s;){const e=s.data.end-s.data.start;if(e===t)return a?a.next=s.next:this._head=s.next,s.data.start;if(e>t){const e=s.data.start;return s.data.start+=t,e}a=s,s=s.next}return null}free(t,a){const s=t+a;if(e(this._head)){const e=new r({start:t,end:s});return void(this._head=e)}if(s<=this._head.data.start){if(s===this._head.data.start)return void(this._head.data.start-=a);const e=new r({start:t,end:s});return e.next=this._head,void(this._head=e)}let n=this._head,i=n.next;for(;i;){if(i.data.start>=s){if(n.data.end===t){if(n.data.end+=a,n.data.end===i.data.start){const t=i.data.end-i.data.start;return n.data.end+=t,void(n.next=i.next)}return}if(i.data.start===s)return void(i.data.start-=a);const e=new r({start:t,end:s});return e.next=n.next,void(n.next=e)}n=i,i=i.next}if(t===n.data.end)return void(n.data.end+=a);const h=new r({start:t,end:s});n.next=h}}const i=t("esri-2d-log-allocations");class h{constructor(t,e){this._array=t,this._pool=e}get array(){return this._array}get length(){return this._array.length}static create(t,e){const a=e.acquire(t);return new h(a,e)}expand(t){const e=this._pool.acquire(t);e.set(this._array),this._pool.release(this._array),this._array=e}destroy(){this._pool.release(this._array)}set(t,e){this._array.set(t._array,e)}slice(){const t=this._pool.acquire(this._array.byteLength);return t.set(this._array),new h(t,this._pool)}}class d{constructor(){this._data=new ArrayBuffer(d.BYTE_LENGTH),this._freeList=new n({start:0,end:this._data.byteLength})}static get BYTE_LENGTH(){return 64e6}get buffer(){return this._data}allocate(t){const a=this._freeList.firstFit(t);return e(a)?null:new Uint32Array(this._data,a,t/Uint32Array.BYTES_PER_ELEMENT)}free(t){this._freeList.free(t.byteOffset,t.byteLength)}}class o{constructor(){this._bytesAllocated=0,this._pages=[],this._pagesByBuffer=new Map,this._addPage()}destroy(){this._pages=[],this._pagesByBuffer=null}get _bytesTotal(){return this._pages.length*d.BYTE_LENGTH}acquire(t){if(this._bytesAllocated+=t,i&&console.log(`Allocating ${t}, (${this._bytesAllocated} / ${this._bytesTotal})`),t>d.BYTE_LENGTH)return new Uint32Array(t/Uint32Array.BYTES_PER_ELEMENT);for(const e of this._pages){const s=e.allocate(t);if(a(s))return s}return s(this._addPage().allocate(t),"Expected to allocate page")}release(t){this._bytesAllocated-=t.byteLength,i&&console.log(`Freeing ${t.byteLength}, (${this._bytesAllocated} / ${this._bytesTotal})`);const e=this._pagesByBuffer.get(t.buffer);e&&e.free(t)}_addPage(){const t=new d;return this._pages.push(t),this._pagesByBuffer.set(t.buffer,t),t}}export{o as B,n as F,r as L,h as T};
