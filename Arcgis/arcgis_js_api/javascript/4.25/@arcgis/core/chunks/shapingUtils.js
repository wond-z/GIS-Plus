/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{B as t}from"./BidiEngine.js";import{f as s,m as e,t as i,r as h}from"./mat2d.js";import{c as n,t as r}from"./mat2df32.js";import{s as a,t as o}from"./vec2.js";import{f as c,c as f}from"./vec2f32.js";import{V as d}from"./alignmentUtils.js";import{i as l}from"./number2.js";import{R as m}from"./Rect.js";const g=new t;function u(t){if(!g.hasBidiChar(t))return[t,!1];let s;return s="rtl"===g.checkContextual(t)?"IDNNN":"ICNNN",[g.bidiTransform(t,s,"VLYSN"),!0]}class x{constructor(t,s,e,i){this.center=c(t,s),this.centerT=f(),this.halfWidth=e/2,this.halfHeight=i/2,this.width=e,this.height=i}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(t){this.center[0]=t}set y(t){this.center[1]=t}clone(){return new x(this.x,this.y,this.width,this.height)}serialize(t){return t.writeF32(this.center[0]),t.writeF32(this.center[1]),t.push(this.width),t.push(this.height),t}findCollisionDelta(t,s=4){const e=Math.abs(t.centerT[0]-this.centerT[0]),i=Math.abs(t.centerT[1]-this.centerT[1]),h=(t.halfWidth+this.halfWidth+s)/e,n=(t.halfHeight+this.halfHeight+s)/i,r=Math.min(h,n);return Math.log2(r)}extend(t){const s=Math.min(this.xmin,t.xmin),e=Math.min(this.ymin,t.ymin),i=Math.max(this.xmax,t.xmax)-s,h=Math.max(this.ymax,t.ymax)-e,n=s+i/2,r=e+h/2;this.width=i,this.height=h,this.halfWidth=i/2,this.halfHeight=h/2,this.x=n,this.y=r}static deserialize(t){const s=t.readF32(),e=t.readF32(),i=t.readInt32(),h=t.readInt32();return new x(s,e,i,h)}}const _=Math.PI/180;class w{constructor(t,s,e,i){this._rotationT=n(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const h=e.rect,r=new Float32Array(8);t*=i,s*=i;const a=e.code?h.width*i:e.metrics.width,o=e.code?h.height*i:e.metrics.height;r[0]=t,r[1]=s,r[2]=t+a,r[3]=s,r[4]=t,r[5]=s+o,r[6]=t+a,r[7]=s+o,this._data=r,this._setTextureCoords(h),this._scale=i,this._mosaic=e,this.x=t,this.y=s,this.maxOffset=Math.max(t+a,s+o)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(t){this._angle=t,s(this._rotationT,-t),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:t,width:s}=this._mosaic.metrics,i=s*this._scale,h=Math.abs(t)*this._scale,a=new Float32Array(8);a[0]=this.x,a[1]=this.y,a[2]=this.x+i,a[3]=this.y,a[4]=this.x,a[5]=this.y+h,a[6]=this.x+i,a[7]=this.y+h;const o=e(n(),this._rotationT,this._transform);r(a,a,o);let c=1/0,f=1/0,d=0,l=0;for(let t=0;t<4;t++){const s=a[2*t],e=a[2*t+1];c=Math.min(c,s),f=Math.min(f,e),d=Math.max(d,s),l=Math.max(l,e)}const m=d-c,g=l-f,u=c+m/2,_=f+g/2;this._bounds=new x(u,_,m,g)}return this._bounds}setTransform(t){this._transform=t,this._offsets=null}_setOffsets(t){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const s=this._offsets,i=new Float32Array(8),h=e(n(),this._rotationT,this._transform);r(i,t,h),s.upperLeft=l(8*i[0],8*i[1]),s.upperRight=l(8*i[2],8*i[3]),s.lowerLeft=l(8*i[4],8*i[5]),s.lowerRight=l(8*i[6],8*i[7])}_setTextureCoords({x:t,y:s,width:e,height:i}){this._texcoords={upperLeft:l(t,s),upperRight:l(t+e,s),lowerLeft:l(t,s+i),lowerRight:l(t+e,s+i)}}}const p=(t,s)=>({code:0,page:0,sdf:!0,rect:new m(0,0,11,8),textureBinding:s,metrics:{advance:0,height:4,width:t,left:0,top:0}});class y{constructor(t,s,e){this._rotation=0,this._decorate(t,s,e),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=s.length>1,this._hasRotation=0!==e.angle,this._transform=this._createGlyphTransform(this.bounds,e);for(const s of t)s.setTransform(this._transform)}setRotation(t){if(0===t&&0===this._rotation)return;this._rotation=t;const i=this._transform,h=s(n(),t);e(i,h,i);for(const t of this.glyphs)t.setTransform(this._transform)}_decorate(t,s,e){if(!e.decoration||"none"===e.decoration||!t.length)return;const i=e.scale,h="underline"===e.decoration?30:20,n=t[0].textureBinding;for(const e of s){const s=e.startX*i,r=e.startY*i,a=(e.width+e.glyphWidthEnd)*i;t.push(new w(s,r+h*i,p(a,n),1))}}get boundsT(){const t=this.bounds,s=a(f(),t.x,t.y);if(o(s,s,this._transform),this._hasRotation){const e=Math.max(t.width,t.height);return new x(s[0],s[1],e,e)}return new x(s[0],s[1],t.width,t.height)}_createBounds(t){let s=1/0,e=1/0,i=0,h=0;for(const n of t)s=Math.min(s,n.xTopLeft),e=Math.min(e,n.yTopLeft),i=Math.max(i,n.xTopLeft+n.width),h=Math.max(h,n.yBottomRight);const n=i-s,r=h-e;return new x(s+n/2,e+r/2,n,r)}_createGlyphTransform(t,s){const e=_*s.angle,r=n(),o=f();return i(r,r,a(o,s.xOffset,-s.yOffset)),s.isCIM?h(r,r,e):(i(r,r,a(o,t.x,t.y)),h(r,r,e),i(r,r,a(o,-t.x,-t.y))),r}}class M{constructor(t,s,e,i,h,n){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(s,e)),this.end=Math.max(0,Math.max(s,e)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=i,this.yMin=h,this.yMax=n}}const T=t=>10===t,b=t=>32===t;function B(t,s,e){const i=e.scale,h=new Array,n=function(t,s,e){const i=new Array,h=1/e.scale,n=e.maxLineWidth*h,r=s?t.length-1:0,a=s?-1:t.length,o=s?-1:1;let c=r,f=0,d=0,l=c,m=l,g=0,u=1/0,x=0;for(;c!==a;){const{code:s,metrics:e}=t[c],h=Math.abs(e.top);if(T(s)||b(s)||(u=Math.min(u,h),x=Math.max(x,h+e.height)),T(s))c!==r&&(i.push(new M(t,l,c-o,f,u,x)),u=1/0,x=0),f=0,l=c+o,m=c+o,d=0;else if(b(s))m=c+o,d=0,g=e.advance,f+=e.advance;else if(f>n){if(m!==l){const s=m-2*o;f-=g,i.push(new M(t,l,s,f-d,u,x)),u=1/0,x=0,l=m,f=d}else i.push(new M(t,l,c-o,f,u,x)),u=1/0,x=0,l=c,m=c,f=0;f+=e.advance,d+=e.advance}else f+=e.advance,d+=e.advance;c+=o}const _=new M(t,l,c-o,f,u,x);return _.start>=0&&_.end<t.length&&i.push(_),i}(t,s,e),r=function(t,s){let e=0;for(let s=0;s<t.length;s++){const{width:i}=t[s];e=Math.max(i,e)}const i="underline"===s.decoration?4:0,h=t[0].yMin;return{x:0,y:h,height:t[t.length-1].yMax+s.lineHeight*(t.length-1)+i-h,width:e}}(n,e),{vAlign:a,hAlign:o}=e,c=a===d.Baseline?1:0,f=c?0:a-1,l=(1-c)*-r.y+f*(r.height/2)+-26*(c?1:0);for(let s=0;s<n.length;s++){const{start:r,end:a,width:c}=n[s];let f=-1*(o+1)*(c/2)-3;const d=s*e.lineHeight+l-3;n[s].startX=f,n[s].startY=d;for(let s=r;s<=a;s++){const e=t[s];if(T(e.code))continue;const n=new w(f+e.metrics.left,d-e.metrics.top,e,i);f+=e.metrics.advance,h.push(n)}}return new y(h,n,e)}export{u as b,B as s};
