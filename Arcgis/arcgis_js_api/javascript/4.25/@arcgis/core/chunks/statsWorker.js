/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../geometry.js";import e from"../core/Error.js";import{u as n,i}from"./maybe.js";import{a}from"./screenUtils.js";import t,{n as o,g as s}from"../geometry/SpatialReference.js";import{q as l}from"./quantizationUtils.js";import{isNumericField as r,numericTypes as u}from"../layers/support/fieldUtils.js";import{c as f,e as m}from"./heatmapUtils.js";import{b as d,d as c,i as p,e as y,f as h,p as v,h as I,c as x,j as z,r as T,k as $}from"./utils13.js";import{l as g}from"./arcadeOnDemand.js";import F from"../geometry/Point.js";let j=null;async function b(e,n){if(!n)return[];const{field:i,field2:a,field3:o,fieldDelimiter:s}=e,l=e.valueExpression,r=e.normalizationType,u=e.normalizationField,f=e.normalizationTotal,m=[],p=e.viewInfoParams;let y=null,h=null;if(l){if(!j){const{arcadeUtils:e}=await g();j=e}y=j.createFunction(l),h=p&&j.getViewInfo({viewingMode:p.viewingMode,scale:p.scale,spatialReference:new t(p.spatialReference)})}const v=e.fieldInfos,I=n[0]&&"declaredClass"in n[0]&&"esri.Graphic"===n[0].declaredClass||!v?null:{fields:v};return n.forEach((e=>{const n=e.attributes;let t;if(l){const n=I?{...e,layer:I}:e,i=j.createExecContext(n,h);t=j.executeFunction(y,i)}else n&&(t=n[i],a&&(t=`${d(t)}${s}${d(n[a])}`,o&&(t=`${t}${s}${d(n[o])}`)));if(r&&"number"==typeof t&&isFinite(t)){const e=n&&parseFloat(n[u]);t=c(t,r,e,f)}m.push(t)})),m}function w(e){const n=e.field,i=e.normalizationType,a=e.normalizationField;let t;return"field"===i?t="(NOT "+a+" = 0)":"log"!==i&&"natural-log"!==i&&"square-root"!==i||(t=`(${n} > 0)`),t}function E(n,i){return new e(n,i)}function V(e,n,i){const a=null!=n?e+" >= "+n:"",t=null!=i?e+" <= "+i:"";let o="";return o=a&&t?P(a,t):a||t,o?"("+o+")":""}function M(e,n,i,a){let t=null;return n?n.name!==e.objectIdField&&a.includes(n.type)||(t=E(i,"'field' should be one of these types: "+a.join(","))):t=E(i,"'field' is not defined in the layer schema"),t}function D(e,n,i){let a;return n?n.name!==e.objectIdField&&r(n)||(a=E(i,"'field' should be one of these numeric types: "+u.join(","))):a=E(i,"'field' is not defined in the layer schema"),a}function P(e,n){let a=i(e)?e:"";return i(n)&&n&&(a=a?"("+a+") AND ("+n+")":n),a}function N(e,n){if(e&&"intersects"!==e.spatialRelationship)return E(n,"Only 'intersects' spatialRelationship is supported for featureFilter")}function S(e,n,i){const a=function(e){const n=e.layer;return e.fields.filter((e=>!n.getField(e)))}({layer:e,fields:n});if(a.length)return E(i,"Unknown fields: "+a.join(", ")+". You can only use fields defined in the layer schema");const t=function(e){const n=e.layer;return e.fields.filter((e=>{const i=n.getFieldUsageInfo(e);return!i||!i.supportsStatistics}))}({layer:e,fields:n});return t.length?E(i,"Unsupported fields: "+t.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function U(e,n,i){const a=[],t=[],o=[],s=[],l=[];e.forEach(((e,n)=>{const r=e.field?"field":"expression",u=e.field||e.valueExpression;e.field?(l.push(u),t.push(`var ${r}${n} = Number($feature["${u}"]);`)):(a.push(`function getValueForExpr${n}() {\n  ${u} \n}`),t.push(`var ${r}${n} = Number(getValueForExpr${n}());`)),i||o.push(`${r}${n} = IIf(${r}${n} < 0, 0, ${r}${n});`),s.push(`${r}${n}`)}));let r="return sum;";const u=a.length?null:l.reduce(((e,n)=>`${e} + ${n}`));let f=null;return n||i?n?i||(r="return IIf(sum >= 0, sum, null);",u&&(f=`(( ${u} ) >= 0)`)):(r="return IIf(sum != 0, sum, null);",u&&(f=`(( ${u} ) <> 0)`)):(r="return IIf(sum > 0, sum, null);",u&&(f=`(( ${u} ) > 0)`)),{valueExpression:[a.length?a.join("\n"):"",t.join("\n"),o.join("\n"),`var sum = ${s.join(" + ")};`,r].filter(Boolean).join("\n\n"),sqlExpression:u,sqlWhere:f}}async function C(e){const{attribute:n,features:i}=e,{normalizationType:a,normalizationField:t,minValue:o,maxValue:s,fieldType:l}=n,r=await b({field:n.field,valueExpression:n.valueExpression,normalizationType:a,normalizationField:t,normalizationTotal:n.normalizationTotal,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i),u=p({normalizationType:a,normalizationField:t,minValue:o,maxValue:s}),f={value:.5,fieldType:l},m="esriFieldTypeString"===l?y({values:r,supportsNullCount:u,percentileParams:f}):h({values:r,minValue:o,maxValue:s,useSampleStdDev:!a,supportsNullCount:u,percentileParams:f});return v(m,"esriFieldTypeDate"===l)}async function q(e){const{attribute:n,features:i}=e,a=await b({field:n.field,field2:n.field2,field3:n.field3,fieldDelimiter:n.fieldDelimiter,valueExpression:n.valueExpression,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i),t=I(a);return x(t,n.domains,n.returnAllCodedValues,n.fieldDelimiter)}async function O(e){const{attribute:n,features:i}=e,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l}=n,r=await b({field:a,valueExpression:n.valueExpression,normalizationType:t,normalizationField:o,normalizationTotal:s,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i),u=z(r,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l,standardDeviationInterval:n.standardDeviationInterval,numClasses:n.numClasses,minValue:n.minValue,maxValue:n.maxValue});return T(u,l)}async function R(e){const{attribute:n,features:i}=e,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l}=n,r=await b({field:a,valueExpression:n.valueExpression,normalizationType:t,normalizationField:o,normalizationTotal:s,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},i);return $(r,{field:a,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:l,standardDeviationInterval:n.standardDeviationInterval,numBins:n.numBins,minValue:n.minValue,maxValue:n.maxValue})}async function _(e){const{attribute:i,features:t}=e,{field:r,radius:u,fieldOffset:d,transform:c,spatialReference:p,size:y}=i,h=function(e,i,a,t){const r=o(a)?s(a):null,u=r?Math.round((r.valid[1]-r.valid[0])/i.scale[0]):null;return e.map((e=>{const a=new F(n(e.geometry));return l(i,a,a,a.hasZ,a.hasM),e.geometry=r?function(e,n,i){return e.x<0?e.x+=n:e.x>i&&(e.x-=n),e}(a,u,t[0]):a,e}))}(t,c,p,y),{count:v,min:I,max:x,mean:z,stdDev:T}=function(e,n=18,i,t,o,s){const l=new Float64Array(o*s);n=Math.round(a(n));let r=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,d=0,c=0,p=0,y=0;const h=f(t,i);for(const{geometry:i,attributes:a}of e){const{x:e,y:t}=i,f=Math.max(0,e-n),v=Math.max(0,t-n),I=Math.min(s,t+n),x=Math.min(o,e+n),z=+h(a);for(let i=v;i<I;i++)for(let a=f;a<x;a++){const s=i*o+a,f=m(a-e,i-t,n),h=l[s];d=l[s]+=f*z;const v=d-h;c+=v,p+=v*v,d<r&&(r=d),d>u&&(u=d),y++}}if(!y)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const v=(u-r)/2;return{mean:c/y,stdDev:Math.sqrt((p-c*c/y)/y),min:r,max:u,mid:v,count:y}}(h,u,d,r,y[0],y[1]);return{count:v,min:I,max:x,avg:z,stddev:T}}const A=Object.freeze(Object.defineProperty({__proto__:null,summaryStatistics:C,uniqueValues:q,classBreaks:O,histogram:R,heatmapStatistics:_},Symbol.toStringTag,{value:"Module"}));export{V as a,_ as b,O as c,b as d,D as e,N as f,w as g,R as h,M as i,U as j,A as k,P as m,C as s,q as u,S as v};
