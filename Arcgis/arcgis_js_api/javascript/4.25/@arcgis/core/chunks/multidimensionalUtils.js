/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{i as e,a as n}from"./maybe.js";import t from"../layers/support/DimensionalDefinition.js";function a(e,n,t){const s=n.shift();if(0===t.length){const e=[];t.push({sliceId:-1,multidimensionalDefinition:e})}const i=t.length;for(let n=0;n<i;n++){const n=t.shift().multidimensionalDefinition;s.values?.forEach((a=>{t.push({sliceId:-1,multidimensionalDefinition:[...n,{variableName:e,dimensionName:s.name,values:[a]}]})}))}n.length&&a(e,n,t)}function s(e,n){const t=[];let s=0;return(n?e.variables.filter((e=>e.name.toLowerCase()===n.toLowerCase())):[...e.variables].sort(((e,n)=>e.name>n.name?1:-1))).forEach((e=>{const n=[],i=[...e.dimensions].sort(((e,n)=>e.name>n.name?-1:1));a(e.name,i,n),n.forEach((e=>{t.push({...e,sliceId:s++})}))})),t}function i(n,t,a){let s=n;if(t&&(t=[...t].sort(((e,n)=>e.dimensionName<n.dimensionName?-1:1))).forEach((({dimensionName:e,values:n,isSlice:t})=>{n.length&&(s=s.filter((a=>{const s=a.multidimensionalDefinition.find((n=>n.dimensionName===e));if(null==s)return!1;const i=s.values[0];return"number"==typeof i?"number"==typeof n[0]?n.includes(i):n.some((e=>e[0]<=i&&e[1]>=i)):"number"==typeof n[0]?n.some((e=>i[0]<=e&&i[1]>=e)):t?n.some((e=>e[0]===i[0]&&e[0]===i[1])):n.some((e=>e[0]>=i[0]&&e[0]<=i[1]||e[1]>=i[0]&&e[1]<=i[1]||e[0]<i[0]&&e[1]>i[1]))})))})),s.length&&a&&e(a.start)&&e(a.end)){const e=a.start.getTime(),n=a.end.getTime(),t=s[0].multidimensionalDefinition.findIndex((e=>"StdTime"===e.dimensionName));t>-1&&(s=s.filter((a=>{const s=a.multidimensionalDefinition[t].values[0];return e<=s&&n>=s})))}return s.map((e=>e.sliceId))}function r(e,n){return Array.isArray(e)?n[0]===n[1]?e[0]===n[0]||e[1]===n[0]:e[0]>=n[0]&&e[0]<=n[1]&&e[1]>=n[0]&&e[1]<=n[1]:e>=n[0]&&e<=n[1]}function l(e,n){return e[0]<=n[0]&&e[1]>=n[0]||e[0]<=n[1]&&e[1]>=n[1]||e[0]>=n[0]&&e[1]<=n[1]}function o(e){return 1===e.length?[e[0],e[0]]:[e[0],e[e.length-1]]}function u(e,n,t){if(!n?.subsetDefinitions?.length)return e;let a;if(t){const{variables:s}=n;if(s.length&&!s.includes(t))return null;const i=n.subsetDefinitions.find((n=>n.dimensionName===e.name&&n.variableName===t));if(!i?.values?.length)return e;a=o(i.values)}else a=n.dimensions.find((({name:n})=>n===e.name))?.extent;const s=a;if(!s||!s?.length)return e;const i=e.values.filter((e=>r(e,s)));return{...e,extent:[...s],values:i}}function m(e,n,t){if(!n?.subsetDefinitions?.length)return!1;const{variables:a}=n;if(a.length&&e.some((({variableName:e})=>e&&!a.includes(e))))return!0;for(let a=0;a<e.length;a++){const s=e[a],i=n.subsetDefinitions.find((e=>(""===s.variableName||e.variableName===s.variableName)&&e.dimensionName===s.dimensionName));if(i?.values.length){const e=o(i.values);if(s.isSlice||2!==s.values.length||Array.isArray(s.values[0])||s.values[0]===s.values[1]||!t){if(s.values.some((n=>!r(n,e))))return!0}else if(!l(s.values,e))return!0}}return!1}function c(e,a={}){const{multidimensionalInfo:s,keyProperties:i}=e;if(n(s))return null;const r=a.variableName||i?.DefaultVariable;let{variables:l}=s;const{multidimensionalSubset:o}=a;o?.variables?.length&&(l=l.filter((({name:e})=>o.variables.includes(e))));const m=r?l.find((({name:e})=>e===r))??l[0]:l[0];if(!m)return null;const c=[],{dimensions:f,name:d}=m;if(0===f.length)return[new t({variableName:d,dimensionName:"",values:[],isSlice:!0})];for(let e=0;e<f.length;e++){const n=u(f[e],o,d);if(!n)return null;const{values:s,extent:i}=n;let r=s?.[0]??i[0];"stdz"===n.name.toLowerCase()&&!n.hasRanges&&Math.abs(i[1])<=Math.abs(i[0])&&(r=s?.length?s[s.length-1]:i[1]),c.push(new t({variableName:d,dimensionName:n.name,values:[r],isSlice:!a.useRangeForRangedDimensionInfo||!!n.hasRanges}))}return c}function f(e){return!(n(e)||!e.length)&&e.some((e=>{if(null==e.values)return!0;const n=e.values.length;return 0===n||n>1||!e.isSlice&&Array.isArray(e.values[0])}))}function d(e,t){if(n(t)||n(e))return null;let a=t.variables.map((e=>({...e})));return e?.variables?.length&&(a=a.filter((({name:n})=>e.variables.includes(n))),a.forEach((n=>{n.dimensions=n.dimensions.map((t=>u(t,e,n.name)))}))),a}function h(e,n){const{values:t}=n;if(t?.length)return Array.isArray(t[0])!==Array.isArray(e)?-1:Array.isArray(t[0])?t.findIndex((n=>n[0]===e[0]&&n[1]===e[1])):t.indexOf(e);const{extent:a}=n;if(Array.isArray(e)||e<a[0]||e>a[1])return-1;const s=n.interval||1;if("ISO8601"!==n.unit)return Math.round((e-a[0])/s);const i=a[0];let r=-1;switch(n.intervalUnit?.toLowerCase()||"seconds"){case"seconds":r=Math.round((e-i)/1e3/s);break;case"minutes":r=Math.round((e-i)/6e4/s);break;case"hours":r=Math.round((e-i)/36e5/s);break;case"days":r=Math.round((e-i)/864e5/s);break;case"months":{const n=new Date(e).getUTCFullYear()-new Date(i).getUTCFullYear(),t=new Date(i).getUTCMonth(),a=new Date(e).getUTCMonth();r=0===n?a-t:a+11-t+12*(n-1)}break;case"years":r=Math.round((new Date(e).getUTCFullYear()-new Date(i).getUTCFullYear())/s);break;case"decades":r=Math.round((new Date(e).getUTCFullYear()-new Date(i).getUTCFullYear())/10/s)}return r}function g(e){let n=e.values?.length;if(n)return n;const{extent:t,unit:a}=e,s=e.interval||1,i=t?t[1]-t[0]:0;if("ISO8601"!==a)return Math.round(i/s);switch(e.intervalUnit?.toLowerCase()??"seconds"){case"seconds":n=Math.round(i/1e3/s);break;case"minutes":n=Math.round(i/6e4/s);break;case"hours":n=Math.round(i/36e5/s);break;case"days":n=Math.round(i/864e5/s);break;case"months":{const e=new Date(t[1]).getUTCFullYear()-new Date(t[0]).getUTCFullYear(),a=new Date(t[1][0]).getUTCMonth(),s=new Date(t[1][1]).getUTCMonth();n=0===e?s-a+1:s+11-a+12*(e-1)+1}break;case"years":n=Math.round((new Date(t[1]).getUTCFullYear()-new Date(t[0]).getUTCFullYear())/s);break;case"decades":n=Math.round((new Date(t[1]).getUTCFullYear()-new Date(t[0]).getUTCFullYear())/10/s);break;default:n=0}return n}function v(e,n){let t=0;const a=e[0].variableName,s=[...n.variables].sort(((e,n)=>e.name>n.name?1:-1));for(let n=0;n<s.length;n++){const i=s[n],r=[...i.dimensions].sort(((e,n)=>e.name>n.name?-1:1));if(i.name!==a){t+=r.map((e=>g(e))).reduce(((e,n)=>e*n));continue}const l=r.map((e=>g(e))),o=r.length;for(let n=0;n<o;n++){const a=e.find((e=>e.dimensionName===r[n].name));if(null==a)return null;const s=h(a.values[0],r[n]);if(-1===s)return null;l.shift(),t+=n===o-1?s:s*l.reduce(((e,n)=>e*n))}break}return t}export{c as a,v as b,s as c,i as d,d as g,m as h,f as i};
