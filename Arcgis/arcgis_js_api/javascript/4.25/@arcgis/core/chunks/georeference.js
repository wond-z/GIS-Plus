/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{i as t,a as r}from"./maybe.js";import{e as o,g as n,c as e}from"./unitUtils.js";import{c as a}from"./mat3f64.js";import{b as i,c as s,m as l,e as c,d as p,g as u}from"./mat4.js";import{c as f,I as g}from"./mat4f64.js";import{n as m}from"./mat3.js";import{computeTranslationToOriginAndRotation as y,projectBuffer as h}from"../geometry/projection.js";import{c as j}from"./projectionEllipsoid.js";import{_ as A}from"./tslib.es6.js";import{JSONSupport as d}from"../core/JSONSupport.js";import{property as w}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import{subclass as x}from"../core/accessorSupport/decorators/subclass.js";import{s as T}from"./quat.js";import{c as b}from"./quatf64.js";import{d as v,f as M,e as F,j as R,k as E}from"./vec3.js";import N from"../geometry/Point.js";import{c as z,b as P,d as S}from"./axisAngleDegrees.js";import{B as _,a as B}from"./BufferView.js";import{t as I,c as L,a as q}from"./vec32.js";import{c as O,d as G,e as Y,p as k,a as D,b as J,t as U,f as V,g as W}from"./projection.js";var C;let H=C=class extends d{constructor(t){super(t),this.origin=v(),this.translation=v(),this.rotation=z(),this.scale=M(1,1,1),this.geographic=!0}get localMatrix(){const t=f();return T(K,S(this.rotation),P(this.rotation)),i(t,K,this.translation,this.scale),t}get localMatrixInverse(){return s(f(),this.localMatrix)}applyLocal(t,r){return F(r,t,this.localMatrix)}applyLocalInverse(t,r){return F(r,t,this.localMatrixInverse)}project(t,r){const o=new Float64Array(t.length),n=_.fromTypedArray(o),e=_.fromTypedArray(t);if(this.geographic){const t=j(r),a=f();return y(r,this.origin,a,t),l(a,a,this.localMatrix),I(n,e,a),h(o,t,0,o,r,0,o.length/3),o}const{localMatrix:a,origin:i}=this;c(a,g)?L(n,e):I(n,e,a);for(let t=0;t<o.length;t+=3)o[t+0]+=i[0],o[t+1]+=i[1],o[t+2]+=i[2];return o}getOriginPoint(t){const[r,o,n]=this.origin;return new N({x:r,y:o,z:n,spatialReference:t})}equals(r){return t(r)&&this.geographic===r.geographic&&R(this.origin,r.origin)&&p(this.localMatrix,r.localMatrix)}clone(){const t={origin:E(this.origin),translation:E(this.translation),rotation:z(this.rotation),scale:E(this.scale),geographic:this.geographic};return new C(t)}};A([w({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"origin",void 0),A([w({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"translation",void 0),A([w({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"rotation",void 0),A([w({type:[Number],nonNullable:!0,json:{write:!0}})],H.prototype,"scale",void 0),A([w({type:Boolean,nonNullable:!0,json:{write:!0}})],H.prototype,"geographic",void 0),A([w()],H.prototype,"localMatrix",null),A([w()],H.prototype,"localMatrixInverse",null),H=C=A([x("esri.geometry.support.MeshTransform")],H);const K=b(),Q=H;function X(t,r){return t.isGeographic||t.isWebMercator&&(r?.geographic??!0)}function Z(t,o,n){return X(o.spatialReference,n)?function(t,o,n){const e=o.spatialReference,a=at(o,n,st),i=new Float64Array(t.position.length),s=function(t,r,o,n){I(_.fromTypedArray(n),_.fromTypedArray(t),r);const e=new Float64Array(t.length);return O(n,e,o)}(t.position,a,e,i),l=m(ct,a),c=function(t,o,n,e,a){if(r(n))return null;const i=new Float32Array(n.length);return q(B.fromTypedArray(i),B.fromTypedArray(n),e),G(i,t,o,a,i),i}(s,i,t.normal,l,e),p=function(t,o,n,e,a){if(r(n))return null;const i=new Float32Array(n.length);q(B.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT),B.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),e);for(let t=3;t<i.length;t+=4)i[t]=n[t];return Y(i,t,o,a,i),i}(s,i,t.tangent,l,e);return{position:s,normal:c,tangent:p}}(t,o,n):function(t,r,o){const n=new Float64Array(t.position.length),e=t.position,a=r.x,i=r.y,s=r.z||0,{horizontal:l,vertical:c}=it(o?o.unit:null,r.spatialReference);for(let t=0;t<e.length;t+=3)n[t+0]=e[t+0]*l+a,n[t+1]=e[t+1]*l+i,n[t+2]=e[t+2]*c+s;return{position:n,normal:t.normal,tangent:t.tangent}}(t,o,n)}function $(o,n,e){const{position:a,normal:i,tangent:s}=o;if(r(n))return{position:a,normal:i,tangent:s};const l=n.localMatrix;return Z({position:U(a,new Float64Array(a.length),l),normal:t(i)?V(i,new Float32Array(i.length),l):null,tangent:t(s)?W(s,new Float32Array(s.length),l):null},n.getOriginPoint(e),{geographic:n.geographic})}function tt(t,r,o){if(o?.useTransform){const{position:n,normal:e,tangent:a}=t;return{vertexAttributes:{position:n,normal:e,tangent:a},transform:new Q({origin:[r.x,r.y,r.z??0],geographic:X(r.spatialReference,o)})}}return{vertexAttributes:Z(t,r,o),transform:null}}function rt(t,r,o){return X(r.spatialReference,o)?et(t,r,o):nt(t,r,o)}function ot(t,o,n,e){if(r(o))return rt(t,n,e);const a=$(t,o,n.spatialReference);return n.equals(o.getOriginPoint(n.spatialReference))?nt(a,n,e):X(n.spatialReference,e)?et(a,n,e):nt(a,n,e)}function nt(t,r,o){const n=new Float64Array(t.position.length),e=t.position,a=r.x,i=r.y,s=r.z||0,{horizontal:l,vertical:c}=it(o?o.unit:null,r.spatialReference);for(let t=0;t<e.length;t+=3)n[t+0]=(e[t+0]-a)/l,n[t+1]=(e[t+1]-i)/l,n[t+2]=(e[t+2]-s)/c;return{position:n,normal:t.normal,tangent:t.tangent}}function et(t,o,n){const e=o.spatialReference;at(o,n,st);const a=s(lt,st),i=new Float64Array(t.position.length),l=function(t,r,o,n){const e=k(t,r,n),a=_.fromTypedArray(e),i=new Float64Array(e.length),s=_.fromTypedArray(i);return I(s,a,o),i}(t.position,e,a,i),c=m(ct,a),p=function(t,o,n,e,a){if(r(t))return null;const i=D(t,o,n,e,new Float32Array(t.length)),s=B.fromTypedArray(i);return q(s,s,a),i}(t.normal,t.position,i,e,c),u=function(t,o,n,e,a){if(r(t))return null;const i=J(t,o,n,e,new Float32Array(t.length)),s=B.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT);return q(s,s,a),i}(t.tangent,t.position,i,e,c);return{position:l,normal:p,tangent:u}}function at(t,r,o){y(t.spatialReference,[t.x,t.y,t.z||0],o,j(t.spatialReference));const{horizontal:n,vertical:e}=it(r?r.unit:null,t.spatialReference);return u(o,o,[n,n,e]),o}function it(t,a){if(r(t))return pt;const i=a.isGeographic?1:o(a),s=a.isGeographic?1:n(a),l=e(1,t,"meters");return{horizontal:l*i,vertical:l*s}}const st=f(),lt=f(),ct=a(),pt={horizontal:1,vertical:1};export{Q as M,tt as a,$ as b,ot as c,Z as g,X as i,rt as u};
