/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{a as e,i as t,f as n}from"./maybe.js";import{ignoreAbortErrors as a,debounce as o}from"../core/promiseUtils.js";import{p as s}from"./dehydratedFeatureComparison.js";import{c as i}from"./hydratedFeatures.js";import{E as r}from"./dragEventPipeline.js";import{S as p}from"./SnappingContext.js";import{T as l,I as c}from"./Scheduler.js";class u{constructor(){this.next=new r}createSnapDragEventPipelineStep({predicate:o=(()=>!0),cancel:s,snappingManager:i,snappingContext:p,updatingHandles:l,useZ:c=!0}){if(e(i))return e=>e;let u=null,d=null;const f=()=>{u=n(u),i.doneSnapping(),t(d)&&d.frameTask.remove(),d=null};s.next((e=>(f(),e))),this.next=new r;const m=this._createSnapFunction(i,c);let h=null,S=null,x=null;return n=>{if(!o(n))return n;if("start"===n.action){const e=this._createFrameTask(i.view);if(d=this._createSnappingInfo(p,n,e),d.context.selfSnappingZ=null,!c&&t(n.info)){const e=this._extractSelfSnappingZ(p.coordinateHelper,n.info.handle.component);t(e)&&(d.context.selfSnappingZ={value:e,elevationInfo:p.elevationInfo})}}if(t(d)){const{context:t,originalScenePos:o,originalPos:s}=d,{mapEnd:r,mapStart:p,action:f,scenePoints:P}=n,g=this._updatePosition(s,this._computeMapDelta(r,p)),_=this._computeMapDelta(p,s),v={...n,action:"update"},y=d.context,Z=this._updateScenePosition(o,P),T=i.update({point:g,scenePoint:Z,context:t});if(x=T,this._applySnappedUpdate(r,T,_,c),h=g,S=Z,"end"!==f){const{frameTask:t}=d;e(u)&&(u=new AbortController),l.addPromise(a(m({frameTask:t,event:v,context:y,point:g,scenePoint:Z,delta:_,lastPos:h,lastScenePos:S,lastUpdate:x},u.signal)))}}return"end"===n.action&&f(),n}}_createSnapFunction(e,n){return o((async({frameTask:a,point:o,scenePoint:i,context:r,event:p,delta:l,lastPos:c,lastScenePos:u,lastUpdate:d},f)=>{const m=await a.schedule((()=>e.snap({point:o,scenePoint:i,context:r,signal:f})),f);if(m.valid){let i=await a.schedule((()=>m.apply()),f);o!==c&&t(c)&&(i=e.update({point:c,scenePoint:u,context:r})),s(i,d)||(this._applySnappedUpdate(p.mapEnd,i,l,n),this.next.execute(p))}}))}_createFrameTask(e){return"3d"===e.type?e.resourceController.scheduler.registerTask(l.SNAPPING):c}_createSnappingInfo(e,n,a){return{context:new p({editGeometryOperations:e.editGeometryOperations,elevationInfo:e.elevationInfo,pointer:e.pointer,vertexHandle:t(n.info)?n.info.handle:null,excludeFeature:e.excludeFeature,visualizer:e.visualizer}),originalPos:t(n.snapOrigin)?e.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:t(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:a}}_updatePosition(e,[t,n,a]){const o=i(e);return o.x+=t,o.y+=n,o.hasZ&&(o.z+=a),o}_updateScenePosition(t,n){return e(t)||e(n)?null:this._updatePosition(t,this._computeMapDelta(n.sceneEnd,n.sceneStart))}_computeMapDelta(e,t){const n=e.hasZ&&t.hasZ?e.z-t.z:0;return[e.x-t.x,e.y-t.y,n]}_applySnappedUpdate(e,t,[n,a,o],s){e.x=t.x+n,e.y=t.y+a,s&&e.hasZ&&t.hasZ&&(e.z=t.z+o)}_extractSelfSnappingZ(n,a){if(!n.hasZ())return null;const o=a.vertices;let s=null;for(const a of o){const o=n.getZ(a.pos);if(t(s)&&Math.abs(o-s)>1e-6)return null;e(s)&&(s=o)}return s}}export{u as S};
