/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{n as e}from"./compilerUtils.js";import{e as t,a as n,i as r}from"./maybe.js";import{j as o}from"./mat4.js";import{c as s}from"./mat4f64.js";import{d as i}from"./vec3.js";import{projectBuffer as a,computeTranslationToOriginAndRotation as u}from"../geometry/projection.js";import{i as l,a as f,g as c}from"./ElevationProvider.js";import{u as d}from"./graphicUtils.js";import{g as m,a as p}from"./unitConversionUtils.js";import{L as h}from"./Logger.js";import{throwIfAborted as g}from"../core/promiseUtils.js";import{a as E}from"./hydratedFeatures.js";import{l as v}from"./arcadeOnDemand.js";import{L as x,N as U,F as y}from"./bufferWriterUtils.js";import{g as I}from"./Material.js";function O(e,t,n,r,o,s,i,u,l,f,c){const d=F[c.mode];let m,p,h=0;if(a(e,t,n,r,l.spatialReference,o,u))return d.requiresAlignment(c)?(h=d.applyElevationAlignmentBuffer(r,o,s,i,u,l,f,c),m=s,p=i):(m=r,p=o),a(m,l.spatialReference,p,s,f.spatialReference,i,u)?h:void 0}function R(n,r,o,s,i){const a=(l(n)?n.z:f(n)?n.array[n.offset+2]:n[2])||0;switch(o.mode){case"on-the-ground":{const e=t(c(r,n,"ground"),0);return i.verticalDistanceToGround=0,i.sampledElevation=e,void(i.z=e)}case"relative-to-ground":{const e=t(c(r,n,"ground"),0),u=o.geometryZWithOffset(a,s);return i.verticalDistanceToGround=u,i.sampledElevation=e,void(i.z=u+e)}case"relative-to-scene":{const e=t(c(r,n,"scene"),0),u=o.geometryZWithOffset(a,s);return i.verticalDistanceToGround=u,i.sampledElevation=e,void(i.z=u+e)}case"absolute-height":{const e=o.geometryZWithOffset(a,s),u=t(c(r,n,"ground"),0);return i.verticalDistanceToGround=e-u,i.sampledElevation=u,void(i.z=e)}default:return e(o.mode),void(i.z=0)}}function _(e,t,n,r){return R(e,t,n,r,z),z.z}function C(e,t,n){return null==t||null==n?e.definedChanged:"on-the-ground"===t&&"on-the-ground"===n?e.staysOnTheGround:t===n||"on-the-ground"!==t&&"on-the-ground"!==n?b.UPDATE:e.onTheGroundChanged}function T(e){return"relative-to-ground"===e||"relative-to-scene"===e}function j(e){return"absolute-height"!==e}function D(e,t,n,r,s){R(t,n,s,r,z),d(e,z.verticalDistanceToGround);const i=z.sampledElevation,a=o(w,e.transformation);return P[0]=t.x,P[1]=t.y,P[2]=z.z,u(t.spatialReference,P,a,r.spatialReference)?e.transformation=a:console.warn("Could not locate symbol object properly, it might be misplaced"),i}class A{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var b;!function(e){e[e.NONE=0]="NONE",e[e.UPDATE=1]="UPDATE",e[e.RECREATE=2]="RECREATE"}(b||(b={}));const F={"absolute-height":{applyElevationAlignmentBuffer:function(e,t,n,r,o,s,i,a){const u=a.calculateOffsetRenderUnits(i),l=a.featureExpressionInfoContext;t*=3,r*=3;for(let s=0;s<o;++s){const o=e[t+0],s=e[t+1],i=e[t+2];n[r+0]=o,n[r+1]=s,n[r+2]=null==l?i+u:u,t+=3,r+=3}return 0},requiresAlignment:function(e){const t=e.meterUnitOffset,n=e.featureExpressionInfoContext;return 0!==t||null!=n}},"on-the-ground":{applyElevationAlignmentBuffer:function(e,n,r,o,s,i){let a=0;const u=i.spatialReference;n*=3,o*=3;for(let l=0;l<s;++l){const s=e[n+0],l=e[n+1],f=e[n+2],c=t(i.getElevation(s,l,f,u,"ground"),0);a+=c,r[o+0]=s,r[o+1]=l,r[o+2]=c,n+=3,o+=3}return a/s},requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:function(e,n,r,o,s,i,a,u){let l=0;const f=u.calculateOffsetRenderUnits(a),c=u.featureExpressionInfoContext,d=i.spatialReference;n*=3,o*=3;for(let a=0;a<s;++a){const s=e[n+0],a=e[n+1],u=e[n+2],m=t(i.getElevation(s,a,u,d,"ground"),0);l+=m,r[o+0]=s,r[o+1]=a,r[o+2]=null==c?u+m+f:m+f,n+=3,o+=3}return l/s},requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:function(e,n,r,o,s,i,a,u){let l=0;const f=u.calculateOffsetRenderUnits(a),c=u.featureExpressionInfoContext,d=i.spatialReference;n*=3,o*=3;for(let a=0;a<s;++a){const s=e[n+0],a=e[n+1],u=e[n+2],m=t(i.getElevation(s,a,u,d,"scene"),0);l+=m,r[o+0]=s,r[o+1]=a,r[o+2]=null==c?u+m+f:m+f,n+=3,o+=3}return l/s},requiresAlignment:()=>!0}},w=s(),z=new A,P=i(),G=h.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function q(e){const t=e&&e.expression;if("string"==typeof t){const e=Z(t);if(null!=e)return{cachedResult:e}}return null}async function B(e,t,n,r){const o=e&&e.expression;if("string"!=typeof o)return null;const s=Z(o);if(null!=s)return{cachedResult:s};const i=await v();g(n);const a=i.arcadeUtils,u=a.createSyntaxTree(o);return a.dependsOnView(u)?(null!=r&&r.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:a.createFunction(u),context:a.createExecContext(null,{sr:t}),modules:i}}}function N(e,t,n){return e.arcadeUtils.createFeature(t.attributes,t.geometry,n)}function W(e,t){if(null!=e&&!S(e)){if(!t||!e.arcade)return void G.errorOncePerTick("Arcade support required but not provided");const n=t;n._geometry&&(n._geometry=E(n._geometry)),e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context,t)}}function L(e,t=!1){let n=e&&e.featureExpressionInfo;const r=n&&n.expression;return t||"0"===r||(n=null),n}const M={cachedResult:0};function S(e){return null!=e.cachedResult}function Z(e){return"0"===e?0:null}class k{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=m(e)}get requiresSampledElevationInfo(){return"absolute-height"!==this.mode}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,t){const n=this.calculateOffsetRenderUnits(t);return null!=this.featureExpressionInfoContext?n:e+n}calculateOffsetRenderUnits(e){let t=this._meterUnitOffset;const n=this.featureExpressionInfoContext;return null!=n&&(t+=function(e){if(null!=e){if(S(e))return e.cachedResult;const t=e.arcade;let n=e.arcade.modules.arcadeUtils.executeFunction(t.func,t.context);return"number"!=typeof n&&(e.cachedResult=0,n=0),n}return 0}(n)*this._metersPerElevationInfoUnit),t/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=p(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=t(e.offset,0)}updateFeatureExpressionInfoContext(e,t,o){if(n(e))return void(this._featureExpressionInfoContext=null);const s=e&&e.arcade;var i;s&&r(t)&&r(o)?(this._featureExpressionInfoContext={cachedResult:(i=e).cachedResult,arcade:i.arcade?{func:i.arcade.func,context:i.arcade.modules.arcadeUtils.createExecContext(null,{sr:i.arcade.context.spatialReference}),modules:i.arcade.modules}:null},W(this._featureExpressionInfoContext,N(s.modules,t,o))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const t=new k;return r(e)&&t.setFromElevationInfo(e),t}}function V(e){e.include(x),e.uniforms.add([new U("geometryDepthTexture",((e,t)=>t.multipassGeometry.linearDepthTexture)),new y("nearFar",((e,t)=>t.camera.nearFar))]),e.code.add(I`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}class ${constructor(){this.enabled=!1}}export{k as E,$ as M,A as S,R as a,b,D as c,C as d,_ as e,N as f,O as g,j as h,L as i,B as j,q as k,V as m,T as n,W as s,M as z};
