/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{i as e}from"./maybe.js";import{O as t}from"./ArrayPool.js";import{P as n}from"../core/scheduling.js";import{g as s,a as i,G as r,c as o,z as h,d as a,f as d}from"./vec3.js";import{i as l}from"./frustum.js";import{w as c}from"./ray.js";import{b as u,g as f,d as _,i as m,c as p}from"./sphere.js";import{r as b}from"./Util2.js";class g{constructor(e,t){this._objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new O,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),O.clearPool(),D[0]=null,y.prune(),k.prune()}add(e,t=e.length){this._objectCount+=t,this._grow(e,t);const n=O.acquire();for(let s=0;s<t;s++){const t=e[s];this._isDegenerate(t)?this._degenerateObjects.add(t):(n.init(this._root),this._add(t,n))}O.release(n)}remove(t,n=null){this._objectCount-=t.length;const s=O.acquire();for(const i of t){const t=e(n)?n:u(this._objectToBoundingSphere(i),w);E(t[3])?(s.init(this._root),this._remove(i,t,s)):this._degenerateObjects.delete(i)}O.release(s),this._shrink()}update(e,t){if(!E(t[3])&&this._isDegenerate(e))return;const n=function(e){return D[0]=e,D}(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const s=c(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNode(s,e))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(s,e)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(s,e)&&n(e)})),!0}))}forEachAlongRayWithVerticalOffset(e,t,n,s){const i=c(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNodeWithOffset(i,e,s))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(i,e,s)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(i,e,s)&&n(e)})),!0}))}forEach(e){this._forEachNode(this._root,(t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0})),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,n,r=(()=>!0),o=1/0){let h=1/0,a=1/0,d=null;const c=N(e,t),u=s=>{if(--o,!r(s))return;const i=this._objectToBoundingSphere(s);if(!l(n,i))return;const c=T(e,t,_(i)),u=c-i[3],f=c+i[3];u<h&&(h=u,a=f,d=s)};return this._forEachNodeDepthOrdered(this._root,(r=>{if(o<=0||!l(n,r.bounds))return!1;if(s(B,c,r.halfSize),i(B,B,r.bounds),T(e,t,B)>a)return!1;const h=r.node;return h.terminals.forAll((e=>u(e))),null!==h.residents&&h.residents.forAll((e=>u(e))),!0}),e,t),d}forEachInDepthRange(e,t,n,r,o,h,a){let d=-1/0,c=1/0;const u={setRange:e=>{n===g.DepthOrder.FRONT_TO_BACK?(d=Math.max(d,e.near),c=Math.min(c,e.far)):(d=Math.max(d,-e.far),c=Math.min(c,-e.near))}};u.setRange(r);const f=T(t,n,e),m=N(t,n),p=N(t,-n),b=e=>{if(!a(e))return;const s=this._objectToBoundingSphere(e),i=_(s),r=T(t,n,i)-f,m=r-s[3],p=r+s[3];m>c||p<d||!l(h,s)||o(e,u)};this._forEachNodeDepthOrdered(this._root,(e=>{if(!l(h,e.bounds))return!1;if(s(B,m,e.halfSize),i(B,B,e.bounds),T(t,n,B)-f>c)return!1;if(s(B,p,e.halfSize),i(B,B,e.bounds),T(t,n,B)-f<d)return!1;const r=e.node;return r.terminals.forAll((e=>b(e))),null!==r.residents&&r.residents.forAll((e=>b(e))),!0}),t,n)}forEachNode(e){this._forEachNode(this._root,(t=>e(t.node,t.bounds,t.halfSize)))}forEachNeighbor(e,t){const n=f(t),s=_(t),i=t=>{const i=this._objectToBoundingSphere(t),o=f(i),h=n+o;return!(r(_(i),s)-h*h<=0)||e(t)};let o=!0;const h=e=>{o&&(o=i(e))};this._forEachNode(this._root,(e=>{const t=f(e.bounds),i=n+t;if(r(_(e.bounds),s)-i*i>0)return!1;const a=e.node;return a.terminals.forAll(h),o&&null!==a.residents&&a.residents.forAll(h),o})),o&&this.forEachDegenerateObject(h)}_intersectsNode(e,t){return S(t.bounds,2*-t.halfSize,R),S(t.bounds,2*t.halfSize,F),b(e.origin,e.direction,R,F)}_intersectsNodeWithOffset(e,t,n){return S(t.bounds,2*-t.halfSize,R),S(t.bounds,2*t.halfSize,F),n.applyToMinMax(R,F),b(e.origin,e.direction,R,F)}_intersectsObject(e,t){const n=this._objectToBoundingSphere(t);return!(n[3]>0)||m(n,e)}_intersectsObjectWithOffset(e,t,n){const s=this._objectToBoundingSphere(t);return!(s[3]>0)||m(n.applyToBoundingSphere(s),e)}_forEachNode(e,t){let n=O.acquire().init(e);const s=[n];for(;0!==s.length;){if(n=s.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++)n.node.children[e]&&s.push(O.acquire().init(n).advance(e));O.release(n)}}_forEachNodeDepthOrdered(e,t,n,s=g.DepthOrder.FRONT_TO_BACK){let i=O.acquire().init(e);const r=[i];for(function(e,t,n){if(!k.length)for(let e=0;e<8;++e)k.push({index:0,distance:0});for(let n=0;n<8;++n){const s=M[n];k.data[n].index=n,k.data[n].distance=T(e,t,s)}k.sort(((e,t)=>e.distance-t.distance));for(let e=0;e<8;++e)n[e]=k.data[e].index}(n,s,L);0!==r.length;){if(i=r.pop(),t(i)&&!i.isLeaf())for(let e=7;e>=0;--e){const t=L[e];i.node.children[t]&&r.push(O.acquire().init(i).advance(t))}O.release(i)}}_remove(e,t,n){y.clear();const s=n.advanceTo(t,((e,t)=>{y.push(e.node),y.push(t)}))?n.node.terminals:n.node.residents;if(s.removeUnordered(e),0===s.length)for(let e=y.length-2;e>=0;e-=2){const t=y.data[e],n=y.data[e+1];if(!this._purge(t,n))break}}_nodeIsEmpty(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}_purge(e,t){return t>=0&&(e.children[t]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new n({shrink:!0})),!0)}_add(e,t){t.advanceTo(this._objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const s=O.acquire().init(e);this._add(t.getItemAt(n),s),O.release(s)}}_grow(e,t){if(0!==t&&(x(e,t,(e=>this._objectToBoundingSphere(e)),q),E(q[3])&&!this._fitsInsideTree(q)))if(this._nodeIsEmpty(this._root.node))u(q,this._root.bounds),this._root.halfSize=1.25*q[3];else{const e=this._rootBoundsForRootAsSubNode(q);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(q,e):this._growRootAsSubNode(e),O.release(e)}}_rebuildTree(e,t){o(C,t.bounds),C[3]=t.halfSize,x([e,C],2,(e=>e),I);const n=O.acquire().init(this._root);this._root.initFrom(null,I,1.25*I[3]),this._forEachNode(n,(e=>(this.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&this.add(e.node.residents.data,e.node.residents.length),!0))),O.release(n)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,(e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth))),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let s=-1/0;const i=this._root.bounds,r=this._root.halfSize;for(let e=0;e<3;e++){const o=i[e]-r-(n[e]-t),h=n[e]+t-(i[e]+r),a=Math.max(0,Math.ceil(o/(2*r))),d=Math.max(0,Math.ceil(h/(2*r)))+1,l=2**Math.ceil(Math.log(a+d)*Math.LOG2E);s=Math.max(s,l),P[e].min=a,P[e].max=d}for(let e=0;e<3;e++){let t=P[e].min,n=P[e].max;const o=(s-(t+n))/2;t+=Math.ceil(o),n+=Math.floor(o);const h=i[e]-r-t*r*2;v[e]=h+(n+t)*r}return v[3]=s*r*A,O.acquire().initFrom(null,v,s*r,0)}_growRootAsSubNode(e){const t=this._root.node;o(q,this._root.bounds),q[3]=this._root.halfSize,this._root.init(e),e.advanceTo(q,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,s=0;for(;s<t.length&&null==e;)n=s++,e=t[n];for(;s<t.length;)if(t[s++])return-1;return n}_isDegenerate(e){return!E(this._objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}}class O{constructor(){this.bounds=p(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(t,n,s,i=this.depth){return this.node=e(t)?t:O.createEmptyNode(),e(n)&&u(n,this.bounds),this.halfSize=s,this.depth=i,this}advance(e){let t=this.node.children[e];t||(t=O.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=M[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.bounds[3]=this.halfSize*A,this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const s=this._childIndex(e);t&&t(this,s),this.advance(s)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new n({shrink:!0}),residents:new n({shrink:!0})}}static acquire(){return O._pool.acquire()}static release(e){O._pool.release(e)}static clearPool(){O._pool.prune()}}function j(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3])}function S(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t}function x(e,t,n,s){if(1===t){const t=n(e[0]);u(t,s)}else{R[0]=1/0,R[1]=1/0,R[2]=1/0,F[0]=-1/0,F[1]=-1/0,F[2]=-1/0;for(let s=0;s<t;s++){const t=n(e[s]);E(t[3])&&(r=t,(i=R)[0]=Math.min(i[0],r[0]-r[3]),i[1]=Math.min(i[1],r[1]-r[3]),i[2]=Math.min(i[2],r[2]-r[3]),j(F,t))}h(s,R,F,.5),s[3]=Math.max(F[0]-R[0],F[1]-R[1],F[2]-R[2])/2}var i,r}function N(e,t){let n,s=1/0;for(let i=0;i<8;++i){const r=T(e,t,z[i]);r<s&&(s=r,n=z[i])}return n}function T(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function E(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}O._pool=new t(O),function(e){var t;(t=e.DepthOrder||(e.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(g||(g={}));const M=[d(-1,-1,-1),d(1,-1,-1),d(-1,1,-1),d(1,1,-1),d(-1,-1,1),d(1,-1,1),d(-1,1,1),d(1,1,1)],z=[d(-1,-1,-1),d(-1,-1,1),d(-1,1,-1),d(-1,1,1),d(1,-1,-1),d(1,-1,1),d(1,1,-1),d(1,1,1)],A=Math.sqrt(3),D=[null],v=p(),B=a(),R=a(),F=a(),y=new n,w=p(),q=p(),C=p(),I=p(),P=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],k=new n,L=[0,0,0,0,0,0,0,0],K=g;export{K as O};
