/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{g as t}from"../geometry/SpatialReference.js";import{i as o}from"./maybe.js";import{T as e}from"./TileKey2.js";import{O as l}from"./ArrayPool.js";function s(t,o){return[t,o]}function r(t,o,e){return t[0]=o,t[1]=e,t}const i=new e("0/0/0/0");class n{constructor(t,o,e,l,s,r,i,n,a,h,c,u){this.level=t,this.resolution=o,this.scale=e,this.origin=l,this.first=s,this.last=r,this.size=i,this.norm=n,this.worldStart=a,this.worldEnd=h,this.worldSize=c,this.wrap=u}static create(e,l,i=null){const a=t(e.spatialReference),h=l.origin||s(e.origin.x,e.origin.y),c=s(e.size[0]*l.resolution,e.size[1]*l.resolution),u=s(-1/0,-1/0),f=s(1/0,1/0),m=s(1/0,1/0);o(i)&&(r(u,Math.max(0,Math.floor((i.xmin-h[0])/c[0])),Math.max(0,Math.floor((h[1]-i.ymax)/c[1]))),r(f,Math.max(0,Math.floor((i.xmax-h[0])/c[0])),Math.max(0,Math.floor((h[1]-i.ymin)/c[1]))),r(m,f[0]-u[0]+1,f[1]-u[1]+1));const{cols:g,rows:d}=l;let w,y,M,p;return!i&&g&&d&&(r(u,g[0],d[0]),r(f,g[1],d[1]),r(m,g[1]-g[0]+1,d[1]-d[0]+1)),e.isWrappable?(w=s(Math.ceil(Math.round((a.valid[1]-a.valid[0])/l.resolution)/e.size[0]),m[1]),y=s(Math.floor((a.origin[0]-h[0])/c[0]),u[1]),M=s(w[0]+y[0]-1,f[1]),p=!0):(y=u,M=f,w=m,p=!1),new n(l.level,l.resolution,l.scale,h,u,f,m,c,y,M,w,p)}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,e=!1){i.set(o);const l=e?i.col:this.denormalizeCol(i.col,i.world),s=i.row;return function(t,o,e,l,s){t[0]=o,t[1]=e,t[2]=l,t[3]=s}(t,this.getXForColumn(l),this.getYForRow(s+1),this.getXForColumn(l+1),this.getYForRow(s)),t}getTileCoords(t,o,e=!1){i.set(o);const l=e?i.col:this.denormalizeCol(i.col,i.world);return Array.isArray(t)?r(t,this.getXForColumn(l),this.getYForRow(i.row)):(t.x=this.getXForColumn(l),t.y=this.getYForRow(i.row)),t}}class a{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:e,lodInfo:l}=this,{level:s}=l;if(0!==e.length)for(const{row:r,colFrom:i,colTo:n}of e)for(let e=i;e<=n;e++)t.call(o,s,r,l.normalizeCol(e),l.getWorldForColumn(e))}}a.pool=new l(a);class h{constructor(t,o,e){this.row=t,this.colFrom=o,this.colTo=e}}const c=new e("0/0/0/0");class u{constructor(t,o,e,l,s,r,i,n){this.x=t,this.ymin=o,this.ymax=e,this.invM=l,this.leftAdjust=s,this.rightAdjust=r,this.leftBound=i,this.rightBound=n}static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[e,l]=t,[s,r]=o,i=s-e,n=r-l,a=0!==n?i/n:0,h=(Math.ceil(l)-l)*a,c=(Math.floor(l)-l)*a;return new u(e,Math.floor(l),Math.ceil(r),a,i<0?h:c,i<0?c:h,i<0?s:e,i<0?e:s)}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const f=[[0,0],[0,0],[0,0],[0,0]];class m{constructor(t,o=null){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._infoByScale={},this._infoByLevel={};const e=t.lods.slice();e.sort(((t,o)=>o.scale-t.scale));const l=this._lodInfos=e.map((e=>n.create(t,e,o)));e.forEach(((t,o)=>{this._infoByLevel[t.level]=l[o],this._infoByScale[t.scale]=l[o],this.scales[o]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,o,e=!1){c.set(o);const l=this._infoByLevel[c.level];return l?l.getTileBounds(t,c,e):t}getTileCoords(t,o,e=!1){c.set(o);const l=this._infoByLevel[c.level];return l?l.getTileCoords(t,c,e):t}getTileCoverage(t,o=192,e="closest"){const l="closest"===e?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),s=a.pool.acquire(l),r=this._wrap;let i,n,c,m=1/0,g=-1/0;const d=s.spans;f[0][0]=f[0][1]=f[1][1]=f[3][0]=-o,f[1][0]=f[2][0]=t.size[0]+o,f[2][1]=f[3][1]=t.size[1]+o;for(const o of f)t.toMap(o,o),o[0]=l.getColumnForX(o[0]),o[1]=l.getRowForY(o[1]);const w=[];let y=3;for(let t=0;t<4;t++){if(f[t][1]===f[y][1]){y=t;continue}const o=u.create(f[t],f[y]);m=Math.min(o.ymin,m),g=Math.max(o.ymax,g),void 0===w[o.ymin]&&(w[o.ymin]=[]),w[o.ymin].push(o),y=t}if(null==m||null==g||g-m>100)return null;let M=[];for(i=m;i<g;){null!=w[i]&&(M=M.concat(w[i])),n=1/0,c=-1/0;for(let t=M.length-1;t>=0;t--){const o=M[t];n=Math.min(n,o.getLeftCol()),c=Math.max(c,o.getRightCol())}if(n=Math.floor(n),c=Math.floor(c),i>=l.first[1]&&i<=l.last[1])if(r)if(l.size[0]<l.worldSize[0]){const t=Math.floor(c/l.worldSize[0]);for(let o=Math.floor(n/l.worldSize[0]);o<=t;o++)d.push(new h(i,Math.max(l.getFirstColumnForWorld(o),n),Math.min(l.getLastColumnForWorld(o),c)))}else d.push(new h(i,n,c));else n>l.last[0]||c<l.first[0]||(n=Math.max(n,l.first[0]),c=Math.min(c,l.last[0]),d.push(new h(i,n,c)));i+=1;for(let t=M.length-1;t>=0;t--){const o=M[t];o.ymax>=i?o.incrRow():M.splice(t,1)}}return s}getTileParentId(t){c.set(t);const o=this._infoByLevel[c.level],e=this._lodInfos.indexOf(o)-1;return e<0?null:(this._getTileIdAtLOD(c,this._lodInfos[e],c),c.id)}getTileResolution(t){const o=this._infoByLevel["object"==typeof t?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){c.set(o);const e=this._infoByLevel[c.level],l=t.lodInfo;if(l.resolution>e.resolution){this._getTileIdAtLOD(c,l,c);const o=l.denormalizeCol(c.col,c.world);for(const e of t.spans)if(e.row===c.row&&e.colFrom<=o&&e.colTo>=o)return!0}if(l.resolution<e.resolution){const[o,s,r,i]=t.spans.reduce(((t,o)=>(t[0]=Math.min(t[0],o.row),t[1]=Math.max(t[1],o.row),t[2]=Math.min(t[2],o.colFrom),t[3]=Math.max(t[3],o.colTo),t)),[1/0,-1/0,1/0,-1/0]),n=e.denormalizeCol(c.col,c.world),a=l.getColumnForX(e.getXForColumn(n)),h=l.getRowForY(e.getYForRow(c.row)),u=l.getColumnForX(e.getXForColumn(n+1))-1,f=l.getRowForY(e.getYForRow(c.row+1))-1;return!(a>i||u<r||h>s||f<o)}const s=l.denormalizeCol(c.col,c.world);return t.spans.some((t=>t.row===c.row&&t.colFrom<=s&&t.colTo>=s))}normalizeBounds(o,e,l){if(o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=e[3],this._wrap){const e=t(this.tileInfo.spatialReference),s=-l*(e.valid[1]-e.valid[0]);o[0]+=s,o[2]+=s}return o}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let e=1;e<o.length-1;e++)if(t>o[e]+1e-6)return this._infoByScale[o[e-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce(((o,e)=>Math.abs(e-t)<Math.abs(o-t)?e:o),o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=o.length-1;e>=0;e--)if(t<o[e])return e===o.length-1?this._infoByScale[o[o.length-1]].level:this._infoByScale[o[e]].level+(o[e]-t)/(o[e]-o[e+1]);return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,e){const l=this._infoByLevel[e.level];return t.set(e),o.resolution<l.resolution?null:(o.resolution===l.resolution||(t.level=o.level,t.col=Math.floor(e.col*l.resolution/o.resolution+.01),t.row=Math.floor(e.row*l.resolution/o.resolution+.01)),t)}}export{m as T,a};
