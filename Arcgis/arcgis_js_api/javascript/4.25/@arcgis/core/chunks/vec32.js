/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";const t=e.getLogger("esri.views.3d.support.buffer.math");function f(e,f,r){if(e.count!==f.count)return void t.error("source and destination buffers need to have the same number of elements");const n=e.count,o=r[0],u=r[1],d=r[2],s=r[4],c=r[5],i=r[6],p=r[8],y=r[9],B=r[10],a=r[12],m=r[13],S=r[14],l=e.typedBuffer,h=e.typedBufferStride,b=f.typedBuffer,x=f.typedBufferStride;for(let e=0;e<n;e++){const t=e*h,f=e*x,r=b[f],n=b[f+1],g=b[f+2];l[t]=o*r+s*n+p*g+a,l[t+1]=u*r+c*n+y*g+m,l[t+2]=d*r+i*n+B*g+S}}function r(e,f,r){if(e.count!==f.count)return void t.error("source and destination buffers need to have the same number of elements");const n=e.count,o=r[0],u=r[1],d=r[2],s=r[3],c=r[4],i=r[5],p=r[6],y=r[7],B=r[8],a=e.typedBuffer,m=e.typedBufferStride,S=f.typedBuffer,l=f.typedBufferStride;for(let e=0;e<n;e++){const t=e*m,f=e*l,r=S[f],n=S[f+1],h=S[f+2];a[t]=o*r+s*n+p*h,a[t+1]=u*r+c*n+y*h,a[t+2]=d*r+i*n+B*h}}function n(e,t,f){const r=Math.min(e.count,t.count),n=e.typedBuffer,o=e.typedBufferStride,u=t.typedBuffer,d=t.typedBufferStride;for(let e=0;e<r;e++){const t=e*o,r=e*d;n[t]=f*u[r],n[t+1]=f*u[r+1],n[t+2]=f*u[r+2]}}function o(e,t){const f=Math.min(e.count,t.count),r=e.typedBuffer,n=e.typedBufferStride,o=t.typedBuffer,u=t.typedBufferStride;for(let e=0;e<f;e++){const t=e*n,f=e*u,d=o[f],s=o[f+1],c=o[f+2],i=d*d+s*s+c*c;if(i>0){const e=1/Math.sqrt(i);r[t]=e*d,r[t+1]=e*s,r[t+2]=e*c}}}function u(e,t,f){const r=Math.min(e.count,t.count),n=e.typedBuffer,o=e.typedBufferStride,u=t.typedBuffer,d=t.typedBufferStride;for(let e=0;e<r;e++){const t=e*o,r=e*d;n[t]=u[r]>>f,n[t+1]=u[r+1]>>f,n[t+2]=u[r+2]>>f}}function d(e,t,f){const r=e.typedBuffer,n=e.typedBufferStride,o=t.typedBuffer,u=t.typedBufferStride,d=f?f.count:t.count;let s=(f&&f.dstIndex?f.dstIndex:0)*n,c=(f&&f.srcIndex?f.srcIndex:0)*u;for(let e=0;e<d;++e)r[s]=o[c],r[s+1]=o[c+1],r[s+2]=o[c+2],s+=n,c+=u}function s(e,t,f,r,n){const o=e.typedBuffer,u=e.typedBufferStride,d=n?.count??e.count;let s=(n?.dstIndex??0)*u;for(let e=0;e<d;++e)o[s]=t,o[s+1]=f,o[s+2]=r,s+=u}export{r as a,u as b,d as c,s as f,t as m,o as n,n as s,f as t};
