/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{clone as e,P as t,i as s}from"../core/lang.js";import i from"../core/Error.js";import{r,d as a,a as n,i as o}from"./maybe.js";import{M as u,a as c}from"./MemCache.js";import{e as h}from"./unitUtils.js";import{c as l,p as f,N as m,a as d}from"./aaBoundingBox.js";import{r as p,c as y}from"./aaBoundingRect.js";import{c as g}from"./extentUtils.js";import{fromJSON as x,isExtent as _,isPolygon as S}from"../geometry/support/jsonUtils.js";import{normalizeCentralMeridian as w}from"../geometry/support/normalizeUtils.js";import{e as F,j as Q}from"../geometry/SpatialReference.js";import{b as R}from"./featureConversionUtils.js";import{Q as I,S as j,g as E,v as b,a as A,b as T,h as k}from"./QueryEngineResult.js";import{p as C,c as B,a as q}from"./projectionSupport.js";import{q as v}from"./QueryEngineCapabilities.js";import{g as z,a as O,b as G,c as M,d as P}from"./timeSupport.js";import{c as N,Q as U,n as Z,g as D}from"./utils21.js";import H from"../layers/support/FieldsIndex.js";import{l as L}from"./arcadeOnDemand.js";import{n as J}from"./Scheduler.js";const V="feature-store:unsupported-query",W=new u(2e6);let $=0;class K{constructor(e){this.capabilities={query:v},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new c($+++"$$",W)),this.fieldsIndex=new H(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=r(this._frameTask),this.clearCache(),a(this._geometryQueryCache),this._changeHandle=r(this._changeHandle),a(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return n(e)?null:{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:N(this.spatialReference)}}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=z(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache?.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(t){if(t!==U)throw t;return new I([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(e){if(e!==U)throw e;return 0}}async executeQueryForExtent(e,t){const s=e.outSR;try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=i.size;if(!r)return{count:0,extent:null};f(Y,m),this.featureStore.forEachBounds(i.items,(e=>d(Y,e)),X);const a={xmin:Y[0],ymin:Y[1],xmax:Y[3],ymax:Y[4],spatialReference:N(this.spatialReference)};this.hasZ&&isFinite(Y[2])&&isFinite(Y[5])&&(a.zmin=Y[2],a.zmax=Y[5]);const n=C(a,i.spatialReference,s);if(n.spatialReference=N(s||this.spatialReference),n.xmax-n.xmin==0){const e=h(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin==0){const e=h(n.spatialReference);n.ymin-=e,n.ymax+=e}if(this.hasZ&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin==0){const e=h(n.spatialReference);n.zmin-=e,n.zmax+=e}return{count:r,extent:n}}catch(e){if(e===U)return{count:0,extent:null};throw e}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),i=s.items,r=new Set;return await this._reschedule((()=>{for(const e of i)r.add(s.featureAdapter.getObjectId(e))}),t),r}catch(e){if(e===U)return new Set;throw e}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:r}=e;if(r===j.NONE)return{candidates:[]};const a=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),o=!F(s.spatialReference,this.spatialReference);o&&await B(s.spatialReference,this.spatialReference);const u="number"==typeof i?i:i.x,c="number"==typeof i?i:i.y,h={xmin:s.x-u,xmax:s.x+u,ymin:s.y-c,ymax:s.y+c,spatialReference:s.spatialReference},l=o?C(h,this.spatialReference):h;if(!l)return{candidates:[]};const f=(await w(x(s),null,{signal:t}))[0],m=(await w(x(l),null,{signal:t}))[0];if(n(f)||n(m))return{candidates:[]};const d=new I(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),a,this);await this._reschedule((()=>this._executeObjectIdsQuery(d)),t),await this._reschedule((()=>this._executeTimeQuery(d)),t),await this._reschedule((()=>this._executeAttributesQuery(d)),t);const p=f.toJSON(),y=o?C(p,this.spatialReference):p,g=o?Math.max(l.xmax-l.xmin,l.ymax-l.ymin)/2:i;return d.createSnappingResponse({...e,point:y,distance:g},s.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new i(V,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const s=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(s)),t),s.createQueryResponse()}catch(t){if(t!==U)throw t;return new I([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,field2:r,field3:a,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:i,field2:r,field3:a,valueExpression:n},s)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:a},s)).createHistogramResponse(t)}async _schedule(e,t){return o(this._frameTask)?this._frameTask.schedule(e,t):e(J)}async _reschedule(e,t){return o(this._frameTask)?this._frameTask.reschedule(e,t):e(J)}_getAll(e){return n(this._allItems)&&(this._allItems=this.featureStore.toArray()),new I(this._allItems,e,this)}async _executeQuery(t,s,i){t=e(t),t=await this._schedule((()=>Z(t,this.definitionExpression,this.spatialReference)),i),t=await this._reschedule((()=>this._checkQuerySupport(t)),i),t={...t,...s};const r=await this._reschedule((()=>this._executeSceneFilterQuery(t,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(t,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(n(e.sceneFilter))return null;const{outSR:s,returnGeometry:i,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,o=e.sceneFilter.geometry,u=n(a)||F(a,o.spatialReference)?o:C(o,a);if(!u)return null;const c=i||r,h=Q(s)&&!F(this.spatialReference,s)&&c?async e=>this._project(e,s):e=>e,l=this.featureAdapter,f=this._searchFeatures(this._getQueryBBoxes(u));if("disjoint"===e.sceneFilter.spatialRelationship){if(!f.length)return null;const s=new Set;for(const e of f)s.add(l.getObjectId(e));const i=await this._reschedule((()=>this.featureStore.toArray()),t);return h(await this._reschedule((async()=>{const r=await O("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(i,(e=>!s.has(l.getObjectId(e))||r(l.getGeometry(e))),t);return new I(a,e,this)}),t))}if(!f.length)return new I([],e,this);if(this._canExecuteSinglePass(u,e))return h(new I(f,e,this));const m=await O("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),d=await this._runSpatialFilter(f,(e=>m(l.getGeometry(e))),t);return h(new I(d,e,this))}async _executeGeometryQuery(e,i,r){if(o(i)&&0===i.items.length)return i;e=o(i)?i.query:e;const{geometry:a,outSR:u,spatialRel:c,returnGeometry:h,returnCentroid:l}=e,f=this.featureStore.featureSpatialReference,m=!a||n(f)||F(f,a.spatialReference)?a:C(a,f),d=h||l,p=Q(u)&&!F(this.spatialReference,u),y=this._geometryQueryCache&&n(i)?p&&d?JSON.stringify({originalFilterGeometry:a,spatialRelationship:c,outSpatialReference:u}):JSON.stringify({originalFilterGeometry:a,spatialRelationship:c}):null,g=y?this._geometryQueryCache.get(y):null;if(o(g))return new I(g,e,this);const x=async e=>(p&&d&&await this._project(e,u),y&&this._geometryQueryCache.put(y,e.items,e.items.length+1),e);if(!m)return x(o(i)?i:this._getAll(e));const _=this.featureAdapter;let S=this._searchFeatures(this._getQueryBBoxes(a));if("esriSpatialRelDisjoint"===c){if(!S.length)return x(o(i)?i:this._getAll(e));const t=new Set;for(const e of S)t.add(_.getObjectId(e));const s=o(i)?i.items:await this._reschedule((()=>this.featureStore.toArray()),r);return x(await this._reschedule((async()=>{const i=await O(c,m,this.geometryType,this.hasZ,this.hasM),a=await this._runSpatialFilter(s,(e=>!t.has(_.getObjectId(e))||i(_.getGeometry(e))),r);return new I(a,e,this)}),r))}if(o(i)){const e=new t;S=S.filter((t=>s(i.items,t,i.items.length,e)>=0))}if(!S.length){const t=new I([],e,this);return y&&this._geometryQueryCache.put(y,t.items,1),t}if(this._canExecuteSinglePass(m,e))return x(new I(S,e,this));const w=await O(c,m,this.geometryType,this.hasZ,this.hasM),R=await this._runSpatialFilter(S,(e=>w(_.getGeometry(e))),r);return x(new I(R,e,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds||!e.query.aggregateIds.length||n(this.aggregateAdapter))return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)));const s=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(s(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),s=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(s(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=G(this.timeInfo,e.query.timeExtent,this.featureAdapter);n(t)||(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=E(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,s){if(!t)return e;if(n(this._frameTask))return e.filter((e=>t(e)));let i=0;const r=new Array,a=async n=>{for(;i<e.length;){const o=e[i++];t(o)&&(r.push(o),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),s)}};return this._reschedule((e=>a(e)),s).then((()=>r))}_filterLatest(e){const{trackIdField:t,startTimeField:s,endTimeField:i}=this.timeInfo,r=i||s,a=new Map,n=this.featureAdapter.getAttribute;for(const s of e.items){const e=n(s,t),i=n(s,r),o=a.get(e);(!o||i>n(o,r))&&a.set(e,s)}e.items=Array.from(a.values())}_canExecuteSinglePass(e,t){const{spatialRel:s}=t;return M(e)&&("esriSpatialRelEnvelopeIntersects"===s||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===s||"esriSpatialRelContains"===s||"esriSpatialRelWithin"===s))}async _project(e,t){if(!t||F(this.spatialReference,t))return e;const s=this.featureAdapter,i=await q(e.items.map((e=>D(this.geometryType,this.hasZ,this.hasM,s.getGeometry(e)))),this.spatialReference,t);return e.items=i.map(((t,i)=>s.cloneWithGeometry(e.items[i],R(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if(M(e)){if(_(e))return[p(e.xmin,e.ymin,e.xmax,e.ymax)];if(S(e))return e.rings.map((e=>p(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[g(y(),e)]}_searchFeatures(e){for(const t of e)this.featureStore.forEachInBounds(t,(e=>ee.add(e)));const t=Array.from(ee.values());return ee.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new i(V,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t),P(e,this.geometryType,this.spatialReference),B(this.spatialReference,e.outSR)]).then((()=>e))}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await L();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.field2&&t.push(e.field2),e.field3&&t.push(e.field3),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new i(V,"params should have at least a field or valueExpression",{params:e});b(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new i(V,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([P(e,this.geometryType,this.spatialReference),B(this.spatialReference,e.outSR)]).then((()=>e))}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:r,outStatistics:a}=e,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(s&&s.length>0){const e=" asc",t=" desc",i=s.map((s=>{const i=s.toLowerCase();return i.includes(e)?i.split(e)[0]:i.includes(t)?i.split(t)[0]:s})).filter((e=>!n.includes(e)));b(this.fieldsIndex,i,"orderByFields contains missing fields")}if(t&&t.length>0)b(this.fieldsIndex,t,"outFields contains missing fields");else if(r)throw new i(V,"outFields should be specified for returnDistinctValues",{query:e});A(this.fieldsIndex,e.where)}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:r}=e,a=s&&s.length,n=t&&t.length;if(r){if(!a||!n)throw new i(V,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});T(this.fieldsIndex,r,t)}if(n){if(!function(e){return e.every((e=>"exceedslimit"!==e.statisticType))}(t))return;const r=t.map((e=>e.onStatisticField)).filter(Boolean);b(this.fieldsIndex,r,"onStatisticFields contains missing fields"),a&&b(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const s of t){const{onStatisticField:t,statisticType:r}=s;if("percentile_disc"!==r&&"percentile_cont"!==r||!("statisticParameters"in s)){if("count"!==r&&t&&k(t,this.fieldsIndex))throw new i(V,"outStatistics contains non-numeric fields",{definition:s,query:e})}else{const{statisticParameters:t}=s;if(!t)throw new i(V,"statisticParamters should be set for percentile type",{definition:s,query:e})}}}}async _getQueryEngineResultForStats(t,s,i){t=e(t);try{t=await this._schedule((()=>Z(t,this.definitionExpression,this.spatialReference)),i),t=await this._reschedule((()=>this._checkStatisticsSupport(t,s)),i);const e=await this._reschedule((()=>this._executeSceneFilterQuery(t,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(t,e,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}catch(e){if(e!==U)throw e;return new I([],t,this)}}}const X=l(),Y=l(),ee=new Set;export{K as Q};
