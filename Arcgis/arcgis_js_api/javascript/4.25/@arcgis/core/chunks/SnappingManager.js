/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Evented.js";import{HandleOwner as n}from"../core/HandleOwner.js";import{clone as s}from"../core/lang.js";import{i,a as r,u as o}from"./maybe.js";import{eachAlwaysValues as a,throwIfAborted as c,isAborted as d}from"../core/promiseUtils.js";import{sync as h,watch as l,syncAndInitial as p}from"../core/reactiveUtils.js";import{property as u}from"../core/accessorSupport/decorators/property.js";import{s as f}from"./ensureType.js";import{subclass as g}from"../core/accessorSupport/decorators/subclass.js";import{project as y,initializeProjection as v}from"../geometry/projection.js";import{h as S,a as m,c as _}from"./elevationInfoUtils.js";import{o as E,a as w,L as x,b as L,R as P,s as T,c as C,d as H,e as I,f as Z,P as R,I as V}from"./RightAngleSnappingHint.js";import F from"../core/Handles.js";import{b as Y,u as X,e as N,q as A,g as M,m as q,a as k,l as O,d as j}from"./vec2.js";import{d as b,f as G,s as z,v as D,m as U,w as W,k as J,h as Q,J as B,G as K,b as $,l as ee,C as te,o as ne,c as se,a as ie}from"./vec3.js";import{S as re}from"./QueryEngineResult.js";import{d as oe,a as ae}from"./vec2f64.js";import{d as ce}from"./Settings2.js";import{u as de}from"./mathUtils.js";import{L as he,p as le,a as pe}from"./geometry2dUtils.js";import{v as ue,a as fe}from"./viewUtils.js";import ge from"../core/Accessor.js";import ye from"../core/Collection.js";import ve from"../views/interactive/snapping/SnappingOptions.js";function Se({start:e,end:t,type:n},s,i){const r=[],o=s,a=Y(Fe,t,e),c=Y(Ye,e,o),d=X(a),h=2*N(a,c),l=h*h-4*d*(X(c)-i*i);if(0===l){const t=-h/(2*d);(n===Ze.PLANE||t>=0)&&r.push(A(G(0,0,s[2]),e,a,t))}else if(l>0){const t=Math.sqrt(l),i=(-h+t)/(2*d);(n===Ze.PLANE||i>=0)&&r.push(A(G(0,0,s[2]),e,a,i));const o=(-h-t)/(2*d);(n===Ze.PLANE||o>=0)&&r.push(A(G(0,0,s[2]),e,a,o))}return r}function me(e,t){const n=e.start,s=e.end,i=Y(Fe,s,n),r=z(Ye,-i[1],i[0],0),o=t.start,a=t.end,c=D(Xe,a,o),d=U(c,r),h=z(Ne,n[0],n[1],0),l=D(Ae,h,o),p=U(l,r);if(Math.abs(d)<Ve)return Math.abs(p),[];const u=W(Me,o,c,p/d);if(t.type===he.RAY){const e=D(qe,u,o);if(U(e,c)<-Ve)return[]}if(e.type===Ze.HALF_PLANE){const e=M(qe,u,n);if(N(e,i)<-Ve)return[]}return[J(u)]}function _e(e,t){return Ce(Ie(ke,t[2],e),t)}function Ee(e,t){const n=Te(Ie(ke,0,e),Ie(Oe,0,t)),s=[];for(const e of n)s.push(oe(e));return s}function we(e,t){return xe(e,Ie(ke,e[2],t))}function xe(e,{start:t,end:n,type:s}){const i=D(Fe,e,t),r=D(Ye,n,t),o=U(i,r)/U(r,r);return W(b(),t,r,s===he.RAY?Math.max(o,0):o)}function Le({start:e,end:t,type:n},s){const i=D(Fe,s,e),r=D(Ye,t,e);if(n===he.RAY&&U(r,i)<-Ve)return te(e,s);const o=Q(Xe,r,i);return ne(o)/ne(r)}function Pe({start:e,end:t,type:n},s,i){const r=[];if(de(e[2],s[2],Ve)&&de(t[2],s[2],Ve)){const o=e,a=s,c=Y(Fe,t,o),d=Y(Ye,o,a),h=X(c),l=2*N(c,d),p=l*l-4*h*(X(d)-i*i);if(0===p){const e=-l/(2*h);(n===he.LINE||e>=0)&&r.push(A(G(0,0,s[2]),o,c,e))}else if(p>0){const e=Math.sqrt(p),t=(-l+e)/(2*h);(n===he.LINE||t>=0)&&r.push(A(G(0,0,s[2]),o,c,t));const i=(-l-e)/(2*h);(n===he.LINE||i>=0)&&r.push(A(G(0,0,s[2]),o,c,i))}}else{const o=D(Fe,t,e);if(de(o[2],0,Ve))return r;const a=(s[2]-e[2])/o[2],c=W(Ye,e,o,a);if(n===he.RAY){const t=D(Xe,c,e);if(U(o,t)<-Ve)return r}for(const e of He(s,i,c))r.push(e)}return r}function Te(e,t){const n=e.start,s=e.end,i=t.start,r=t.end,o=D(Fe,s,n),a=D(Ye,r,i),c=D(Xe,i,n),d=Q(Ne,o,a),h=U(c,d);if(!de(h,0,Ve))return[];const l=B(d);if(de(l,0,Ve))return[];const p=Q(Ae,c,a),u=U(p,d)/l,f=W(Me,n,o,u);if(e.type===he.RAY){const e=D(qe,f,n);if(U(o,e)<-Ve)return[]}if(t.type===he.RAY){const e=D(qe,f,i);if(U(a,e)<-Ve)return[]}return[J(f)]}function Ce({start:e,end:t,type:n},s){const i=D(Fe,s,e),r=D(Ye,t,e),o=Q(Xe,r,i);if(B(o)/B(r)<Ve)switch(n){case he.LINE:return[J(s)];case he.RAY:return U(r,i)<-Ve?[]:[J(s)]}return[]}function He(e,t,n){return de(e[2],n[2],Ve)&&de(K(n,e),t*t,Ve)?[J(n)]:[]}function Ie(e,t,{start:n,end:s,type:i}){return z(e.start,n[0],n[1],t),z(e.end,s[0],s[1],t),e.type=Re[i],e}var Ze;!function(e){e[e.PLANE=0]="PLANE",e[e.HALF_PLANE=1]="HALF_PLANE"}(Ze||(Ze={}));const Re={[Ze.PLANE]:he.LINE,[Ze.HALF_PLANE]:he.RAY},Ve=1e-6,Fe=b(),Ye=b(),Xe=b(),Ne=b(),Ae=b(),Me=b(),qe=b(),ke={start:b(),end:b(),type:he.LINE},Oe={start:b(),end:b(),type:he.LINE};class je{constructor(e){this.coordinateHelper=e}intersect(e){return function(e,t){let n=[];if(tt(e)){const{pointXYZ:s}=e;nt(t)?n=Ce(t.lineLike,s):st(t)?n=He(t.centerXYZ,t.radius,s):it(t)?n=_e(t.planeLike,s):rt(t)&&(n=et(t,e))}else if(nt(e)){const{lineLike:s}=e;tt(t)?n=Ce(s,t.pointXYZ):nt(t)?n=Te(s,t.lineLike):st(t)?n=Pe(s,t.centerXYZ,t.radius):it(t)?n=me(t.planeLike,s):rt(t)&&(n=et(t,e))}else if(st(e)){const{centerXYZ:s,radius:i}=e;nt(t)?n=Pe(t.lineLike,s,i):tt(t)?n=He(s,i,t.pointXYZ):it(t)?n=Se(t.planeLike,s,i):rt(t)&&(n=et(t,e))}else if(it(e)){const{planeLike:s,coordinateHelper:i}=e;if(it(t))return Ee(s,t.planeLike).map((n=>new Ue(i,i.fromXYZ(n),e,t)));tt(t)?n=_e(s,t.pointXYZ):nt(t)?n=me(s,t.lineLike):st(t)?n=Se(s,t.centerXYZ,t.radius):rt(t)&&(n=et(t,e))}else rt(e)&&(n=et(e,t));return function(e,t,n){const s=t.coordinateHelper;return e.map((e=>new De(s,s.fromXYZ(e),t,n)))}(n,e,t)}(this,e)}}class be extends je{constructor(e,t){super(e),this.point=t,this.pointXYZ=e.toXYZ(t)}equals(e){return tt(e)&&E(this.point,e.point)}check(e){const t=this.coordinateHelper.toXYZ(e,ot);return K(t,this.pointXYZ)<ce.pointThreshold}closestTo(){return this.coordinateHelper.clone(this.point)}}class Ge extends je{constructor(e,t,n,s){super(e),this.start=t,this.end=n,this.type=s,this.startXYZ=e.toXYZ(t),this.endXYZ=e.toXYZ(n),this.lineLike={start:this.startXYZ,end:this.endXYZ,type:this.type}}equals(e){return nt(e)&&this.type===e.type&&E(this.start,e.start)&&E(this.end,e.end)}check(e){const t=this.coordinateHelper.toXYZ(e,ot);return Le(this.lineLike,t)<ce.pointOnLineThreshold}closestTo(e){const t=this.coordinateHelper,n=xe(t.toXYZ(e,ot),this.lineLike);return t.fromXYZ(n)}}class ze extends Ge{constructor(e,t,n){super(e,t,n,he.LINE)}}class De extends je{constructor(e,t,n,s){super(e),this.intersection=t,this.first=n,this.second=s}equals(e){return e instanceof De&&this.first.equals(e.first)&&this.second.equals(e.second)}check(){return!1}closestTo(){return this.coordinateHelper.clone(this.intersection)}}class Ue extends je{constructor(e,t,n,s){super(e),this.basePoint=t,this.first=n,this.second=s}equals(e){return e instanceof Ue&&this.first.equals(e.first)&&this.second.equals(e.second)}check(){return!1}closestTo(e){const t=this.basePoint,n=this.coordinateHelper,s=n.toXYZ(e,ot),i=z(at,t[0],t[1],s[2]);return n.fromXYZ(i)}}class We extends je{constructor(e,t,n){super(e),this.center=t,this.radius=n,this.centerXYZ=e.toXYZ(t)}equals(e){return st(e)&&this.center[0]===e.center[0]&&this.center[1]===e.center[1]&&this.radius===e.radius}check(){return!1}closestTo(e){const t=this.coordinateHelper,n=function(e,t,n){const s=z(Fe,e[0],e[1],t[2]),i=$(Ye,s,t),r=n/ee(i);return W(b(),t,i,r)}(t.toXYZ(e,ot),this.centerXYZ,this.radius);return n[2]=t.getZ(e,this.centerXYZ[2]),t.fromXYZ(n)}}class Je extends je{constructor(e,t,n,s){super(e),this.start=t,this.end=n,this.type=s,this.planeLike={start:t,end:n,type:s}}equals(e){return it(e)&&this.type===e.type&&E(this.start,e.start)&&E(this.end,e.end)}check(e){return function(e,t){return Le(Ie(ke,e[2],t),e)}(this.coordinateHelper.toXYZ(e,ot),this.planeLike)<ce.pointOnLineThreshold}closestTo(e){const t=this.coordinateHelper,n=we(t.toXYZ(e,ot),this.planeLike);return t.fromXYZ(n)}closestEndTo(e){const{start:t,end:n}=this;return Math.sign(N(Y(ct,n,t),Y(dt,e,t)))>0?n:t}}class Qe extends Je{constructor(e,t,n){super(e,t,n,Ze.HALF_PLANE)}}class Be extends Je{constructor(e,t,n){super(e,t,n,Ze.PLANE)}}class Ke extends je{constructor(e,t,n,s){super(e),this.start=t,this.end=n,this.getZ=s,this.planeLike={start:t,end:n,type:Ze.HALF_PLANE}}equals(e){return rt(e)&&E(this.start,e.start)&&E(this.end,e.end)&&this.getZ===e.getZ}check(e){const t=this.coordinateHelper.toXYZ(e,ot),n=$e(this,t);return K(t,n)<ce.pointThreshold}closestTo(e){const t=this.coordinateHelper,n=$e(this,t.toXYZ(e,ot));return t.fromXYZ(n)}addIfOnTheGround(e,t){for(const n of t){const t=this.getZ(n[0],n[1],n[2]);i(t)&&Math.abs(n[2]-t)<Ve&&(n[2]=t,e.push(n))}}}function $e(e,t){const n=we(t,e.planeLike),s=e.getZ(t[0],t[1],t[2]);return i(s)&&(n[2]=s),n}function et(e,t){const{planeLike:n,getZ:s}=e,r=[];if(tt(t))e.addIfOnTheGround(r,_e(n,t.pointXYZ));else if(nt(t))e.addIfOnTheGround(r,me(n,t.lineLike));else if(st(t))e.addIfOnTheGround(r,Se(n,t.centerXYZ,t.radius));else if(it(t)||rt(t))for(const[e,o]of Ee(n,t.planeLike)){const t=s(e,o,0);i(t)&&r.push(G(e,o,t))}return r}function tt(e){return e instanceof be}function nt(e){return e instanceof Ge}function st(e){return e instanceof We}function it(e){return e instanceof Je}function rt(e){return e instanceof Ke}const ot=b(),at=b(),ct=ae(),dt=ae();class ht{constructor(e,t,n,s,i){this.coordinateHelper=e,this.targetPoint=t,this.constraint=n,this.elevationInfo=s,this.domain=i}}class lt extends ht{constructor({coordinateHelper:e,targetPoint:t,objectId:n,constraint:s,elevationInfo:i}){super(e,t,s,i,w.FEATURE),this.objectId=n}}class pt extends lt{constructor(e){super({...e,constraint:new ze(e.coordinateHelper,e.edgeStart,e.edgeEnd)})}get hints(){return[new x(L.REFERENCE,this.constraint.start,this.constraint.end,this.elevationInfo,this.domain)]}}class ut extends ht{constructor({coordinateHelper:e,targetPoint:t,constraint:n,previousVertex:s,otherVertex:i,otherVertexType:r,objectId:o,elevationInfo:a}){super(e,t,n,a,w.SELF),this.previousVertex=s,this.otherVertex=i,this.otherVertexType=r,this.objectId=o}get hints(){const e=this.previousVertex,t=this.otherVertexType===ft.CENTER?this.otherVertex:this.targetPoint,n=this.otherVertexType===ft.CENTER?this.targetPoint:this.otherVertex,s=this.elevationInfo;return[new x(L.TARGET,t,n,s,this.domain),new x(L.REFERENCE,e,t,s,this.domain),new P(this.previousVertex,t,n,s,this.domain)]}}var ft;!function(e){e[e.NEXT=0]="NEXT",e[e.CENTER=1]="CENTER"}(ft||(ft={}));let gt=class extends n{constructor(e){super(e),this.options=null,this._domain=w.FEATURE,this._sourceModules={featureService:{module:null,loader:null},featureCollection:{module:null,loader:null},graphics:{module:null,loader:null},notes:{module:null,loader:null},scene:{module:null,loader:null}}}get updating(){return f(this.snappingSources,(({snappingSource:e})=>e.updating))||this.updatingHandles.updating}get snappingSources(){const e=this._get("snappingSources")||new Map,t=new Map;if(i(this.options)&&i(this.options.featureSources))for(const n of this.options.featureSources.items){const s=n.layer.uid,r=e.get(s);if(r){e.delete(s),t.set(s,r);continue}if(!n.layer.loaded){this.updatingHandles.addPromise(n.layer.load());continue}const o=this._createSourceInfo(n);i(o)&&t.set(s,o)}for(const[,t]of e)t.destroy();return t}initialize(){this.updatingHandles.add((()=>this.snappingSources),(()=>this.notifyChange("updating")),h),i(this.view)&&this.handles.add([this.view.on("layerview-create",(e=>this._updateLayerView(e.layer,e.layerView))),this.view.on("layerview-destroy",(e=>this._updateLayerView(e.layer,null)))])}_updateLayerView(e,t){for(const[,n]of this.snappingSources)n.snappingSource.layerSource.layer===e&&(n.layerView=t)}destroy(){this._set("options",null);for(const[,e]of this.snappingSources)e.destroy()}async fetchCandidates(e,t,n,s){if(!(t&this._domain)||r(this.options)||!this.options.effectiveFeatureEnabled)return[];const o=[],d=this._computeScreeenSizeDistanceParameters(e,n),h={distance:d,point:e,coordinateHelper:n.coordinateHelper,types:this._types};for(const[,{snappingSource:e,layerView:t}]of this.snappingSources)!e.layerSource.enabled||i(t)&&t.suspended||o.push(e.fetchCandidates(h,s).then((t=>t.filter((t=>!this._candidateIsExcluded(e,t,n.excludeFeature))))));const l=(await a(o)).flat();return this._addRightAngleCandidates(l,e,d,n),c(s),T(e,l,n.coordinateHelper),l}_addRightAngleCandidates(e,t,n,s){const r=i(s.vertexHandle)?s.vertexHandle.rightEdge?.rightVertex?.pos:i(s.editGeometryOperations)&&"polygon"===s.editGeometryOperations.data.type?o(s.editGeometryOperations.data.components[0]?.getFirstVertex())?.pos:null,a=i(s.vertexHandle)?s.vertexHandle.leftEdge?.leftVertex?.pos:i(s.editGeometryOperations)?o(s.editGeometryOperations.data.components[0]?.getLastVertex())?.pos:null,{view:c}=this,d=C(r,c,s),h=C(a,c,s),l=e.length;for(let i=0;i<l;i++)this._addRightAngleCandidate(e[i],h,t,n,s,e),this._addRightAngleCandidate(e[i],d,t,n,s,e)}_addRightAngleCandidate(e,t,n,s,i,o){const a=e instanceof pt,c=a&&q(e.constraint.start,e.constraint.end);if(r(t)||!a||c)return;const d=e.constraint.closestTo(t),h=(d[0]-n[0])/s.x,l=(d[1]-n[1])/s.y;if(h*h+l*l<=1){const n=i.coordinateHelper,s=new ut({coordinateHelper:n,targetPoint:d,otherVertex:t,otherVertexType:ft.NEXT,previousVertex:e.constraint.start,constraint:new Qe(n,t,d),objectId:e.objectId,elevationInfo:e.elevationInfo});o.push(s)}}_computeScreeenSizeDistanceParameters(e,t){let n=i(this.options)?this.options.distance*("touch"===t.pointer?this.options.touchSensitivityMultiplier:1):0;return r(this.view)?{x:n,y:n,z:n,distance:n}:"2d"===this.view.type?(n*=this.view.resolution,{x:n,y:n,z:n,distance:n}):this._computeScreenSizeDistanceParameters3D(e,n,this.view,t)}_computeScreenSizeDistanceParameters3D(e,t,n,s){const{coordinateHelper:i,elevationInfo:r}=s,{spatialReference:o}=i,a=i.hasZ()?S:r,c=i.toXYZ(e,St);c[2]=m(n,c,o,a,S),n.renderCoordsHelper.toRenderCoords(c,o,mt);const d=n.state.camera.computeScreenPixelSizeAt(mt),h=d*n.renderCoordsHelper.unitInMeters/n.mapCoordsHelper.unitInMeters,l=t*h,p=ue(c,o,S,n),u=vt(p,c,h,0,0,n,s),f=vt(p,c,0,h,0,n,s),g=vt(p,c,0,0,h,n,s);return{x:0===u?0:l/u,y:0===f?0:l/f,z:0===g?0:l/g,distance:d*t}}get _types(){return re.EDGE|re.VERTEX}_candidateIsExcluded(e,t,n){if(r(n))return!1;const s=this._getCandidateObjectId(t);if(r(s))return!1;const i=e.layerSource.layer;return"graphics"===i.type?n.uid===s:n.sourceLayer===i&&!(!n.attributes||!("objectIdField"in i))&&n.attributes[i.objectIdField]===s}_getCandidateObjectId(e){return e instanceof lt?e.objectId:null}_createSourceInfo(e){const t=this._createFeatureSnappingSourceType(e);if(r(t))return null;if("loading"in t)return this.updatingHandles.addPromise(t.loading.then((()=>{this.destroyed||this.notifyChange("snappingSources")}))),null;const n=i(this.view)?this.view.allLayerViews.find((t=>t.layer===e.layer)):null;return new yt(t.source,n)}_createFeatureSnappingSourceType(e){switch(e.layer.type){case"feature":case"geojson":case"csv":case"oriented-imagery":case"subtype-group":case"wfs":return this._createFeatureSnappingSourceFeatureLayer(e);case"graphics":return this._createFeatureSnappingSourceGraphicsLayer(e);case"map-notes":return this._createFeatureSnappingSourceMapNotesLayer(e);case"scene":case"building-scene":return this._createFeatureSnappingSourceSceneLayer(e)}return null}_createFeatureSnappingSourceSceneLayer(e){const{view:t}=this;if(r(t)||"3d"!==t.type)return null;const n=this._getSourceModule("scene");return i(n.module)?{source:new n.module.SceneLayerSnappingSource({layerSource:e,view:t})}:{loading:n.loader}}_createFeatureSnappingSourceFeatureLayer(e){switch(e.layer.source.type){case"feature-layer":case"oriented-imagery":{const t=this._getSourceModule("featureService");return i(t.module)?{source:new t.module.FeatureServiceSnappingSource({spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}case"memory":case"csv":case"geojson":case"wfs":{if("mesh"===e.layer.geometryType)return null;const t=this._getSourceModule("featureCollection");return i(t.module)?{source:new t.module.FeatureCollectionSnappingSource({layerSource:e,view:this.view})}:{loading:t.loader}}}return null}_createFeatureSnappingSourceGraphicsLayer(e){const t=this._getSourceModule("graphics");return i(t.module)?{source:new t.module.GraphicsSnappingSource({getGraphicsLayers:()=>[e.layer],spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_createFeatureSnappingSourceMapNotesLayer(e){const t=this._getSourceModule("notes");return i(t.module)?{source:new t.module.GraphicsSnappingSource({getGraphicsLayers:()=>i(e.layer.sublayers)?e.layer.sublayers.toArray():[],spatialReference:this.spatialReference,view:this.view,layerSource:e})}:{loading:t.loader}}_getSourceModule(e){const t=this._sourceModules[e];if(r(t.loader)){const n=this._loadSourceModule(e).then((e=>{t.module=e}));return t.loader=n,{module:t.module,loader:n}}return{module:t.module,loader:t.loader}}_loadSourceModule(e){const t=this.updatingHandles;switch(e){case"featureService":return t.addPromise(import("./FeatureServiceSnappingSource.js"));case"featureCollection":return t.addPromise(import("./FeatureCollectionSnappingSource.js"));case"graphics":case"notes":return t.addPromise(import("./GraphicsSnappingSource.js"));case"scene":return t.addPromise(import("./SceneLayerSnappingSource.js"))}return null}};e([u({constructOnly:!0})],gt.prototype,"spatialReference",void 0),e([u({constructOnly:!0})],gt.prototype,"view",void 0),e([u()],gt.prototype,"options",void 0),e([u({readOnly:!0})],gt.prototype,"updating",null),e([u({readOnly:!0})],gt.prototype,"snappingSources",null),gt=e([g("esri.views.interactive.snapping.FeatureSnappingEngine")],gt);class yt{constructor(e,t){this.snappingSource=e,this.layerView=t,this.handles=new F;const n=this.snappingSource.layerSource.layer;if("refresh"in n){const t=n;this.handles.add(t.on("refresh",(()=>e.refresh())))}this.handles.add([l((()=>e.updating),(t=>e.layerSource.updating=t),p),l((()=>e.availability),(t=>e.layerSource.availability=t),p)])}destroy(){this.snappingSource.destroy(),this.handles.destroy()}}function vt(e,t,n,s,i,r,{coordinateHelper:o}){const a=se(_t,t);a[0]+=n,a[1]+=s,a[2]+=i;const c=ue(a,o.spatialReference,S,r);return H(c,e)}const St=b(),mt=b(),_t=b();class Et{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=ce.shortLineThreshold*ce.shortLineThreshold}snap(e,t){return i(t.vertexHandle)?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(e.leftVertex.pos,e.rightVertex.pos,t)}exceedsShortLineThreshold(e,t,{elevationInfo:n,editGeometryOperations:s}){const i=s.data.coordinateHelper;return 0===this.squaredShortLineThreshold||I(fe(t,i,n,this.view),fe(e,i,n,this.view))>this.squaredShortLineThreshold}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,n=e*t;return n*n}}class wt extends ht{constructor({coordinateHelper:e,lineStart:t,lineEnd:n,targetPoint:s,elevationInfo:i}){super(e,s,new Be(e,t,n),i,w.SELF),this._referenceLineHint=new x(L.REFERENCE_EXTENSION,t,n,i,this.domain)}get hints(){return[this._referenceLineHint,new x(L.TARGET,this._lineEndClosestToTarget(),this.targetPoint,this.elevationInfo,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}}class xt extends Et{snapNewVertex(e,t){const n=t.editGeometryOperations.data.components[0],s=n.edges.length,i=[];if(s<1)return i;const r=t.coordinateHelper,o=fe(e,r,S,this.view),{view:a}=this,c=n.edges[s-1];let d=c;do{if(this.edgeExceedsShortLineThreshold(d,t)){const n=Z(d,a,t);this._processCandidateProposal(n.left,n.right,e,o,t,i)}d=d.leftVertex.leftEdge}while(d&&d!==c);return i}snapExistingVertex(e,t){const n=[],s=o(t.vertexHandle),i=s.component;if(i.edges.length<2)return n;const{view:r}=this,{coordinateHelper:a}=t,c=fe(e,a,S,r),d=s.leftEdge,h=s.rightEdge;d&&h&&this.edgeExceedsShortLineThreshold(d,t)&&this.edgeExceedsShortLineThreshold(h,t)&&this._processCandidateProposal(C(d.leftVertex.pos,r,t),C(h.rightVertex.pos,r,t),e,c,t,n);const l=i.edges[0];let p=l;do{if(p!==s.leftEdge&&p!==s.rightEdge&&this.edgeExceedsShortLineThreshold(p,t)){const s=Z(p,r,t);this._processCandidateProposal(s.left,s.right,e,c,t,n)}p=p.rightVertex.rightEdge}while(p&&p!==l);return n}_processCandidateProposal(e,t,n,s,i,r){const{coordinateHelper:o,pointer:a}=i;o.toXYZ(e,Lt),o.toXYZ(t,Pt);const c=xe(o.toXYZ(n,Ct),Tt),d=o.fromXYZ(c);I(s,fe(d,o,S,this.view))<this.squaredProximityThreshold(a)&&r.push(new wt({coordinateHelper:o,lineStart:e,lineEnd:t,targetPoint:d,elevationInfo:o.hasZ()?S:null}))}}const Lt=b(),Pt=b(),Tt={start:Lt,end:Pt,type:he.LINE},Ct=b();class Ht extends ht{constructor({coordinateHelper:e,referenceLine:t,lineStart:n,targetPoint:s,elevationInfo:i}){const r=e.toXYZ(n,It),o=e.toXYZ(t.left,Zt),a=e.toXYZ(t.right,Rt);$(r,ie(r,r,a),o),super(e,s,new Be(e,n,e.fromXYZ(r)),i,w.SELF),this._referenceLines=[{edge:t,fadeLeft:!0,fadeRight:!0}]}get hints(){const e=this.elevationInfo;return[new x(L.TARGET,this.constraint.start,this.targetPoint,e,this.domain),new R(this.constraint.start,this.targetPoint,e,this.domain),...this._referenceLines.map((t=>new x(L.REFERENCE,t.edge.left,t.edge.right,e,this.domain,t.fadeLeft,t.fadeRight)))]}addReferenceLine(e){const t={edge:e,fadeLeft:!0,fadeRight:!0},{coordinateHelper:n}=this;this._referenceLines.forEach((s=>{n.equals(e.right,s.edge.left)&&(s.fadeLeft=!1,t.fadeRight=!1),n.equals(e.right,s.edge.right)&&(s.fadeRight=!1,t.fadeRight=!1),n.equals(e.left,s.edge.right)&&(s.fadeRight=!1,t.fadeLeft=!1),n.equals(e.left,s.edge.left)&&(s.fadeLeft=!1,t.fadeLeft=!1)})),this._referenceLines.push(t)}}const It=b(),Zt=b(),Rt=b();class Vt extends Et{snapNewVertex(e,t){const n=t.editGeometryOperations.data.components[0],s=n.edges.length,i=n.vertices.length,r=[];if(s<2)return r;const{view:o}=this,a=fe(e,t.coordinateHelper,S,o),c=C(n.vertices[i-1].pos,o,t),d=C(n.vertices[0].pos,o,t),h=n.edges[s-1];let l=h;do{if(this.edgeExceedsShortLineThreshold(l,t)){const n=Z(l,o,t);this._checkEdgeForParalleLines(n,c,e,a,t,r),this._checkEdgeForParalleLines(n,d,e,a,t,r)}l=l.leftVertex.leftEdge}while(l&&l!==h);return r}snapExistingVertex(e,t){const n=[],s=o(t.vertexHandle),i=s.component;if(i.edges.length<3)return n;const{view:r}=this,a=fe(e,t.coordinateHelper,S,r),c=s.leftEdge,d=s.rightEdge,h=i.vertices[0],l=C(h.pos,r,t),p=i.vertices.length,u=i.vertices[p-1],f=C(u.pos,r,t),g=i.edges[0];let y=g;do{if(y!==c&&y!==d&&this.edgeExceedsShortLineThreshold(y,t)){const i=Z(y,r,t);c&&this._checkEdgeForParalleLines(i,C(c.leftVertex.pos,r,t),e,a,t,n),d&&this._checkEdgeForParalleLines(i,C(d.rightVertex.pos,r,t),e,a,t,n),s===h?this._checkEdgeForParalleLines(i,f,e,a,t,n):s===u&&this._checkEdgeForParalleLines(i,l,e,a,t,n)}y=y.rightVertex.rightEdge}while(y&&y!==g);return n}_checkEdgeForParalleLines(e,t,n,s,i,r){const o=e.left,a=e.right;if(le(Ft,t,o,a),k(Ft,t)<ce.parallelLineThreshold)return;le(Ft,n,o,a,t);const{coordinateHelper:c,pointer:d}=i,h=c.fromXYZ(Ft,c.getZ(n,0));if(I(s,fe(h,c,S,this.view))<this.squaredProximityThreshold(d)){if(this._parallelToPreviousCandidate(e,r))return;r.push(new Ht({coordinateHelper:c,referenceLine:e,lineStart:t,targetPoint:h,elevationInfo:c.hasZ()?S:null}))}}_parallelToPreviousCandidate(e,t){const n=e.left,s=e.right;for(const i of t)if(le(Ft,s,i.constraint.start,i.constraint.end,n),k(Ft,s)<ce.parallelLineThreshold)return i.addReferenceLine(e),!0;return!1}}const Ft=ae();class Yt extends Et{snapNewVertex(e,t){const n=t.editGeometryOperations.data.components[0],s=n.vertices.length,i=[];if(s<2)return i;const{view:r}=this,o=fe(e,t.coordinateHelper,S,r),a=n.vertices[s-1];if(this.edgeExceedsShortLineThreshold(a.leftEdge,t)){const n=C(a.pos,r,t),s=Z(a.leftEdge,r,t);this._checkForSnappingCandidate(i,s,n,e,s.left,n,t,e,o)}const c=n.vertices[0];if(this.edgeExceedsShortLineThreshold(c.rightEdge,t)){const n=C(c.pos,r,t),s=Z(c.rightEdge,r,t);this._checkForSnappingCandidate(i,s,n,e,s.right,n,t,e,o)}return i}snapExistingVertex(e,t){const n=[],s=o(t.vertexHandle),i=s.component,r=i.vertices.length;if(r<3)return n;const{view:a}=this,c=fe(e,t.coordinateHelper,S,a),d=s.leftEdge,h=s.rightEdge,l=i.vertices[0],p=i.vertices[r-1];if(!d){const s=l.rightEdge.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const i=Z(s,a,t),r=C(l.rightEdge.rightVertex.pos,a,t);this._checkForSnappingCandidate(n,i,r,e,i.right,r,t,e,c)}return n}if(!h){const s=p.leftEdge.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const i=Z(s,a,t),r=C(p.leftEdge.leftVertex.pos,a,t);this._checkForSnappingCandidate(n,i,r,e,i.left,r,t,e,c)}return n}if(d&&d.leftVertex.leftEdge){const s=d.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const i=Z(s,a,t),r=C(d.leftVertex.pos,a,t);this._checkForSnappingCandidate(n,i,r,e,i.left,r,t,e,c)}}if(h&&h.rightVertex.rightEdge){const s=h.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const i=Z(s,a,t),r=C(h.rightVertex.pos,a,t);this._checkForSnappingCandidate(n,i,r,e,i.right,r,t,e,c)}}return n}_checkForSnappingCandidate(e,t,n,s,i,r,o,a,c){const{coordinateHelper:d,pointer:h}=o;Y(Xt,t.right,t.left);const l=z(Mt,Xt[1],-Xt[0],0),p=N(l,Y(Xt,s,n))/X(l),u=d.fromXYZ(A(Xt,r,l,p),d.getZ(a,0));if(I(c,fe(u,d,S,this.view))<this.squaredProximityThreshold(h)){const t=d.toXYZ(r,Nt),n=W(At,t,l,Math.sign(p)),s=d.fromXYZ(n);e.push(new ut({coordinateHelper:d,targetPoint:u,constraint:new Qe(d,r,s),previousVertex:i,otherVertex:r,otherVertexType:ft.CENTER,elevationInfo:d.hasZ()?S:null}))}}}const Xt=ae(),Nt=b(),At=b(),Mt=b();class qt extends ht{constructor({coordinateHelper:e,targetPoint:t,point1:n,point2:s,elevationInfo:i}){super(e,t,new We(e,e.arrayToVector(O(kt,n,s,.5)),.5*j(n,s)),i,w.SELF),this._p1=n,this._p2=s}get hints(){const e=this.elevationInfo;return[new x(L.REFERENCE,this.targetPoint,this._p1,e,this.domain),new x(L.REFERENCE,this.targetPoint,this._p2,e,this.domain),new P(this._p1,this.targetPoint,this._p2,e,this.domain)]}}const kt=ae();class Ot extends Et{snapNewVertex(e,t){const n=t.editGeometryOperations.data.components[0],s=[],i=n.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||i<2)return s;const{view:r}=this,o=n.vertices[0],a=n.vertices[i-1],c=C(o.pos,r,t),d=C(a.pos,r,t);return this._processCandidateProposal(c,d,e,t,s),s}snapExistingVertex(e,t){const n=[],s=o(t.vertexHandle),i=s.component;if(i.edges.length<2)return n;if("polyline"===t.editGeometryOperations.data.type&&(0===s.index||s.index===i.vertices.length-1))return n;const{view:r}=this,a=C(s.leftEdge.leftVertex.pos,r,t),c=C(s.rightEdge.rightVertex.pos,r,t);return this._processCandidateProposal(a,c,e,t,n),n}_processCandidateProposal(e,t,n,s,i){if(!this.exceedsShortLineThreshold(e,t,s))return;const r=O(jt,e,t,.5),o=.5*j(e,t),a=pe(bt,n,r,o),{coordinateHelper:c,pointer:d}=s,h=c.fromXYZ(a,c.getZ(n,0)),l=fe(n,c,S,this.view);I(l,fe(h,c,S,this.view))<this.squaredProximityThreshold(d)&&i.push(new qt({coordinateHelper:c,targetPoint:h,point1:e,point2:t,elevationInfo:c.hasZ()?S:null}))}}const jt=ae(),bt=ae();let Gt=class extends ge{constructor(e){super(e),this.updating=!1,this._snappers=new ye,this._domain=w.SELF}initialize(){this._snappers.push(new Vt(this.view,this.options),new xt(this.view,this.options),new Yt(this.view,this.options),new Ot(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,n){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const s=[];for(const t of this._snappers.items)for(const i of t.snap(e,n))s.push(i);return T(e,s,n.coordinateHelper),s}};function zt(e,t){return[new Gt({view:e,options:t}),new gt({view:e,options:t,spatialReference:e.spatialReference})]}e([u({readOnly:!0})],Gt.prototype,"updating",void 0),e([u({constructOnly:!0})],Gt.prototype,"view",void 0),e([u()],Gt.prototype,"options",null),Gt=e([g("esri.views.interactive.snapping.SelfSnappingEngine")],Gt);class Dt extends ht{constructor(e,t,n,s,i){super(e,t,new De(e,t,n.constraint,s.constraint),i,w.ALL),this.first=n,this.second=s}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new V(this.targetPoint,this.elevationInfo,this.domain)]}}let Ut=class extends(t.EventedMixin(n)){constructor(e){super(e),this.options=new ve,this.snappingEnginesFactory=zt,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=Wt.MAIN}initialize(){this.handles.add([l((()=>{const{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:n,distance:s}=this.options;return{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:n,distance:s}}),(()=>{this.doneSnapping(),this.emit("changed")}),h),l((()=>this.options),(e=>{for(const t of this._engines)t.options=e}),h),l((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:e,snappingEnginesFactory:t})=>this._recreateEngines(e,t)),p)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((e=>e.updating))}_recreateEngines(e,t){if(this._destroyEngines(),!e)return;const{view:n,options:s}=this;this._engines=t(n,s)}_destroyEngines(){for(const e of this._engines)e.destroy();this._engines=[]}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,n=e*t;return n*n}async snap(e){return function(e){return i(e.scenePoint)}(e)?this._snapMultiPoint(e):this._snapSinglePoint(e)}update(e){const{point:t,context:n}=e;this._removeVisualization();const s=this._currentMainCandidate;if(r(s))return t;const o=this._selectUpdateInput(e);if(r(o))return t;const{coordinateHelper:{spatialReference:a}}=n,c=y(this._convertPointElevation(o,n),a);if(r(c))return t;const{view:d}=this,{coordinateHelper:h,elevationInfo:l,visualizer:p}=n,u=[],f=h.pointToVector(c),g=s.constraint.closestTo(f);if(!this._arePointsWithinScreenThreshold(f,g,n))return this._resetSnappingState(),t;s.targetPoint=g,u.push(...s.hints);for(const e of this._currentOtherActiveCandidates)e.targetPoint=g,u.push(...e.hints);i(p)&&this.handles.add(p.draw(u,{coordinateHelper:h,elevationInfo:Qt(n),view:d,selfSnappingZ:n.selfSnappingZ}),Jt);const v=h.vectorToDehydratedPoint(g);return this._convertPointElevation(v,n,S,l)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:e,scenePoint:t}){switch(this._currentSnappedType){case Wt.MAIN:return e;case Wt.SCENE:return t}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=Wt.MAIN}_removeVisualization(){this.handles.remove(Jt)}async _snapSinglePoint({point:e,context:t,signal:n}){const{coordinateHelper:s}=t,{view:i}=this,r=this._convertPointElevation(e,t),o=s.pointToVector(r),a=await this._fetchCandidates(o,w.ALL,t,n);return this._createSnapResult(o,Wt.MAIN,a,i,t,n)}async _snapMultiPoint({point:e,scenePoint:t,context:n,signal:s}){const{view:i}=this,{coordinateHelper:r}=n,{spatialReference:o}=r;await v(t.spatialReference,o);const a=y(this._convertPointElevation(t,n),o),c=r.pointToVector(a),d=await this._fetchCandidates(c,w.FEATURE,n,s);if(d.length>0){const e=await this._fetchCandidates(c,w.SELF,n,s);return this._createSnapResult(c,Wt.SCENE,[...d,...e],i,n,s)}const h=this._convertPointElevation(e,n),l=r.pointToVector(h),p=await this._fetchCandidates(l,w.SELF,n,s);return this._createSnapResult(l,Wt.MAIN,p,i,n,s)}async _fetchCandidates(e,t,n,s){return(await Promise.all(this._engines.map((i=>i.fetchCandidates(e,t,n,s))))).flat()}_createSnapResult(e,t,n,s,r,o){return{get valid(){return!d(o)},apply:()=>{const{elevationInfo:o,coordinateHelper:a}=r,{snappedPoint:c,hints:d}=this._processCandidates(e,t,n,r);return this._removeVisualization(),i(r.visualizer)&&this.handles.add(r.visualizer.draw(d,{coordinateHelper:a,elevationInfo:Qt(r),view:s,selfSnappingZ:r.selfSnappingZ}),Jt),this._convertPointElevation(c,r,S,o)}}}_processCandidates(e,t,n,s){const{coordinateHelper:r}=s;if(n.length<1)return this.doneSnapping(),{snappedPoint:r.vectorToDehydratedPoint(e),hints:[]};this._currentSnappedType!==t&&this._resetSnappingState(),T(e,n,r);const o=this._currentMainCandidate;if(i(o)){const i=this._findOldConstraintInNewCandidates(o,n);if(i>=0){if(!(n[i]instanceof Dt))return this._intersectWithOtherCandidates(i,n,e,t,s);if(this._arePointsWithinScreenThreshold(e,o.targetPoint,s))return this._updateSnappingCandidate(o,t,n,s)}}return this._intersectWithOtherCandidates(0,n,e,t,s)}_findOldConstraintInNewCandidates(e,t){return e instanceof Dt?this._findOldCandidateIndex(t,e.first)>=0&&this._findOldCandidateIndex(t,e.second)>=0?0:-1:this._findOldCandidateIndex(t,e)}_intersectWithOtherCandidates(e,t,n,s,i){const{coordinateHelper:r}=i,o=t[e],a=[];for(let s=0;s<t.length;++s){if(s===e)continue;const i=t[s];for(const e of o.constraint.intersect(i.constraint)){const t=r.fromXYZ(e.closestTo(o.targetPoint),o.targetPoint[2]);a.push([new Dt(r,t,o,i,i.elevationInfo),this._squaredScreenDistance(n,t,r)])}}return a.length>0&&(a.sort(((e,t)=>e[1]-t[1])),a[0][1]<this._squaredPointProximityThreshold(i.pointer))?this._updateSnappingCandidate(a[0][0],s,t,i):this._updateSnappingCandidate(o,s,t,i)}_updateSnappingCandidate(e,t,n,s){this.doneSnapping(),this._currentMainCandidate=e,this._currentSnappedType=t;const i=this._currentMainCandidate.targetPoint,r=[];r.push(...e.hints);for(const t of n){if(e instanceof Dt){if(t.constraint.equals(e.first.constraint)||t.constraint.equals(e.second.constraint))continue}else if(t.constraint.equals(e.constraint))continue;t.constraint.check(i)&&(t.targetPoint=i,this._currentOtherActiveCandidates.push(t),r.push(...t.hints))}return{snappedPoint:s.coordinateHelper.vectorToDehydratedPoint(i),hints:r}}_squaredPointProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}_arePointsWithinScreenThreshold(e,t,n){return this._squaredScreenDistance(e,t,n.coordinateHelper)<this._squaredPointProximityThreshold(n.pointer)}_squaredScreenDistance(e,t,n){return I(this._toScreen(e,n),this._toScreen(t,n))}_toScreen(e,t){return fe(e,t,S,this.view)}_findOldCandidateIndex(e,t){let n=-1;for(let s=0;s<e.length;++s)if(t.constraint.equals(e[s].constraint)){n=s;break}return n}_convertPointElevation(e,t,n=t.elevationInfo,r=S){const{view:o}=this;if(!(i(e)&&t.coordinateHelper.hasZ()&&i(o)&&"3d"===o.type))return e;const a=s(e);return a.z=_(o,a,n,r),a}get test(){return{visualizationsActive:this.handles.has(Jt),engines:this._engines}}};var Wt;e([u({constructOnly:!0})],Ut.prototype,"view",void 0),e([u()],Ut.prototype,"options",void 0),e([u({readOnly:!0})],Ut.prototype,"updating",null),e([u()],Ut.prototype,"snappingEnginesFactory",void 0),e([u()],Ut.prototype,"_engines",void 0),e([u()],Ut.prototype,"_squaredMouseProximityTreshold",null),e([u()],Ut.prototype,"_squaredTouchProximityThreshold",null),Ut=e([g("esri.views.interactive.snapping.SnappingManager")],Ut),function(e){e[e.MAIN=0]="MAIN",e[e.SCENE=1]="SCENE"}(Wt||(Wt={}));const Jt="visualization-handle";function Qt({coordinateHelper:e,elevationInfo:t}){return e.hasZ()?S:t}export{Ke as D,pt as E,gt as F,be as P,Ut as S,lt as a};
