/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as s}from"../chunks/tslib.es6.js";import e from"./Accessor.js";import{b as r}from"../chunks/maybe.js";import{createDeferred as i,createAbortError as t,isAbortError as o}from"./promiseUtils.js";import{subclass as l}from"./accessorSupport/decorators/subclass.js";import"./Handles.js";import"../chunks/get.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"./lang.js";import"../chunks/metadata.js";import"../chunks/object.js";import"../chunks/Logger.js";import"../config.js";import"../chunks/string.js";import"../chunks/ArrayPool.js";import"../chunks/tracking.js";import"./accessorSupport/decorators/property.js";import"../chunks/ensureType.js";import"./Error.js";import"../chunks/watch.js";import"./scheduling.js";import"../chunks/nextTick.js";var n;!function(s){s[s.PENDING=0]="PENDING",s[s.RESOLVED=1]="RESOLVED",s[s.REJECTED=2]="REJECTED"}(n||(n={}));class h{constructor(s){this.instance=s,this._resolver=i(),this._status=n.PENDING,this._resolvingPromises=[],this._resolver.promise.then((()=>{this._status=n.RESOLVED,this._cleanUp()}),(()=>{this._status=n.REJECTED,this._cleanUp()}))}addResolvingPromise(s){this._resolvingPromises.push(s),this._tryResolve()}isResolved(){return this._status===n.RESOLVED}isRejected(){return this._status===n.REJECTED}isFulfilled(){return this._status!==n.PENDING}abort(){this._resolver.reject(t())}when(s,e){return this._resolver.promise.then(s,e)}_cleanUp(){this._allPromise=this._resolvingPromises=this._allPromise=null}_tryResolve(){if(this.isFulfilled())return;const s=i(),e=[...this._resolvingPromises,r(s.promise)],t=this._allPromise=Promise.all(e);t.then((()=>{this.isFulfilled()||this._allPromise!==t||this._resolver.resolve(this.instance)}),(s=>{this.isFulfilled()||this._allPromise!==t||o(s)||this._resolver.reject(s)})),s.resolve()}}const m=e=>{let r=class extends e{constructor(...s){super(...s),this._promiseProps=new h(this),this.addResolvingPromise(Promise.resolve())}isResolved(){return this._promiseProps.isResolved()}isRejected(){return this._promiseProps.isRejected()}isFulfilled(){return this._promiseProps.isFulfilled()}when(s,e){return new Promise(((s,e)=>{this._promiseProps.when(s,e)})).then(s,e)}catch(s){return this.when(null,s)}addResolvingPromise(s){s&&!this._promiseProps.isFulfilled()&&this._promiseProps.addResolvingPromise("_promiseProps"in s?s.when():s)}};return r=s([l("esri.core.Promise")],r),r};let p=class extends(m(e)){};p=s([l("esri.core.Promise")],p);export{p as EsriPromise,m as EsriPromiseMixin};
