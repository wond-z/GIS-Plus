// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define(["../../chunks/_rollupPluginBabelHelpers","../../core/Error","../../core/maybe","../../core/workers/workers","./PixelBlock"],function(f,g,l,p,k){return function(){function n(){this._workerThread=null;this._destroyed=!1}var e=n.prototype;e.initialize=function(){var c=f._asyncToGenerator(function*(){const a=yield p.open("RasterWorker");this._destroyed?a.close():this._workerThread=a});return function(){return c.apply(this,arguments)}}();e.destroy=function(){this._destroyed=!0;this._workerThread&&
(this._workerThread.close(),this._workerThread=null)};e.convertVectorFieldData=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");return(a=yield this._workerThread.invoke("convertVectorFieldData",{pixelBlock:a.pixelBlock.toJSON(),type:a.dataType},b))?new k(a):null});return function(a,b){return c.apply(this,arguments)}}();e.decode=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection",
"no available worker connection");return(a=yield this._workerThread.invoke("decode",a,b))?new k(a):null});return function(a,b){return c.apply(this,arguments)}}();e.symbolize=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");a={extent:a.extent&&a.extent.toJSON(),pixelBlock:l.isSome(a.pixelBlock)&&a.pixelBlock.toJSON(),simpleStretchParams:a.simpleStretchParams,bandIds:a.bandIds};return(b=yield this._workerThread.invoke("symbolize",
a,b))?new k(b):null});return function(a,b){return c.apply(this,arguments)}}();e.updateSymbolizer=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");const d=a?.rendererJSON?.histograms;yield Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:a.toJSON(),histograms:d},b))});return function(a,b){return c.apply(this,arguments)}}();e.updateRasterFunction=function(){var c=f._asyncToGenerator(function*(a,
b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");yield Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:a.toJSON()},b))});return function(a,b){return c.apply(this,arguments)}}();e.process=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");return(a=yield this._workerThread.invoke("process",{extent:a.extent?.toJSON(),
primaryPixelBlocks:a.primaryPixelBlocks.map(d=>l.isSome(d)?d.toJSON():null),primaryRasterIds:a.primaryRasterIds},b))?new k(a):null});return function(a,b){return c.apply(this,arguments)}}();e.stretch=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");if(!a?.pixelBlock)return null;a={srcPixelBlock:a.pixelBlock.toJSON(),stretchParams:a.stretchParams};return(b=yield this._workerThread.invoke("stretch",
a,b))?new k(b):null});return function(a,b){return c.apply(this,arguments)}}();e.split=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");if(!a?.pixelBlock)return null;a={srcPixelBlock:a.pixelBlock.toJSON(),tileSize:a.tileSize,maximumPyramidLevel:a.maximumPyramidLevel};const d=yield this._workerThread.invoke("split",a,b);d&&d.forEach((h,m)=>{d.set(m,h?k.fromJSON(h):null)});return d});return function(a,
b){return c.apply(this,arguments)}}();e.estimateStatisticsHistograms=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");if(!a?.pixelBlock)return null;a={srcPixelBlock:a.pixelBlock.toJSON()};return yield this._workerThread.invoke("estimateStatisticsHistograms",a,b)});return function(a,b){return c.apply(this,arguments)}}();e.mosaicAndTransform=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection",
"no available worker connection");if(!a?.srcPixelBlocks?.length)return{pixelBlock:null};a={...a,srcPixelBlocks:a.srcPixelBlocks.map(d=>l.isSome(d)?d.toJSON():null)};b=yield this._workerThread.invoke("mosaicAndTransform",a,b);return{pixelBlock:b.pixelBlock?new k(b.pixelBlock):null,localNorthDirections:b.localNorthDirections}});return function(a,b){return c.apply(this,arguments)}}();e.createFlowMesh=function(){var c=f._asyncToGenerator(function*(a,b){if(!this._workerThread)throw new g("raster-jobhandler:no-connection",
"no available worker connection");const d={buffer:a.flowData.data.buffer,maskBuffer:a.flowData.mask.buffer,width:a.flowData.width,height:a.flowData.height},{meshType:h,simulationSettings:m}=a;a=yield this._workerThread.invoke("createFlowMesh",{meshType:h,flowData:d,simulationSettings:m},{...b,transferList:[d.buffer,d.maskBuffer]});return{vertexData:new Float32Array(a.vertexBuffer),indexData:new Uint32Array(a.indexBuffer)}});return function(a,b){return c.apply(this,arguments)}}();e.getProjectionOffsetGrid=
function(c,a){if(!this._workerThread)throw new g("raster-jobhandler:no-connection","no available worker connection");const b=l.isSome(c.datumTransformation)?c.datumTransformation.steps.map(h=>({wkid:h.wkid,wkt:h.wkt,isInverse:h.isInverse})):null,d=l.isSome(c.rasterTransform)?c.rasterTransform.toJSON():null;c={projectedExtent:c.projectedExtent.toJSON(),srcBufferExtent:c.srcBufferExtent.toJSON(),pixelSize:c.pixelSize,hasWrapAround:c.hasWrapAround,spacing:c.spacing,datumTransformationSteps:b,rasterTransform:d,
isAdaptive:c.isAdaptive,includeGCSGrid:c.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",c,a)};return n}()});