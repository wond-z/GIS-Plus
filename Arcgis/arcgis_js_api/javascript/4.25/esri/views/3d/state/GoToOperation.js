// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../Camera ../../../Viewpoint ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/reactiveUtils ../camera/constraintUtils ../camera/constraintUtils/surfaceCollision ./controllers/CameraController ./controllers/PointToPointAnimationController ./controllers/SurfaceCollisionCorrectionController ../support/cameraUtils ../support/viewpointUtils".split(" "),function(p,t,u,v,l,d,m,w,x,q,h,n,y,z,A){let B=function(){function r(a,
b,c){this.target=a;this.options=b;this.view=c;this.state="pending";this._animationController=this._abortController=null;this._promise=new Promise((g,k)=>{this._resolveCallback=g;this._rejectCallback=k;g=new AbortController;if(d.isSome(this.options.signal))m.onAbort(this.options.signal,()=>{this.abort()});this._abortController=g;this.waitForReady()})}var f=r.prototype;f.then=function(a,b){return this._promise.then(a,b)};f.catch=function(a){return this._promise.catch(a)};f.resolve=function(a){this.state=
"finished";return this._resolveCallback(a)};f.reject=function(a){this.state="finished";return this._rejectCallback(a)};f.abort=function(a=!1){switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":this.reject(m.createAbortError());break;case "wait-for-animation-finish":!a&&d.isSome(this._animationController)&&this.view.state.cameraController===this._animationController&&this._animationController.active&&this._animationController.stopController(),this.reject(m.createAbortError())}};
f.waitForReady=function(){var a=t._asyncToGenerator(function*(){this.state="wait-for-ready";if(!this.view.ready)try{yield w.whenOnce(()=>this.view.ready,this._abortController.signal)}catch(b){return this.reject(b)}this.createViewPoint()});return function(){return a.apply(this,arguments)}}();f.createViewPoint=function(){"finished"!==this.state&&(this.state="wait-for-viewpoint",this._animationController=this.options.animate?this._getAnimationController():null,A.create(this.view,this.target,this._abortController.signal).then(a=>
{"finished"!==this.state&&(a=this._getCameraFromViewpoint(a),d.isNone(a)||(this.options.animate?d.isNone(this._animationController)||this.startAnimation(a,this._animationController):(this.view.stateManager.setStateCamera(a.camera,{applyConstraints:!a.isFullySpecified,positionAndOrientationOnly:!0,doNotCancelGoToOperation:!0}),this.resolve())))},a=>{this.reject(a)}))};f._getCameraFromViewpoint=function(a){const b=!!(this.target instanceof v&&this.target.camera||this.target instanceof u);var c=a.camera;
if(d.isNone(c))return null;if(!this.view.stateManager.isCompatible(c))return a=(a=c.position)&&a.spatialReference,this.reject(new l("GotoAnimation:incompatible-spatialreference",`Resulting camera has an incompatible spatial reference (camera: ${a?a.wkid:"none"}, view: ${this.view.spatialReference.wkid})`,{camera:c})),null;c=z.externalToInternal(this.view,c);return d.isNone(c)?(this.reject(new l("GotoAnimation:invalid-camera","Resulting camera is invalid")),null):{viewpoint:a,camera:c,isFullySpecified:b}};
f.startAnimation=function(a,b){this.state="wait-for-animation-finish";const c=b.viewAnimation;if(d.isNone(c))this.reject(new l("GotoAnimation:missing-animation","Unreachable code in view.stateManager"));else{c.update(a.viewpoint,"running");if(!b.active||d.isNone(b.viewAnimation)||b.viewAnimation.target!==a.viewpoint||this.view.state.cameraController!==b)return this.abort();if(a.isFullySpecified){var g=new y.SurfaceCollisionCorrectionController({view:this.view,desiredCamera:a.camera});q.applySurfaceCollisionConstraint(this.view,
a.camera,q.Mode.EYE_AND_CENTER)}else x.applyAll(this.view,a.camera);b.begin(a.camera,this.options);var k=e=>{if(!d.isNone(this.view.state))switch(b.state){case h.State.Finished:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.resolve()}break;case h.State.Ready:case h.State.Rejected:case h.State.Running:case h.State.Stopped:switch(this.state){case "pending":case "wait-for-ready":case "wait-for-viewpoint":case "wait-for-animation-finish":this.reject(e)}}};
c.when(()=>{const e=this.view.state.cameraController;g&&(e&&e.active?e instanceof n.PointToPointAnimationController&&d.isSome(e.viewAnimation)&&e.viewAnimation.target===a.viewpoint&&(this.view.state.cameraController=g):d.isSome(b.viewAnimation)&&b.viewAnimation.target===a.viewpoint&&"finished"===b.state&&(this.view.state.cameraController=g))},e=>k(e));b.asyncResult={resolve:()=>k(),reject:e=>k(e)}}};f._getAnimationController=function(){let a;var b=null;b=this.view.state.cameraController;b instanceof
n.PointToPointAnimationController&&(b.updateStateFromViewAnimation(),b.active&&(a=b,b=a.viewAnimation));return null!=a||(a=new n.PointToPointAnimationController({view:this.view,mode:"animation"}),b=a.viewAnimation,this.view.state.switchCameraController(a))?a:(d.isSome(b)&&b.stop(),this.reject(new l("GotoAnimation:goto-cannot-interrupt","Cannot start an animation while interacting")),null)};return r}();p.GoToOperation=B;Object.defineProperties(p,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});