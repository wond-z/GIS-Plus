// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/mathUtils ../../../../../core/maybe ../../../../../core/quantityUtils ../../../../../chunks/vec2 ../../../../../chunks/vec2f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/vec4f64 ../../../../../geometry/projection ../../../../../geometry/projectionEllipsoid ../../../../../geometry/SpatialReference ../../../../../geometry/support/Axis ../../../../../geometry/support/intersectsBase ../../../../../geometry/support/triangle ../../interfaces ../../support/measurementUtils ../../support/viewUtils ../../../support/ElevationProvider ../../../support/mathUtils ../../../webgl-engine/lib/Indices ../../../../support/euclideanAreaMeasurementUtils".split(" "),
function(H,P,C,y,D,I,m,h,Q,q,E,R,S,J,T,K,w,L,U,F,M,N){let V=function(){function O(a,d){this.positionsWorldCoords=[];this.positionsRenderCoords=[];this.positionsProjectedWorldCoords=[];this.positionsFittedRenderCoords=[];this.positionsGeographic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=[];this.intersectingSegments=new Set;this.geodesicIntersectingSegments=new Set;this.areaCentroidWorldCoords=
h.create();this.areaCentroidRenderCoords=h.create();this.geodesicAreaCentroidRenderCoords=h.create();this._length=0;this._centroidRenderCoords=h.create();this._planeWorldCoords=Q.create();this._worldUp=h.create();this._worldTangent=h.create();this._frame=[h.create(),h.create(),h.create()];this._pathVersion=-1;this._hasCursorPoint=this._validMeasurement=!1;this._mode=null;this._tempU=h.create();this._tempV=h.create();this._tempVec3=h.create();this._tempSphere={center:h.create(),radius:0};this._sceneView=
a;this.unitNormalizer=d}var n=O.prototype;n.update=function(a,d,c,b,e,f,k){const t=this.unitNormalizer,p=this._sceneView.renderSpatialReference,l=this.unitNormalizer.spatialReference,g=C.isSome(d);if(this._pathVersion===a.version&&this._validMeasurement===b&&!k&&this._hasCursorPoint===g&&this._mode===f){if(a.isValidPolygon)return!1;this._updateCursorSegmentLength(a,d);return!0}this._pathVersion=a.version;this._validMeasurement=b;this._hasCursorPoint=g;this._resize(a.numVertices);const x=E.getSphericalPCPF(c.spatialReference),
u=q.canProjectWithoutEngine(c.spatialReference,x)&&q.canProjectToWGS84ComparableLonLat(c.spatialReference),{positionsGeographic:r,positionsWorldCoords:v,positionsRenderCoords:A,positionsSpherical:G}=this;a.forEachVertexPosition((z,B)=>{z.hasZ||(z.z=C.unwrapOr(U.getElevationAtPoint(c.elevationProvider,z,"ground"),0));q.projectPointToVector(z,v[B],l);q.projectPointToVector(z,A[B],p);u&&(q.projectPointToWGS84ComparableLonLat(z,r[B]),q.projectPointToVector(z,G[B],x),m.normalize(G[B],G[B]))});k=this._updatePathLengths(b);
this.pathLength=1<this._length?y.createLength(t.normalizeDistance(k),"meters"):null;u?(k=this._updateGeodesicPathLengths(b,l),this.geodesicPathLength=1<this._length?y.createLength(k,"meters"):null):this.geodesicPathLength=null;this._updateCursorSegmentLength(a,d);this._updateMode(a,f);if(!b)return this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0;this._updateArea(c,
t,p,l,e);u&&this._updateGeodesicArea(c);return!0};n.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,
perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,
pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}};n._resize=function(a){a<this._length&&(this.positionsWorldCoords.length=a,this.positionsRenderCoords.length=a,this.positionsProjectedWorldCoords.length=a,this.positionsFittedRenderCoords.length=a,this.positionsGeographic.length=
a,this.positionsSpherical.length=a,this.positionsStereographic.length=a,this.pathSegmentLengths.length=a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=a);for(;this._length<a;)this.positionsWorldCoords.push(h.create()),this.positionsRenderCoords.push(h.create()),this.positionsProjectedWorldCoords.push(I.create()),this.positionsFittedRenderCoords.push(h.create()),this.positionsGeographic.push(h.create()),this.positionsSpherical.push(h.create()),this.positionsStereographic.push(I.create()),
this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length};n._updatePathLengths=function(a){const d=this.positionsWorldCoords,c=this.pathSegmentLengths;let b=0;for(let e=0;e<this._length;++e){const f=c[e]=m.distance(d[e],d[(e+1)%this._length]);if(e<this._length-1||a)b+=f}return b};n._updateGeodesicPathLengths=function(a,d){const c=this.positionsGeographic,b=this.geodesicPathSegmentLengths;let e=0;for(let f=0;f<this._length;++f){const k=
b[f]=w.segmentLengthGeodesicVector(c[f],c[(f+1)%this._length],d);if(f<this._length-1||a)e+=k}return e};n._updateArea=function(a,d,c,b,e){const f=a.renderCoordsHelper;a=this.positionsWorldCoords;const k=this.positionsRenderCoords,t=this.positionsProjectedWorldCoords,p=this.positionsFittedRenderCoords;var l=this._planeWorldCoords,g=this._centroidRenderCoords;L.midpoint(k,g);f.worldUpAtPosition(g,this._worldUp);f.worldBasisAtPosition(g,S.Axis.X,this._worldTangent);q.projectDirection(g,this._worldUp,
c,this._worldUp,b);q.projectDirection(g,this._worldTangent,c,this._worldTangent,b);2<a.length&&w.bestFitPlane(a,l);this.fittingMode=this._selectFittingMode(l,a,this._worldUp,e);let x=0;if("horizontal"===this.fittingMode){let r=-Infinity;k.forEach((v,A)=>{v=f.getAltitude(k[A]);v>r&&(r=v,x=A)})}e=a[x];g=l;var u=this._worldTangent;"horizontal"===this.fittingMode?g=this._worldUp:"vertical"===this.fittingMode&&(g=this._tempVec3,u=this._worldUp,F.makeOrthonormal(l,this._worldUp,g));m.copy(this._frame[2],
g);F.makeOrthonormal(u,g,this._frame[0]);m.cross(this._frame[1],this._frame[0],this._frame[2]);m.negate(this._frame[1],this._frame[1]);l=this._tempVec3;g=this._tempU;u=this._tempV;for(let r=0;r<this._length;++r){const v=t[r],A=p[r];m.subtract(l,a[r],e);D.set(v,m.dot(this._frame[0],l),m.dot(this._frame[1],l));m.scale(g,this._frame[0],v[0]);m.scale(u,this._frame[1],v[1]);m.add(l,g,u);m.add(l,l,e);q.projectVectorToVector(l,b,A,c)}this.perimeterLength=0<this._length?y.createLength(d.normalizeDistance(this._updatePerimeterLengths()),
"meters"):null;L.midpoint(p,this.areaCentroidRenderCoords);q.projectVectorToVector(this.areaCentroidRenderCoords,c,this.areaCentroidWorldCoords,b);this._updateIntersectingSegments();this.area=0===this.intersectingSegments.size?y.createArea(d.normalizeArea(this._computeArea()),"square-meters"):null};n._updateGeodesicArea=function(a){const {renderCoordsHelper:d,spatialReference:c}=a,{positionsSpherical:b,positionsStereographic:e}=this;a=this._tempVec3;const f=w.fitHemisphere(b,a);if(f){var k=this._tempU,
t=this._tempV;F.tangentFrame(a,k,t);for(let p=0;p<this._length;++p){const l=m.dot(b[p],k),g=m.dot(b[p],t),x=m.dot(b[p],a);D.set(e[p],l/x,g/x)}m.scale(a,a,E.getReferenceEllipsoid(c).radius);d.toRenderCoords(a,E.getSphericalPCPF(c),this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=f&&0===this.geodesicIntersectingSegments.size?y.createArea(this._computeGeodesicArea(),"square-meters"):null}else this.geodesicArea=null};n._updatePerimeterLengths=function(){const a=
this.positionsProjectedWorldCoords,d=this.perimeterSegmentLengths;let c=0;for(let b=0;b<this._length;++b){const e=d[b]=D.distance(a[b],a[(b+1)%this._length]);c+=e}return c};n._updateIntersectingSegments=function(){const a=this.positionsProjectedWorldCoords,d=this.intersectingSegments;d.clear();for(let c=0;c<this._length;++c)for(let b=c+2;b<this._length;++b)(b+1)%this._length!==c&&J.segmentIntersects(a[c],a[(c+1)%this._length],a[b],a[(b+1)%this._length])&&(d.add(c),d.add(b))};n._computeArea=function(){const a=
this.positionsProjectedWorldCoords,d=this.triangleIndices=M.compactIndices(N.triangulate(a));let c=0;for(let b=0;b<d.length;b+=3)c+=T.areaPoints2d(a[d[b]],a[d[b+1]],a[d[b+2]]);return c};n._updateGeodesicIntersectingSegments=function(){const a=this.positionsStereographic,d=this.geodesicIntersectingSegments;d.clear();for(let c=0;c<this._length;++c)for(let b=c+2;b<this._length;++b)(b+1)%this._length!==c&&J.segmentIntersects(a[c],a[(c+1)%this._length],a[b],a[(b+1)%this._length])&&(d.add(c),d.add(b))};
n._computeGeodesicArea=function(){const a=this.positionsGeographic,d=this.geodesicTriangleIndices=M.compactIndices(N.triangulate(this.positionsStereographic));let c=0;for(let b=0;b<d.length;b+=3)c+=w.triangleAreaGeodesic(a[d[b]],a[d[b+1]],a[d[b+2]],R.WGS84);return c};n._selectFittingMode=function(a,d,c,b){var e=d.map(k=>Math.abs(w.planePointDistance(a,k))).reduce((k,t)=>Math.max(k,t),0);w.boundingSphere(d,this._tempSphere);d=e/(2*this._tempSphere.radius);e=d<b.maxRelativeErrorAlmostCoplanar;let f=
"horizontal";d<b.maxRelativeErrorCoplanar?f="oblique":e&&(f=Math.abs(m.dot(c,a))>Math.cos(P.deg2rad(b.verticalAngleThreshold))?"horizontal":"vertical");return f};n._updateCursorSegmentLength=function(a,d){const c=a.lastPoint;!a.isValidPolygon&&C.isSome(c)&&C.isSome(d)?(this.geodesicCursorSegmentLength=y.createLength(w.segmentLengthGeodesic(c,d),"meters"),this.cursorSegmentLength=y.createLength(this.unitNormalizer.normalizeDistance(w.segmentLengthEuclidean(c,d,this.unitNormalizer.spatialReference)),
"meters")):this.cursorSegmentLength=this.geodesicCursorSegmentLength=null};n._updateMode=function(a,d){if(d===K.MeasurementMode.Auto){this.actualMeasurementMode="euclidean";let c=0;null!=this.geodesicPathLength&&(c+=this.geodesicPathLength.value);!a.isValidPolygon&&C.isSome(this.geodesicCursorSegmentLength)&&(c+=this.geodesicCursorSegmentLength.value);1E5<c&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=d===K.MeasurementMode.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&
(this.actualMeasurementMode="euclidean");this._mode=d};return O}();H.MeasurementDataManager=V;Object.defineProperties(H,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});