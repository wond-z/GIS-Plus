// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../chunks/tslib.es6 ../../../../geometry ../../../../analysis/featureReferenceUtils ../../../../core/Accessor ../../../../core/asyncUtils ../../../../core/Evented ../../../../core/Handles ../../../../core/handleUtils ../../../../core/Logger ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/reactiveUtils ../../../../core/accessorSupport/decorators/property ../../../../core/arrayUtils ../../../../core/accessorSupport/ensureType ../../../../core/accessorSupport/decorators/subclass ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../core/support/WatchUpdatingTracking ../../../../geometry/projection ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/ray ../../../../support/elevationInfoUtils ../LineOfSightAnalysisResult ./LineOfSightComputation ./LineOfSightRayIntersector ../support/projectionUtils ../../webgl-engine/lib/IntersectorInterfaces ../../webgl-engine/lib/intersectorUtilsConversions ../../../support/Scheduler ../../../../geometry/Point".split(" "),
function(q,J,r,ha,K,V,W,X,M,A,Y,d,Z,E,u,ia,ja,aa,k,y,ba,B,F,L,N,ca,da,ea,O,P,C,z,fa){const Q=Y.getLogger("esri.views.3d.analysis.LineOfSight.LineOfSightController");q.LineOfSightController=function(R){function G(a){a=R.call(this,a)||this;a.updateOnCameraChange=!0;a._effectiveObserverElevationMode="absolute-height";a._observerFeatureId=null;a._updatingHandles=new ba.WatchUpdatingTracking;a._frameTask=z.ImmediateTask;a._handles=new M;a._computationHandles=new M;a._externalObserverUpdate=!0;return a}
J._inheritsLoose(G,R);var m=G.prototype;m.initialize=function(){const a=this.view.resourceController?.scheduler;this._frameTask=a?a.registerTask(z.TaskPriority.LINE_OF_SIGHT_TOOL):z.ImmediateTask;this._intersector=new ea.LineOfSightRayIntersector({view:this.view});this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])};m.destroy=function(){this._handles.destroy();this._computationHandles.destroy();this._computations.removeAll();this._updatingHandles.destroy()};
m._computeResult=function(a){const b=a.computation,{inputPoints:c,computationResult:e}=b,{observerAdjusted:h,targetAdjusted:f}=c,{start:g,end:p}=e;k.copy(g,h);k.copy(p,f);this._canCompute(b)?this._computeIntersection(a):this._interpolateIntersection(a);b.notifyResultChanged();this.emit("result-changed",{target:a.computation.target,result:b.result})};m._updateAdjustedPointsFromFeatures=function(a){const b=this.view;var {sceneIntersectionHelper:c}=b;({inputPoints:a}=a);const {observerAdjusted:e,observerFeatureId:h,
targetFeatureId:f,targetAdjusted:g}=a;if(!d.isNone(h)||!d.isNone(f)){var p=k.distance(e,g),n=this._intersector.intersector,l=L.fromPoints(a.observer,a.target,S);n.options.store=P.StoreResults.ALL;c.intersectToolIntersectorRay(l,n);var w=l=c=null,v=null;for(const t of n.results.all)n=C.toGraphic(t,this.view),d.isNone(n)||d.isNone(t.distanceInRenderSpace)||(n=K.getFeatureId(n),d.isNone(n)||(d.isSome(h)&&n===h&&(d.isNone(c)&&(c=this._getFeatureDistanceThreshold(t,b,p)),t.distanceInRenderSpace<c&&(w=
t)),d.isSome(f)&&n===f&&(d.isNone(l)&&(l=this._getFeatureDistanceThreshold(t,b,p)),d.isNone(v)&&t.distanceInRenderSpace<p&&p-t.distanceInRenderSpace<l&&(v=t))));d.isSome(w)&&w.getIntersectionPoint(e)&&(a.observerSurfaceNormal=w.getTransformedNormal(y.create()));d.isSome(v)&&v.getIntersectionPoint(g)&&(a.targetSurfaceNormal=v.getTransformedNormal(y.create()))}};m._getFeatureDistanceThreshold=function(a,b,c){return C.hasLod(a)&&(a=C.getIntersectedFeatureBSRadius(a,b),d.isSome(a))?Math.min(.05*a,c):
1E-5*c};m._adjustStartEndPositions=function(a){const b=this._screenPixelSize,c=this.view;var {inputPoints:e}=a;const {observer:h,observerSurfaceNormal:f,target:g,targetSurfaceNormal:p,observerAdjusted:n,targetAdjusted:l}=e;e=H;k.copy(n,h);k.copy(l,g);this._updateAdjustedPointsFromFeatures(a);d.isSome(f)?k.copy(e,f):k.subtract(e,l,n);k.normalize(e,e);k.scale(e,e,Math.min(b,1));k.add(n,n,e);d.isSome(p)?k.copy(e,p):k.subtract(e,n,l);a=c.state.camera.computeScreenPixelSizeAt(l);k.normalize(e,e);k.scale(e,
e,Math.min(a,1));k.add(l,l,e)};m._computeIntersection=function({computation:a,interpolationInfo:b}){const {view:c}=this,{sceneIntersectionHelper:e,renderCoordsHelper:h}=c;if(!d.isNone(e)){var f=this._intersector.intersector,{computationResult:g,inputPoints:p}=a,{observer:n,target:l}=p,{start:w,end:v}=g,t=L.fromPoints(w,v,S);f.options.store=P.StoreResults.MIN;e.intersectToolIntersectorRay(t,f);f=f.results.min;t=g.intersection;var T=H,x=!0;d.isSome(f)&&f.getIntersectionPoint(t)&&(k.copy(b.originalIntersection,
t),k.copy(b.originalObserver,w),k.copy(b.originalTarget,v),h.fromRenderCoords(t,T,c.spatialReference),b=1-k.dist(v,l)/k.dist(w,l),x=k.dist(n,t)>=b*k.dist(n,l));b=new fa(T,c.spatialReference);var {result:D,target:U}=a;d.isSome(D)?(D.target=U,D.intersectedGraphic=x?null:C.toGraphic(f,c),D.intersectedLocation=x?null:b,D.visible=x):a.result=new ca.LineOfSightAnalysisResult({target:U,elevationAlignedTargetLocation:a.elevationAlignedTargetLocation,intersectedGraphic:x?null:C.toGraphic(f,c),intersectedLocation:x?
null:b,visible:x});g.isValid=p.isValid=!0;g.isTargetVisible=x}};m._interpolateIntersection=function({computation:a,interpolationInfo:b}){const {computationResult:c,inputPoints:e}=a,{start:h,end:f,intersection:g}=c,{originalIntersection:p,originalObserver:n,originalTarget:l}=b;k.copy(g,p);e.isValid?(a=H,b=k.dist(n,p)/k.dist(n,l),k.sub(a,h,n),k.scale(a,a,1-b),k.add(g,g,a),k.sub(a,f,l),k.scale(a,a,b),k.add(g,g,a),c.isValid=!0):(a.result=null,c.isValid=!1,c.isTargetVisible=!1)};m._canCompute=function(a){var b=
this.view.frustum;if(d.isNone(this.analysisViewData.elevationAlignedObserver)||d.isNone(a.elevationAlignedTargetLocation)||d.isNone(b))return!1;const {observerAdjusted:c,targetAdjusted:e}=a.inputPoints;a=b.intersectsPoint(c);b=b.intersectsPoint(e);return a&&b};m._onObserverPositionChange=function(a,b,c,e,h){this._externalObserverUpdate=h;if(d.isNone(a))this._observerFeatureId=this.analysisViewData.elevationAlignedObserver=null;else if(d.isNone(b))O.logFailedGeometryProjectionError(this.analysis,a.spatialReference,
Q),this.analysisViewData.elevationAlignedObserver=null;else{a=this._getEffectiveElevationInfo(b,c);var {absoluteZ:f,elevation:g}=N.zValueInAbsoluteHeightMode(b.x,b.y,b.z,this.view.spatialReference,this.view,a);b=b.clone();b.z=f;this._effectiveObserverElevationMode=a.mode;this.analysisViewData.elevationAlignedObserver=b;a=y.create();this.view.renderCoordsHelper.toRenderCoords(b,a);this._elevationAlignedObserverPositionRenderSpace=a;this._observerGroundOffsetRenderSpace=f-g;this._observerFeatureId=
K.getFeatureId(e);this.priority=z.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}};m._onObserverRenderSpacePositionChangeForComputation=function(a,b,c,e,h){const {inputPoints:f}=a;k.copy(f.observer,b);f.observerFeatureId=h;f.observerSurfaceNormal=null;switch(e){case "on-the-ground":case "relative-to-ground":b=this._intersector.updateFromGroundIntersection(f.observer,c,f.observer),d.isNone(f.observerFeatureId)&&(f.observerSurfaceNormal=b)}this._adjustStartEndPositions(a);a.notifyInputPointsChanged();
this.priority=z.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE};m._onTargetPositionChange=function(a,b,c,e,h,f=!0){const g=a.inputPoints;f&&(g.isValid=!1);if(d.isNone(c))d.isSome(b)&&O.logFailedGeometryProjectionError(this.analysis,b.spatialReference,Q),a.elevationAlignedTargetLocation=null,a.notifyInputPointsChanged();else{b=this._getEffectiveElevationInfo(c,e);var {absoluteZ:p,elevation:n}=N.zValueInAbsoluteHeightMode(c.x,c.y,c.z,this.view.spatialReference,this.view,b);c=c.clone();c.z=p;a.elevationAlignedTargetLocation=
c;this.view.renderCoordsHelper.toRenderCoords(a.elevationAlignedTargetLocation,g.target);g.targetFeatureId=K.getFeatureId(h);g.targetSurfaceNormal=null;switch(b.mode){case "on-the-ground":case "relative-to-ground":h=this._intersector.updateFromGroundIntersection(g.target,p-n,g.target),d.isNone(g.targetFeatureId)&&(g.targetSurfaceNormal=h)}this._adjustStartEndPositions(a);a.notifyInputPointsChanged();this.priority=z.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE}};m._connectComputationToTarget=function(a){return A.handlesGroup([this._updatingHandles.add(()=>
({computation:a,targetPosition:a.target.position,targetElevationInfo:a.target.elevationInfo,targetFeatureInfo:a.target.feature,projectedTargetPosition:B.projectOrLoad(a.target.position,this.view.spatialReference)}),({computation:b,targetPosition:c,targetElevationInfo:e,targetFeatureInfo:h,projectedTargetPosition:f})=>{d.isSome(f.pending)?this._updatingHandles.addPromise(f.pending):this._onTargetPositionChange(b,c,f.geometry,e,h)},E.initial)])};m._connectComputationToObserver=function(a){return this._updatingHandles.add(()=>
({computation:a,observer:this.analysisViewData.elevationAlignedObserver}),({computation:b})=>{this._externalObserverUpdate&&(b.inputPoints.isValid=!1,b.notifyInputPointsChanged())},E.initial)};m._connectComputationToRenderSpaceObserver=function(a){return this._updatingHandles.add(()=>({computation:a,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId}),
({computation:b,observer:c,observerGroundOffset:e,observerElevationMode:h,observerFeatureId:f})=>{this._onObserverRenderSpacePositionChangeForComputation(b,c,e,h,f)},E.initial)};m._connectComputationToCamera=function(a){return this._updatingHandles.add(()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty}),({isDirty:b})=>{!this.updateOnCameraChange||a.inputPoints.isValid&&!b||a.notifyInputPointsChanged()})};m._connectComputationToSlicePlane=function(a){return this._updatingHandles.add(()=>
this.view.slicePlane,()=>{a.inputPoints.isValid=!1;a.notifyInputPointsChanged()})};m._connectComputationToElevation=function(a){const b=(c,e)=>{const h=this.analysis.observer,f=a.target;var g=null;let p=null,n=null;var l=null;let w=null,v=null;if(d.isSome(h)&&d.isSome(h.position)){g=B.projectOrLoad(h.position,this.view.spatialReference);if(d.isSome(g.pending)){this._updatingHandles.addPromise(g.pending);g.pending.finally(()=>b(c,e));return}g=g.geometry;p=h.elevationInfo;n=h.feature}if(d.isSome(f.position)){l=
B.projectOrLoad(f.position,this.view.spatialReference);if(d.isSome(l.pending)){this._updatingHandles.addPromise(l.pending);l.pending.finally(()=>b(c,e));return}l=l.geometry;w=f.elevationInfo;v=f.feature}d.isNone(g)&&d.isNone(l)||(B.projectBoundingRect(c,e,I,this.view.spatialReference),d.isSome(g)&&F.containsPointObject(I,g)&&this._onObserverPositionChange(d.isSome(h)?h.position:null,g,p,n,!1),d.isSome(l)&&F.containsPointObject(I,l)&&this._onTargetPositionChange(a,f.position,l,w,v,!1),d.isSome(g)&&
d.isSome(l)&&F.intersectsSegment(I,g,l)&&a.notifyInputPointsChanged())};return this.view.elevationProvider.on("elevation-change",c=>b(c.extent,c.spatialReference))};m._connectComputationToTask=function(a){var b=this;let c=d.none;const e={computation:a,interpolationInfo:{originalIntersection:y.create(),originalObserver:y.create(),originalTarget:y.create()}};return A.handlesGroup([this._updatingHandles.add(()=>a.inputPoints,()=>{c=d.abortMaybe(c);c=W.createTask(function(){var h=J._asyncToGenerator(function*(f){yield Z.ignoreAbortErrors(b._frameTask.schedule(()=>
b._computeResult(e),f))});return function(f){return h.apply(this,arguments)}}())},{initial:!0,equals:()=>!1}),A.makeHandle(()=>c=d.abortMaybe(c))])};m._connectComputation=function(a){const b=this._computationHandles;b.has(a)||b.add([this._connectComputationToTarget(a),this._connectComputationToObserver(a),this._connectComputationToRenderSpaceObserver(a),this._connectComputationToCamera(a),this._connectComputationToSlicePlane(a),this._connectComputationToElevation(a),this._connectComputationToTask(a)],
a)};m._disconnectComputation=function(a){this._computationHandles.remove(a)};m._onComputationCollectionChange=function({added:a,removed:b}){for(const c of b)this._disconnectComputation(c);for(const c of a)this._connectComputation(c)};m._onTargetCollectionChange=function({added:a,removed:b}){for(const c of b)this._removeTarget(c);for(const c of a)this._addTarget(c)};m._onCursorTargetChange=function(a,b){d.isSome(b)&&this._removeTarget(b);d.isSome(a)&&this._addTarget(a)};m._addTarget=function(a){this._computations.some(b=>
b.target===a)||this._computations.add(new da.LineOfSightComputation({target:a}))};m._removeTarget=function(a){const b=this._computations.findIndex(c=>c.target===a);this._computations.removeAt(b)};m._connectObserver=function(){return A.handlesGroup([this._updatingHandles.add(()=>({observerPosition:d.isSome(this.analysis.observer)?this.analysis.observer.position:null,projectedObserverPosition:B.projectOrLoad(d.isSome(this.analysis.observer)?this.analysis.observer.position:null,this.view.spatialReference),
observerElevationInfo:d.isSome(this.analysis.observer)?this.analysis.observer.elevationInfo:null,observerFeatureInfo:d.isSome(this.analysis.observer)?this.analysis.observer.feature:null}),({observerPosition:a,projectedObserverPosition:b,observerElevationInfo:c,observerFeatureInfo:e})=>{d.isSome(b.pending)?this._updatingHandles.addPromise(b.pending):this._onObserverPositionChange(a,b.geometry,c,e,!0)},E.initial)])};m._connectComputations=function(){return this._updatingHandles.addOnCollectionChange(()=>
this._computations,a=>this._onComputationCollectionChange(a),{initial:!0,final:!0})};m._connectTargets=function(){return A.handlesGroup([this._updatingHandles.addOnCollectionChange(()=>this.analysis.targets,a=>this._onTargetCollectionChange(a),{initial:!0,final:!0}),this._updatingHandles.add(()=>this.analysisViewData.cursorTarget,(a,b)=>{this._onCursorTargetChange(a,b)})])};m._getEffectiveElevationInfo=function(a,b){return a.hasZ?d.unwrapOr(b,{mode:"absolute-height",offset:0}):{mode:"on-the-ground",
offset:0}};J._createClass(G,[{key:"updating",get:function(){return this._frameTask.updating||this._updatingHandles.updating}},{key:"priority",get:function(){return this._frameTask.priority},set:function(a){this._frameTask.priority=a}},{key:"_computations",get:function(){return this.analysisViewData.computations}},{key:"_elevationAlignedObserverPositionRenderSpace",get:function(){return this.analysisViewData.observerEngineLocation},set:function(a){this.analysisViewData.observerEngineLocation=a}},{key:"_screenPixelSize",
get:function(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}},{key:"_isCameraDirty",get:function(){var a=this.analysisViewData.elevationAlignedObserver;const {view:b}=this,{renderCoordsHelper:c}=b;if(d.isNone(a)||d.isNone(c))return!1;const e=H;c.toRenderCoords(a,e);a=b.state.camera.computeScreenPixelSizeAt(e);return.1<Math.abs((a-this._screenPixelSize)/this._screenPixelSize)}}]);return G}(X.EventedMixin(V));r.__decorate([u.property({constructOnly:!0})],
q.LineOfSightController.prototype,"analysis",void 0);r.__decorate([u.property({constructOnly:!0})],q.LineOfSightController.prototype,"analysisViewData",void 0);r.__decorate([u.property({constructOnly:!0})],q.LineOfSightController.prototype,"view",void 0);r.__decorate([u.property()],q.LineOfSightController.prototype,"updating",null);r.__decorate([u.property()],q.LineOfSightController.prototype,"priority",null);r.__decorate([u.property()],q.LineOfSightController.prototype,"updateOnCameraChange",void 0);
r.__decorate([u.property()],q.LineOfSightController.prototype,"_computations",null);r.__decorate([u.property()],q.LineOfSightController.prototype,"_elevationAlignedObserverPositionRenderSpace",null);r.__decorate([u.property()],q.LineOfSightController.prototype,"_observerGroundOffsetRenderSpace",void 0);r.__decorate([u.property()],q.LineOfSightController.prototype,"_effectiveObserverElevationMode",void 0);r.__decorate([u.property()],q.LineOfSightController.prototype,"_observerFeatureId",void 0);r.__decorate([u.property()],
q.LineOfSightController.prototype,"_screenPixelSize",null);r.__decorate([u.property({readOnly:!0})],q.LineOfSightController.prototype,"_updatingHandles",void 0);r.__decorate([u.property()],q.LineOfSightController.prototype,"_frameTask",void 0);r.__decorate([u.property()],q.LineOfSightController.prototype,"_isCameraDirty",null);q.LineOfSightController=r.__decorate([aa.subclass("esri.views.3d.analysis.LineOfSight.LineOfSightController")],q.LineOfSightController);const H=y.create(),S=L.create(),I=F.empty();
Object.defineProperties(q,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});