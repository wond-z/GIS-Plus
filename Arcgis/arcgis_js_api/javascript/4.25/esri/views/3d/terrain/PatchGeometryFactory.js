// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../core/maybe ../../../chunks/vec4 ../../../geometry/support/aaBoundingBox ../../../geometry/support/aaBoundingRect ./ElevationData ./interfaces ./PatchGeometry ./PatchGeometryLUT ./PatchRenderData ./terrainUtils ./Tile ./tileUtils".split(" "),function(kb,Q,Va,yc,Wb,zc,ka,ob,Y,Ac,Mb,F,Xb,Eb){function Bc(a){if(a.tile.intersectsClippingArea){const h=a.geometryState,r=h.numVerticesPerSide,v=r-2,d=r-1,p=a.geometryInfo,B=p.vertexAttributes,g=B.position,H=B.uv0,
G=B.normalCompressed,U=a.tile,J=U.extent,M=J[0],N=J[2],C=J[1],u=J[3],R=U.ellipsoid.radius,O=h.samplerData,w=a.localOrigin,e=w[0],k=w[1],m=w[2],f=g.typedBuffer,q=g.typedBufferStride,l=1/d,I=p.boundingBox;let D=0;if(1<=v){const L=C*(1-l)+u*l,x=wa.sinLatLUT[1],S=wa.cosLatLUT[1];for(let y=1;y<=v;y++){const c=y*l,K=wa.sinLonLUT[y],T=wa.cosLonLUT[y],ba=R+ka.sampleElevation(M*(1-c)+N*c,L,O),na=-e+ba*T*S,la=-k+ba*K*S,aa=-m+ba*x;Y.minMaxBoundingBox(na,la,aa,I);const ea=(y-1)*q;f[ea+0]=na;f[ea+1]=la;f[ea+2]=
aa;Y.encodeUVInBuffer(H,y-1,c,l)}}for(let L=1;L<=v;L++){const x=L*l,S=C*(1-x)+u*x,y=wa.sinLatLUT[L],c=wa.cosLatLUT[L],K=L+1,T=K*l,ba=C*(1-T)+u*T,na=wa.sinLatLUT[K],la=wa.cosLatLUT[K],aa=wa.sinLonLUT[0],ea=wa.cosLonLUT[0],ha=R+ka.sampleElevation(M,S,O);let oa=ea*c*ha-e,ta=aa*c*ha-k,ua=y*ha-m;const b=D*q;let n=f[b+0],t=f[b+1],A=f[b+2];for(let z=1;z<=v;z++){const P=z*l,ia=M*(1-P)+N*P,V=wa.sinLonLUT[z],W=wa.cosLonLUT[z],E=W*c,X=V*c,Z=y;let ca=0,fa=0,da=0,Aa=0,ma=0,ra=0;if(z<v){const pa=(D+1)*q;Aa=f[pa+
0];ma=f[pa+1];ra=f[pa+2]}else{const pa=wa.sinLonLUT[d],Ca=wa.cosLonLUT[d],Da=R+ka.sampleElevation(N,S,O);Aa=Ca*c*Da-e;ma=pa*c*Da-k;ra=y*Da-m}const Oa=oa,Ka=ta,Ea=ua;oa=n;ta=t;ua=A;n=Aa;t=ma;A=ra;const xa=Aa-Oa,Fa=ma-Ka,La=ra-Ea,Ga=Fa*Z-La*X,Ma=La*E-xa*Z,Ra=xa*X-Fa*E;ca=Ma*La-Ra*Fa;fa=Ra*xa-Ga*La;da=Ga*Fa-Ma*xa;let Sa=0,Pa=0,Ta=0;if(1<L){const pa=(D-v)*q;Sa=f[pa+0];Pa=f[pa+1];Ta=f[pa+2]}else{const pa=wa.sinLatLUT[0],Ca=wa.cosLatLUT[0],Da=R+ka.sampleElevation(ia,C,O);Sa=W*Ca*Da-e;Pa=V*Ca*Da-k;Ta=pa*
Da-m}const ya=R+ka.sampleElevation(ia,ba,O),Na=W*la*ya-e,Ha=V*la*ya-k,za=na*ya-m;if(L<v){const pa=D+v,Ca=pa*q;f[Ca+0]=Na;f[Ca+1]=Ha;f[Ca+2]=za;Y.minMaxBoundingBox(Na,Ha,za,I);Y.encodeUVInBuffer(H,pa,P,T)}const va=Sa-Na,Ua=Pa-Ha,Wa=Ta-za,Qa=Ua*Z-Wa*X,Ya=Wa*E-va*Z,$a=va*X-Ua*E;ca+=Ya*Wa-$a*Ua;fa+=$a*va-Qa*Wa;da+=Qa*Ua-Ya*va;const Xa=1/Math.sqrt(ca*ca+fa*fa+da*da);Y.encodeNormalToBufferFromValues(G,D,ca*Xa,fa*Xa,da*Xa);++D}}}}function Yb(a){a.tile.intersectsClippingArea&&(Fb(a),Zb(a))}function Zb(a,
h=!1){var r=a.geometryState;const v=a.geometryInfo,d=r.neighborData,p=a.tile,B=p.level,g=p.extent,H=p.ellipsoid.radius;var G=p.extentInRadians;const U=G[0],J=G[2],M=G[1];G=G[3];const N=r.samplerData,C=g[0],u=g[2],R=g[1],O=g[3],w=Nb(a),e=v.boundingBox;r=a.localOrigin;const k=r[0],m=r[1],f=r[2];r=p.surface.shading||!0;var q=v.vertexAttributes,l=q.position;const I=l.typedBuffer,D=l.typedBufferStride,L=q.uv0;for(let y=0;4>y;++y){const c=1===y||3===y;q=d.edgeResolutions[y];F.internalAssert(Q.isPowerOfTwo(q));
const K=q+1;var x=Mb.neighborTileIfLoadedOrSelf(p,d.edgePeerNeighbors[y]);if($b(p,x,y)){ac(a,y);continue}const T=Va.isSome(x);F.internalAssert(!T||x.level===p.level);F.internalAssert(!T||0>=Eb.compareTilesByLij(p,x));l=x?.renderData?.geometryState;if(F.ENABLE_TERRAIN_INTERNAL_CHECKS){var S=p.surface;if(!x&&S&&!S.updatingRootTiles){const E=F.neighborEdgeIndices[y],X=p.findNeighborTile(E,Z=>Z.isLoaded||Z.isLeaf||Z.level===p.level);X?X.intersectsClippingArea&&(F.internalAssert(!X.isLoaded),F.internalAssert(!X.isLeaf),
F.internalAssert(X.level===B)):F.internalAssert(Va.isNone(S?.rootTiles)||!p.shouldHaveNeighbor(E))}}const ba=1===y?g[2]:g[0];x=x?.extent;const na=T&&c?1===y?x[0]:x[2]:ba,la=0===y?g[3]:g[1],aa=1===y?1:0,ea=0===y?1:0,ha=1===y?J:U,oa=0===y?G:M,ta=Math.sin(ha),ua=Math.cos(ha),b=Math.sin(oa),n=Math.cos(oa),t=l?.samplerData;l=(E,X,Z)=>ka.sampleElevation(E,X,N);S=(E,X,Z)=>.5*(ka.sampleElevation(E,X,N)+ka.sampleElevation(Z,X,t));const A=T?S:l,z=v.outerEdges[y],P=h&&3<K?K-3:1;l=Va.isSome(N)&&N.some(E=>null!=
E);S=Va.isSome(t)&&t.some(E=>null!=E);const ia=l||S,V=1/q,W=z.index0;r?(F.internalAssert(!T||F.almostEquals(x[2]-x[0],g[2]-g[0])),(()=>{const E=1===y?-1:3===y?1:0,X=0===y?-1:2===y?1:0,Z=(g[2]-g[0])*V,ca=E*Z,fa=X*Z,da=J-U,Aa=c?E*da*V:0,ma=c?0:X*V,ra=ea,Oa=c?ha+Aa:ha,Ka=c?Math.sin(Oa):ta,Ea=c?Math.cos(Oa):ua,xa=c?ha-Aa:ha,Fa=c?Math.sin(xa):ta,La=c?Math.cos(xa):ua,Ga=c?oa:w(ra+ma),Ma=c?b:Math.sin(Ga),Ra=c?n:Math.cos(Ga),Sa=c?oa:w(ra-ma),Pa=c?b:Math.sin(Sa),Ta=c?n:Math.cos(Sa),ya=(W+0)*D;let Na=I[ya+
0]+k,Ha=I[ya+1]+m,za=I[ya+2]+f,va=0,Ua=0,Wa=0;const Qa=1*V,Ya=c?ba:C*(1-Qa)+u*Qa,$a=c?na:Ya,Xa=c?R*(1-Qa)+O*Qa:la,pa=c?ha:U*(1-Qa)+J*Qa,Ca=c?ta:Math.sin(pa),Da=c?ua:Math.cos(pa),ab=c?w(Qa):oa,eb=c?Math.sin(ab):b,bb=c?Math.cos(ab):n,Ba=H+A(Ya,Xa,$a);va=Da*bb*Ba;Ua=Ca*bb*Ba;Wa=eb*Ba;for(let sa=1;sa<K-1;sa+=P){let Ia=0,qa=0,ja=0;const Ja=(W+sa+1)*D;if(sa<K-2){const cb=(sa+1)*V,lb=c?ba:C*(1-cb)+u*cb,pb=c?na:lb,qb=c?R*(1-cb)+O*cb:la,mb=c?ha:U*(1-cb)+J*cb,rb=c?ta:Math.sin(mb),sb=c?ua:Math.cos(mb),Bb=c?
w(cb):oa,Gb=c?Math.sin(Bb):b,Cb=c?Math.cos(Bb):n,db=H+A(lb,qb,pb);Ia=sb*Cb*db;qa=rb*Cb*db;ja=Gb*db}else Ia=I[Ja+0]+k,qa=I[Ja+1]+m,ja=I[Ja+2]+f;const Za=Ia,fb=qa,tb=ja,hb=va,ib=Ua,jb=Wa;va=Za;Ua=fb;Wa=tb;const ub=W+sa,nb=ub*D,gb=hb-k,bc=ib-m,cc=jb-f;I[nb+0]=gb;I[nb+1]=bc;I[nb+2]=cc;Y.minMaxBoundingBox(gb,bc,cc,e);const dc=sa*V;Y.encodeUVInBuffer(L,ub,c?aa:dc,c?dc:ea);const Cc=Na,Dc=Ha,Ec=za;Na=hb;Ha=ib;za=jb;const vb=hb,wb=ib,xb=jb;let yb=0,zb=0,Ab=0;if(ia){const cb=1/Math.sqrt(vb*vb+wb*wb+xb*xb),
lb=vb*cb,pb=wb*cb,qb=xb*cb,mb=Za-Cc,rb=fb-Dc,sb=tb-Ec,Bb=rb*qb-sb*pb,Gb=sb*lb-mb*qb,Cb=mb*pb-rb*lb;yb+=Gb*sb-Cb*rb;zb+=Cb*mb-Bb*sb;Ab+=Bb*rb-Gb*mb;const db=sa*V,ec=c?ba:C*(1-db)+u*db,Fc=c?na:ec,fc=c?R*(1-db)+O*db:la,gc=c?ha:U*(1-db)+J*db,hc=c?ta:Math.sin(gc),ic=c?ua:Math.cos(gc),jc=c?w(db):oa,kc=c?Math.sin(jc):b,lc=c?Math.cos(jc):n;let Ob=vb,Pb=wb,Qb=xb;if(T){const Rb=H+ka.sampleElevation(Fc-ca,fc-fa,t),Gc=c?Fa:hc,Hc=c?kc:Pa,mc=c?lc:Ta;Ob=(c?La:ic)*mc*Rb;Pb=Gc*mc*Rb;Qb=Hc*Rb}const Sb=H+ka.sampleElevation(ec+
ca,fc+fa,N),nc=c?lc:Ra,oc=(c?Ea:ic)*nc*Sb,pc=(c?Ka:hc)*nc*Sb,qc=(c?kc:Ma)*Sb;T||(Ob=2*vb-oc,Pb=2*wb-pc,Qb=2*xb-qc);const Hb=Ob-oc,Ib=Pb-pc,Jb=Qb-qc,rc=Ib*qb-Jb*pb,sc=Jb*lb-Hb*qb,tc=Hb*pb-Ib*lb;yb+=sc*Jb-tc*Ib;zb+=tc*Hb-rc*Jb;Ab+=rc*Ib-sc*Hb}else yb=vb,zb=wb,Ab=xb;const Tb=1/Math.sqrt(yb*yb+zb*zb+Ab*Ab);z.setNormalFromValues(sa,yb*Tb,zb*Tb,Ab*Tb)}})()):(()=>{for(let Aa=1;Aa<K-1;Aa+=P){var E=Aa*V;const ma=c?aa:E,ra=c?E:ea;var X=c?ba:C*(1-E)+u*E,Z=c?R*(1-E)+O*E:la;const Oa=c?na:X;var ca=c?ha:U*(1-E)+
J*E,fa=c?ta:Math.sin(ca);ca=c?ua:Math.cos(ca);var da=c?w(E):oa;E=c?Math.sin(da):b;da=c?Math.cos(da):n;X=A(X,Z,Oa);X=H+X;ca=ca*da*X-k;fa=fa*da*X-m;E=E*X-f;Y.minMaxBoundingBox(ca,fa,E,e);X=W+Aa;Z=X*D;I[Z+0]=ca;I[Z+1]=fa;I[Z+2]=E;Y.encodeUVInBuffer(L,X,ma,ra)}})()}}function Nb(a){a=a.tile;if(a.surface.isWebMercator){const r=a.extent,v=a.ellipsoid.radius;return d=>Math.PI/2-2*Math.atan(Math.exp(-(r[1]*(1-d)+r[3]*d)/v))}const h=a.extentInRadians;return r=>h[1]*(1-r)+h[3]*r}function Ic(a){const h=a.tile;
if(h.intersectsClippingArea)if(h.surface.shading){{const r=a.tile,v=a.geometryState,d=v.samplerData,p=a.localOrigin,B=r.surface.isWebMercatorOnPlateeCarree,g=v.clippingArea,H=Va.isSome(g)?g:Kb,G=r.extent,U=G[0],J=G[1],M=G[2],N=G[3],C=Math.max(U,H[0]),u=Math.min(M,H[2]),R=Math.max(J,H[1]),O=Math.min(N,H[3]),w=r.ellipsoid.radius,e=r.horizontalScale,k=v.numVerticesPerSide,m=k-1,f=k-2,q=a.geometryInfo,l=q.vertexAttributes,I=l.position,D=l.uv0,L=l.normalCompressed,x=q.uvRange,S=x[0],y=x[1],c=x[2],K=x[3],
T=q.boundingBox,ba=p[0],na=p[1],la=p[2],aa=I.typedBuffer,ea=I.typedBufferStride;let ha=0;const oa=Q.clamp(J,R,O),ta=B?(Math.PI/2-2*Math.atan(Math.exp(-oa/w)))*w:oa*e,ua=1/m,b=Q.clamp(J*(1-ua)+N*ua,R,O);let n=ta,t=B?(Math.PI/2-2*Math.atan(Math.exp(-b/w)))*w:b*e;for(let A=1;A<=f;A++){const z=A/m,P=Q.clamp(J*(1-z)+N*z,R,O),ia=Q.clamp(z,y,K),V=t,W=(A-1)/m,E=Q.clamp(J*(1-W)+N*W,R,O),X=n,Z=(A+1)/m,ca=Q.clamp(J*(1-Z)+N*Z,R,O),fa=B?(Math.PI/2-2*Math.atan(Math.exp(-ca/w)))*w:ca*e,da=Q.clamp(Z,y,K);n=t;t=fa;
const Aa=Q.clamp(U,C,u);let ma=Aa*e,ra=ka.sampleElevation(Aa,P,d);const Oa=1/m,Ka=Q.clamp(Oa,S,c),Ea=Q.clamp(U*(1-Ka)+M*Ka,C,u);let xa=Ka,Fa=Ea,La=Ea*e,Ga=ka.sampleElevation(Ea,P,d);if(1===A){const Ma=La-ba,Ra=n-na,Sa=Ga-la,Pa=0*ea;aa[Pa+0]=Ma;aa[Pa+1]=Ra;aa[Pa+2]=Sa;Y.minMaxBoundingBox(Ma,Ra,Sa,T);const Ta=Q.clamp(Oa,S,c);Y.encodeUVInBuffer(D,ha,Ta,ia)}for(let Ma=1;Ma<=f;Ma++){const Ra=La,Sa=Ga,Pa=(Ma+1)/m,Ta=Q.clamp(Pa,S,c),ya=Q.clamp(U*(1-Pa)+M*Pa,C,u),Na=Fa;Fa=ya;const Ha=ha+1,za=Ha*ea;if(1===
A||Ma===f){const Ba=ka.sampleElevation(ya,P,d),sa=ya*e,Ia=V,qa=Ba;if(1===A&&Ma<f){const ja=sa-ba,Ja=Ia-na,Za=qa-la;aa[za+0]=ja;aa[za+1]=Ja;aa[za+2]=Za;Y.minMaxBoundingBox(ja,Ja,Za,T);Y.encodeUVInBuffer(D,Ha,Ta,ia)}La=sa;Ga=qa}else La=aa[za+0]+ba,Ga=aa[za+2]+la;const va=La,Ua=Ga,Wa=ma,Qa=ra;ma=Ra;ra=Sa;const Ya=(ha-f)*ea,$a=1===A?ka.sampleElevation(Na,E,d):aa[Ya+2]+la,Xa=ka.sampleElevation(Na,ca,d);if(A<f){const Ba=ha+f,sa=Ba*ea,Ia=Ra-ba,qa=fa-na,ja=Xa-la;aa[sa+0]=Ia;aa[sa+1]=qa;aa[sa+2]=ja;Y.minMaxBoundingBox(Ia,
qa,ja,T);const Ja=xa;xa=Ta;Y.encodeUVInBuffer(D,Ba,Ja,da)}const pa=va-Wa,Ca=-pa*(Ua-Qa),Da=X-fa,ab=-Da*($a-Xa),eb=pa*pa+Da*Da,bb=Ca*Ca+ab*ab+eb*eb;if(0===bb)Y.encodeNormalToBufferFromValues(L,ha,0,0,1);else{const Ba=1/Math.sqrt(bb);Y.encodeNormalToBufferFromValues(L,ha,Ca*Ba,ab*Ba,eb*Ba)}++ha}}}}else{const r=a.geometryState,v=r.samplerData,d=a.tile,p=a.localOrigin,B=d.surface.isWebMercatorOnPlateeCarree,g=r.clippingArea,H=Va.isSome(g)?g:Kb,G=d.extent,U=G[0],J=G[1],M=G[2],N=G[3],C=Math.max(U,H[0]),
u=Math.min(M,H[2]),R=Math.max(J,H[1]),O=Math.min(N,H[3]),w=p[0],e=p[1],k=p[2],m=d.horizontalScale,f=Ub(B,d.ellipsoid.radius,m),q=r.numVerticesPerSide,l=q-1,I=q-2,D=a.geometryInfo,L=D.uvRange,x=L[0],S=L[1],y=L[2],c=L[3],K=D.boundingBox,T=D.vertexAttributes,ba=T.position,na=T.uv0;let la=0;for(let aa=1;aa<=I;aa++){const ea=aa/l,ha=Q.clamp(J*(1-ea)+N*ea,R,O),oa=Q.clamp(ea,S,c),ta=f(ha)-e;for(let ua=1;ua<=I;ua++){const b=ua/l,n=Q.clamp(U*(1-b)+M*b,C,u),t=Q.clamp(b,x,y),A=ka.sampleElevation(n,ha,v),z=n*
m-w,P=A-k;Y.minMaxBoundingBox(z,ta,P,K);ba.setValues(la,z,ta,P);Y.encodeUVInBuffer(na,la,t,oa);++la}}}}function uc(a,h){a.tile.intersectsClippingArea&&(Fb(a),vc(a,!1))}function vc(a,h){const r=a.geometryState,v=r.neighborData,d=a.tile,p=d.surface,B=p.shading||!0,g=d.extent,H=r.clippingArea,G=Va.isSome(H)?H:Kb,U=g[0],J=g[2],M=g[1],N=g[3],C=[N>G[3],J>G[2],M<G[1],U<G[0]],u=a.geometryInfo,R=d.horizontalScale,O=Ub(p.isWebMercatorOnPlateeCarree,d.ellipsoid.radius,R),w=u.boundingBox,e=u.uvRange[0],k=u.uvRange[1],
m=u.uvRange[2],f=u.uvRange[3],q=Math.max(U,G[0]),l=Math.min(J,G[2]),I=Math.max(M,G[1]),D=Math.min(N,G[3]),L=a.localOrigin,x=L[0],S=L[1],y=L[2],c=r.samplerData;for(let K=0;4>K;++K){const T=1===K||3===K,ba=v.edgeResolutions[K];F.internalAssert(Q.isPowerOfTwo(ba));const na=ba+1,la=C[K],aa=Mb.neighborTileIfLoadedOrSelf(d,v.edgePeerNeighbors[K]);if(!la&&$b(d,aa,K)){ac(a,K);continue}const ea=Va.isSome(aa)&&!la,ha=aa?.renderData?.geometryState;if(F.ENABLE_TERRAIN_INTERNAL_CHECKS&&(F.internalAssert(!ea||
aa.level===d.level),F.internalAssert(!ea||0>=Eb.compareTilesByLij(d,aa)),d&&!aa&&!p.updatingRootTiles)){const V=F.neighborEdgeIndices[K],W=d.findNeighborTile(V,E=>E.isLoaded||E.isLeaf||E.level===d.level);p.updatingRootTiles||(W?W.intersectsClippingArea&&(F.internalAssert(!W.isLoaded),F.internalAssert(!W.isLeaf),F.internalAssert(W.level===d.level)):F.internalAssert(Va.isNone(p?.rootTiles)||!d.shouldHaveNeighbor(V)))}const oa=Q.clamp(1===K?J:U,q,l),ta=Q.clamp(0===K?N:M,I,D),ua=ha?.samplerData,b=u.outerEdges[K],
n=h&&3<na?na-3:1,t=Q.clamp(1===K?1:0,e,m),A=Q.clamp(0===K?1:0,k,f),z=(V,W)=>ka.sampleElevation(V,W,c),P=(V,W)=>.5*(ka.sampleElevation(V,W,ua)+ka.sampleElevation(V,W,c)),ia=ea?P:z;if(B){const V=(J-U)/ba,W=T?1===K?V:-V:0,E=T?0:0===K?V:-V,X=-W,Z=-E,ca=b.attributes.position.typedBuffer,fa=b.attributes.position.typedBufferStride,da=b.index0,Aa=b.stride,ma=da*fa;let ra=ca[ma+0]+x,Oa=ca[ma+1]+S,Ka=ca[ma+2]+y,Ea=0,xa=0,Fa=0;const La=1/ba,Ga=T?oa:Q.clamp(U*(1-La)+J*La,q,l),Ma=T?Q.clamp(M*(1-La)+N*La,I,D):
ta,Ra=ia(Ga,Ma),Sa=Ga*R,Pa=O(Ma),Ta=Ra;Ea=Sa;xa=Pa;Fa=Ta;for(let ya=1;ya<na-1;ya+=n){const Na=ya/ba,Ha=Ea,za=xa,va=Fa,Ua=T?t:Q.clamp(Na,e,m),Wa=T?Q.clamp(Na,k,f):A,Qa=Ha-x,Ya=za-S,$a=va-y;Y.minMaxBoundingBox(Ha,Ya,$a,w);b.setVertexFromValuesRawPositionUV(ya,Qa,Ya,$a,Ua,Wa);const Xa=ya+1;if(ya===na-1){const ja=(da+Xa*Aa)*fa;Ea=ca[ja+0]+x;xa=ca[ja+1]+S;Fa=ca[ja+2]+y}else{const ja=Xa/ba,Ja=T?oa:Q.clamp(U*(1-ja)+J*ja,q,l),Za=T?Q.clamp(M*(1-ja)+N*ja,I,D):ta,fb=ia(Ja,Za);Ea=Ja*R;xa=O(Za);Fa=fb}const pa=
Ea,Ca=xa,Da=Fa,ab=ra,eb=Oa,bb=Ka;ra=Ha;Oa=za;Ka=va;let Ba=0,sa=0,Ia=0;if(T){const ja=Ca-za,Ja=eb-za;sa-=Ja*(bb-va)+ja*(Da-va);Ia+=Ja*Ja+ja*ja;const Za=Q.clamp(M*(1-Na)+N*Na,I,D),fb=oa+X,tb=fb*R,hb=ka.sampleElevation(fb,Za,c),ib=tb-Ha;Ba-=ib*(hb-va);Ia+=ib*ib;if(ea){const jb=oa+W,ub=jb*R,nb=ka.sampleElevation(jb,Za,ua),gb=ub-Ha;Ba-=gb*(nb-va);Ia+=gb*gb}}else{const ja=pa-Ha,Ja=ab-Ha;Ba-=ja*(Da-va)+Ja*(bb-va);Ia+=ja*ja+Ja*Ja;const Za=Q.clamp(U*(1-Na)+J*Na,q,l),fb=ta+Z,tb=ka.sampleElevation(Za,fb,c)-
va,hb=O(fb)-za;sa-=hb*tb;Ia+=hb*hb;if(ea){const ib=Za,jb=ta+E,ub=O(jb),nb=ka.sampleElevation(ib,jb,ua)-va,gb=ub-za;sa-=gb*nb;Ia+=gb*gb}}const qa=1/Math.sqrt(Ba*Ba+sa*sa+Ia*Ia);b.setNormalFromValues(ya,Ba*qa,sa*qa,Ia*qa)}}else for(let V=1;V<na-1;V+=n){const W=V/ba,E=T?oa:Q.clamp(U*(1-W)+J*W,q,l),X=T?Q.clamp(M*(1-W)+N*W,I,D):ta,Z=T?t:Q.clamp(W,e,m),ca=T?Q.clamp(W,k,f):A,fa=ia(E,X),da=E*R-x,Aa=O(X)-S,ma=fa-y;Y.minMaxBoundingBox(da,Aa,ma,w);b.setVertexFromValuesRawPositionUV(V,da,Aa,ma,Z,ca)}}}function Ub(a,
h,r){return a?v=>(Math.PI/2-2*Math.atan(Math.exp(-v/h)))*h:v=>v*r}function wc(a,h,r,v,d,p){const B=h-1,g=a.vertexAttributes.count,H=2*(Math.min(h-2,v[1])-Math.max(1,v[0]))*(Math.min(h-2,d[1])-Math.max(1,d[0])),G=F.neighborEdgeIndices.map((w,e)=>0===e&&d[1]<h-2||1===e&&v[1]<h-2||2===e&&1<d[0]||3===e&&1<v[0]),U=a.outerEdges.reduce((w,e,k)=>w+(G[k]?0:B-2+e.count-1),0),J=r.reduce((w,e)=>w+B*(2*(e.latitudeResolution-1)+1),0),M=p?2:1,N=3*(H+U+J)*M,C=65536<=g?new Uint32Array(N):new Uint16Array(N);let u=
0;const R=h-2,O=B-2;F.internalAssert(0<=O);if(p){const w=(e,k,m)=>{C[u++]=e;C[u++]=k;C[u++]=k;C[u++]=m;C[u++]=m;C[u++]=e;F.ENABLE_TERRAIN_INTERNAL_CHECKS&&(F.internalAssert(e<g),F.internalAssert(k<g),F.internalAssert(m<g),F.internalAssert(u<=N))};(()=>{for(let e=Math.max(d[0],1)-1;e<Math.min(d[1],h-2)-1;++e)for(let k=Math.max(v[0],1)-1;k<Math.min(v[1],h-2)-1;++k){const m=e*R+k,f=m+1,q=f+R,l=q-1;w(m,f,q);w(q,l,m)}})();F.internalAssert(u===3*H*M);(()=>{for(let k=0;4>k;++k){const m=u;if(G[k])continue;
const f=a.outerEdges[k],q=a.innerEdges[k];let l=0,I=0;const D=f.count,L=q.count;F.internalAssert(L===B-1);let x=0;const S=1===k||2===k?(y,c,K)=>w(y,c,K):(y,c,K)=>w(y,K,c);for(;l<D-1||I<L-1;){const y=q.getVertexIndex(I),c=f.getVertexIndex(l);var e=l<D-1;const K=I<L-1,T=e?B*(l+.5)/(D-1):0,ba=K?1+O*(I+.5)/(L-1):0;e&&(!K||T<=ba)?(++l,F.ENABLE_TERRAIN_INTERNAL_CHECKS&&F.internalAssert(l<D),e=f.getVertexIndex(l),S(y,c,e)):(++I,F.ENABLE_TERRAIN_INTERNAL_CHECKS&&F.internalAssert(I<L),e=q.getVertexIndex(I),
S(y,c,e));x++}F.ENABLE_TERRAIN_INTERNAL_CHECKS&&(F.internalAssert(l===D-1),F.internalAssert(I===L-1),F.internalAssert(x===D+L-2),F.internalAssert(x===B-2+f.count-1),F.internalAssert(u===m+3*x*M))}})();F.internalAssert(u===3*(H+U)*M);r.forEach(e=>{var k=a.outerEdges[e.connectedOuterEdgeOffset];let m=k.getVertexIndex(0);k=k.stride;for(let f=0;f<e.latitudeResolution;++f){const q=0===f?e.rowOffset:m+h;for(let l=0;l<B;l++)w(m,m+1,q+l),f<e.latitudeResolution-1&&w(m+1,q+l+1,q+l),m+=k;m=q;k=1}})}else(()=>
{var w=Math.max(d[0],1)-1;const e=Math.min(d[1],h-2)-1,k=Math.max(v[0],1)-1,m=Math.min(v[1],h-2)-1;for(;w<e;++w){const f=w*R;for(let q=k;q<m;++q){const l=f+q,I=l+1,D=I+R,L=D-1;C[u+0]=l;C[u+1]=I;C[u+2]=D;C[u+3]=D;C[u+4]=L;C[u+5]=l;u+=6}}})(),F.internalAssert(u===3*H*M),(()=>{for(let f=0;4>f;++f){if(G[f])continue;var w=a.outerEdges[f],e=a.innerEdges[f];let q=0,l=0;const I=w.count,D=e.count;F.internalAssert(D===B-1);var k=1===f||2===f;const L=k?1:2;k=k?2:1;const x=w.index0;w=w.stride;const S=e.index0;
for(e=e.stride;q<I-1||l<D-1;){const y=S+l*e,c=x+q*w;var m=q<I-1;const K=l<D-1,T=m?B*(q+.5)/(I-1):0,ba=K?1+O*(l+.5)/(D-1):0;(m=m&&(!K||T<=ba))?++q:++l;m=m?c+w:y+e;C[u+0]=y;C[u+L]=c;C[u+k]=m;u+=3}}})(),F.internalAssert(u===3*(H+U)*M),r.forEach(w=>{var e=a.outerEdges[w.connectedOuterEdgeOffset];let k=e.getVertexIndex(0);e=e.stride;for(let m=0;m<w.latitudeResolution;++m){const f=0===m?w.rowOffset:k+h;for(let q=0;q<B;q++){const l=f+q;C[u+0]=k;C[u+1]=k+1;C[u+2]=l;m<w.latitudeResolution-1?(C[u+3]=k+1,C[u+
4]=l+1,C[u+5]=l,u+=6):u+=3;k+=e}k=f;e=1}});F.internalAssert(u===N);a.indices=C;a.indexCount=N}function xc(a,h){const r=a.localOrigin,v=a.geometryInfo;a=a.geometryState.neighborData.edgeResolutions;const d=v.numVerticesPerSide-2,p=v.vertexAttributes;for(let g=0;4>g;++g){var B=0===g||2===g;v.innerEdges[g]=new Y.EdgeDescriptor(p,r,(0===g?d-1:0)*d+(1===g?d-1:0),(B?0:1)*d+(B?1:0),d);B=a[g]+1;v.outerEdges[g]=new Y.EdgeDescriptor(p,r,h,1,B);h+=B}}function ac(a,h){var r=(h+2)%4,v=a.tile,d=a.geometryState.neighborData,
p=Mb.neighborTileIfLoadedOrSelf(v,d.edgePeerNeighbors[h]),B=v.level-p.level;const g=1===h||3===h;d=d.edgeResolutions[h];F.internalAssert(Q.isPowerOfTwo(d));const H=d+1;var G=a.geometryInfo;const U=G.boundingBox;var J=G.outerEdges[h];const M=G.uvRange[0],N=G.uvRange[1],C=G.uvRange[2];G=G.uvRange[3];const u=Q.clamp(1===h?1:0,M,C),R=Q.clamp(0===h?1:0,N,G);var O=p.renderData,w=O.geometryState,e=O.geometryInfo.outerEdges[r];h=v.getNeighborEdgeStartVertexIndex(h,p)*d;B=d*2**B;F.internalAssert(w.neighborData.edgeResolutions[r]===
B);F.internalAssert(e.count-1===B);r=O.localOrigin[0]-a.localOrigin[0];B=O.localOrigin[1]-a.localOrigin[1];a=O.localOrigin[2]-a.localOrigin[2];var k=J.attributes;O=J.index0;J=J.stride;v=k.position.typedBuffer;p=k.position.typedBufferStride;w=k.normalCompressed.typedBuffer;const m=k.normalCompressed.typedBufferStride;k=k.uv0;var f=e.attributes;const q=e.index0;e=e.stride;const l=f.position.typedBuffer,I=f.position.typedBufferStride,D=f.normalCompressed.typedBuffer;f=f.normalCompressed.typedBufferStride;
for(let y=1;y<H-1;++y){const c=O+J*y;var L=q+e*(h+y),x=c*p,S=L*I;const K=l[S+0]+r,T=l[S+1]+B;S=l[S+2]+a;v[x+0]=K;v[x+1]=T;v[x+2]=S;Y.minMaxBoundingBox(K,T,S,U);x=c*m;L*=f;w[x+0]=D[L+0];w[x+1]=D[L+1];x=y/d;L=g?u:Q.clamp(x,M,C);x=g?Q.clamp(x,N,G):R;Y.encodeUVInBuffer(k,c,L,x)}}function Fb(a){const h=a.geometryState,r=a.localOrigin,v=h.neighborData.cornerNeighborData,d=a.geometryInfo,p=d.outerEdges,B=d.boundingBox,g=a.tile,H="local"===a.tile.surface.view?.viewingMode,G=g.ellipsoid.radius,U=g.extentInRadians,
J=g.horizontalScale;let M=0,N=0,C=0,u=0,R=0,O=0;const w=()=>{const b=a.geometryState.clippingArea,n=g.extent,t=Va.isSome(b)&&(n[3]>b[3]||n[2]>b[2]||n[1]<b[1]||n[0]<b[0]),A=Ub(g.surface.isWebMercatorOnPlateeCarree,g.ellipsoid.radius,J);return(z,P,ia)=>{z=0===z?D[0]:D[2];P=0===P?D[1]:D[3];z=t?Q.clamp(z,b[0],b[2]):z;P=t?Q.clamp(P,b[1],b[3]):P;M=z*J;N=A(P);C=ia}},e=(b,n,t)=>{var A=U[0===n?1:3];b=U[0===b?0:2];n=Math.cos(A);A=Math.sin(A);const z=Math.sin(b);t=G+t;M=Math.cos(b)*n*t;N=z*n*t;C=A*t},k=H?w():
e;let m=0,f=0,q=0;const l=H&&a.tile.surface.isWebMercatorOnPlateeCarree,I=(b,n,t,A)=>{if(H){var z=n*J-M;t=(l?(Math.PI/2-2*Math.atan(Math.exp(-t/G)))*G:t*J)-N;A-=C;m+=-z*A;f+=-t*A;q+=z*z+t*t}else{z=Nb(b);var P=b.tile;b=P.extent;P=P.extentInRadians;n=(n-b[0])/(b[2]-b[0]);n=P[0]*(1-n)+P[2]*n;z=z((t-b[1])/(b[3]-b[1]));t=Math.cos(z);b=G+A;A=Math.cos(n)*t*b-M;t=Math.sin(n)*t*b-N;z=Math.sin(z)*b-C;b=t*O-z*R;n=z*u-A*O;P=A*R-t*u;m+=n*z-P*t;f+=P*A-b*z;q+=b*t-n*A}},D=g.extent,L=h.clippingArea,x=Va.isSome(L)?
L:Kb,S=D[0],y=D[2],c=D[1],K=D[3],T=[K>x[3],y>x[2],c<x[1],S<x[0]],ba=Math.max(S,x[0]),na=Math.min(y,x[2]),la=Math.max(c,x[1]),aa=Math.min(K,x[3]),ea=d.uvRange[0],ha=d.uvRange[1],oa=d.uvRange[2],ta=d.uvRange[3],ua=b=>{if(!H){var n=1/Math.sqrt(M*M+N*N+C*C);u=M*n;R=N*n;O=C*n}b=v[b].cornerTiles;q=f=m=0;n=Infinity;for(var t=0;4>t;++t)n=Math.min(n,b[t]?.level??Infinity);for(t=0;4>t;++t){var A=b[t];Db[t]=A?.level===n?A:null}b=1;n=0;for(t=0;4>t;++t)if(A=Db[t])b=Math.max(b,A?.renderData.geometryState.numVerticesPerSide),
n=A.extent[2]-A.extent[0];F.internalAssert(1<b);b=n/b;for(n=0;4>n;++n){var z=Db[(n+3)%4],P=Db[(n+0)%4];if(z||P){A=0===n?1:1===n?2:2===n?3:0;var ia=0===n?2:1===n?3:2===n?0:1;if(z&&P){var V=Vb[n][0]*b,W=Vb[n][1]*b,E=z.extent;t=E[0===A||1===A?2:0]+V;A=E[0===A||3===A?3:1]+W;E=P.extent;V=E[0===ia||1===ia?2:0]+V;ia=E[0===ia||3===ia?3:1]+W;z=z.renderData;W=P.renderData;P=ka.sampleElevation(t,A,z.geometryState.samplerData);ia=ka.sampleElevation(V,ia,W.geometryState.samplerData);I(z,t,A,.5*(P+ia))}else t=
z??P,z=z?A:ia,P=t.extent,ia=Vb[n],A=P[0===z||1===z?2:0]+ia[0]*b,z=P[0===z||3===z?3:1]+ia[1]*b,t=t.renderData,P=ka.sampleElevation(A,z,t.geometryState.samplerData),I(t,A,z,P)}}b=1/Math.sqrt(m*m+f*f+q*q);m*=b;f*=b;q*=b};for(let b=0;4>b;++b){const n=b,t=(b+1)%4,A=0===b||1===b?1:0,z=0===b||3===b?1:0,P=Q.clamp(A,ea,oa),ia=Q.clamp(z,ha,ta),V=p[n],W=0===b||3===b?V.count-1:0,E=p[t],X=0===b||1===b?E.count-1:0,Z=v[b].cornerTiles;let ca=-1;for(let ma=0;4>ma;++ma){const ra=Z[ma];ra&&(-1===ca||0<Eb.compareTilesByLij(Z[ca],
ra))&&(ca=ma)}const fa=ca,da=Z[fa],Aa=da!==g;f=m=0;q=1;if(Aa){const ma=g.level-da.level,ra=2**ma,Oa=[da.lij[0]+ma,da.lij[1]*ra,da.lij[2]*ra],Ka=[Oa[1]+ra===g.lij[1],0===b&&(1===fa||0===fa&&da!==Z[3])||1===b&&(0===fa||1===fa&&da!==Z[2]),Oa[1]===g.lij[1]+1,2===b&&(3===fa||2===fa&&da!==Z[1])||3===b&&(2===fa||3===fa&&da!==Z[0])],Ea=Ka.reduce((qa,ja)=>qa+(ja?1:0),0);F.internalAssert(1===Ea||2===Ea);let xa=-1,Fa=-1;const La=da.renderData;if(1===Ea){const qa=Ka.findIndex(Ja=>Ja);F.internalAssert(0<=qa&&
3>=qa);xa=(qa+2)%4;const ja=a.geometryState.neighborData.edgeResolutions[qa];Fa=g.getNeighborEdgeStartVertexIndex(qa,da)*ja+ja*(0===qa&&0===b||1===qa&&0===b||2===qa&&1===b||3===qa&&3===b?1:0)}else{F.internalAssert(Ka[1]||Ka[3]);xa=Ka[1]?3:1;const qa=La.geometryState.neighborData.edgeResolutions[xa];Fa=0===b||3===b?0:qa}const Ga=La.geometryInfo.outerEdges[xa],Ma=V.index0+W*V.stride,Ra=E.index0+X*E.stride,Sa=Ga.index0+Fa*Ga.stride,Pa=Ga.attributes.position,Ta=Pa.typedBuffer,ya=Sa*Pa.typedBufferStride,
Na=a.localOrigin,Ha=Ga.localOrigin,za=Ta[ya+0]+Ha[0]-Na[0],va=Ta[ya+1]+Ha[1]-Na[1],Ua=Ta[ya+2]+Ha[2]-Na[2];Y.minMaxBoundingBox(za,va,Ua,B);const Wa=V.attributes.position,Qa=Wa.typedBuffer,Ya=Ma*Wa.typedBufferStride;Qa[Ya+0]=za;Qa[Ya+1]=va;Qa[Ya+2]=Ua;const $a=E.attributes.position,Xa=$a.typedBuffer,pa=Ra*$a.typedBufferStride;Xa[pa+0]=za;Xa[pa+1]=va;Xa[pa+2]=Ua;Y.encodeUVInBuffer(V.attributes.uv0,Ma,P,ia);Y.encodeUVInBuffer(E.attributes.uv0,Ra,P,ia);const Ca=Ga.attributes.normalCompressed.typedBuffer,
Da=Sa*Ga.attributes.normalCompressed.typedBufferStride,ab=V.attributes.normalCompressed,eb=ab.typedBuffer,bb=Ma*ab.typedBufferStride;eb[bb+0]=Ca[Da+0];eb[bb+1]=Ca[Da+1];const Ba=E.attributes.normalCompressed,sa=Ba.typedBuffer,Ia=Ra*Ba.typedBufferStride;sa[Ia+0]=Ca[Da+0];sa[Ia+1]=Ca[Da+1]}else{const ma=T[t];let ra=void 0;if(T[n]||ma){const xa=Q.clamp(S*(1-A)+y*A,ba,na),Fa=Q.clamp(c*(1-z)+K*z,la,aa);ra=ka.sampleElevation(xa,Fa,h.samplerData)}else ra=Jc(Z);k(A,z,ra);ua(b);const Oa=M-r[0],Ka=N-r[1],Ea=
C-r[2];Y.minMaxBoundingBox(Oa,Ka,Ea,B);V.setVertexFromValuesRawPositionUVNormal(W,Oa,Ka,Ea,P,ia,m,f,q);E.setVertexFromValuesRawPositionUVNormal(X,Oa,Ka,Ea,P,ia,m,f,q)}}for(let b=0;4>b;++b)Db[b]=null}function Jc(a){const h=a.reduce((p,B)=>Math.min(p,B?.level??Infinity),Infinity);F.ENABLE_TERRAIN_INTERNAL_CHECKS&&(F.internalAssert(!a[0]||!a[2]||Xb.isCornerNeighbor(a[0],a[2],ob.NeighborIndex.SOUTH_WEST)),F.internalAssert(!a[1]||!a[3]||Xb.isCornerNeighbor(a[1],a[3],ob.NeighborIndex.NORTH_WEST)));let r=
0,v=0;for(let p=0;4>p;++p){var d=a[p];if(d&&d.level===h){const B=d.extent;d=ka.sampleElevation(B[0===p||1===p?0:2],B[0===p||3===p?1:3],d.renderData?.geometryState?.samplerData);v+=d;r++}}a=r?v/r:0;F.internalAssert(null!=a);return a}function Lb(a){const h=a.geometryInfo.vertexAttributes.position.typedBuffer;a.vao.vertexBuffers.geometry.setSubData(h,0,0,h.length)}function $b(a,h,r){if(!h)return!1;a=Eb.compareTilesByLij(a,h);return 0<a||0===a&&2>r}const Vb=[[0,1],[1,0],[0,-1],[-1,0]],wa=new Ac.PatchGeometryLUT,
Kb=zc.fromValues(-Infinity,-Infinity,Infinity,Infinity),Db=[null,null,null,null];kb.createInternalVerticesPositionsSpherical=function(a){var h=a.geometryState,r=h.numVerticesPerSide;const v=r-2;--r;var d=a.geometryInfo,p=d.vertexAttributes,B=p.position;p=p.uv0;var g=a.tile,H=g.extent;const G=H[0],U=H[2],J=H[1];H=H[3];g=g.ellipsoid.radius;h=h.samplerData;var M=a.localOrigin;a=M[0];const N=M[1];M=M[2];d=d.boundingBox;const C=B.typedBuffer;B=B.typedBufferStride;let u=0;for(let e=1;e<=v;e++){const k=
e/r,m=J*(1-k)+H*k,f=wa.sinLatLUT[e],q=wa.cosLatLUT[e];for(let l=1;l<=v;l++){const I=l/r;var R=wa.sinLonLUT[l],O=wa.cosLonLUT[l],w=g+ka.sampleElevation(G*(1-I)+U*I,m,h);O=O*q*w-a;R=R*q*w-N;w=f*w-M;Y.minMaxBoundingBox(O,R,w,d);const D=u*B;C[D+0]=O;C[D+1]=R;C[D+2]=w;Y.encodeUVInBuffer(p,u,I,k);++u}}};kb.createPlanarGlobePatch=function(a,h){var r=a.tile.extent;h=a.geometryState;var v=r[0],d=r[1],p=r[2]-v,B=r[3]-d,g=h.clippingArea;r=Va.isSome(g)?Math.max(0,(g[0]-v)/p):0;const H=Va.isSome(g)?Math.max(0,
(g[1]-d)/B):0;v=Va.isSome(g)?Math.min(1,(g[2]-v)/p):1;d=Va.isSome(g)?Math.min(1,(g[3]-d)/B):1;p=h.numVerticesPerSide;B=(p-2)**2;g=h.neighborData.edgeResolutions.reduce((U,J)=>U+J+1,0);g=Y.acquireTerrainAttributes(B+g);const G=a.geometryInfo;Wb.empty(G.boundingBox);G.numVerticesPerSide=h.numVerticesPerSide;G.vertexAttributes=g;yc.set(G.uvRange,r,H,v,d);Ic(a);xc(a,B);uc(a);wc(G,h.numVerticesPerSide,[],[0,p-1],[0,p-1],h.wireframe);a.intersectionData=null};kb.createSphericalGlobePatch=function(a,h){const r=
a.tile,{extent:v,extentInRadians:d,surface:p}=r,B=a.localOrigin,g=a.geometryState;var H=p.isWebMercator;const G=p.shading||!0,U=g.numVerticesPerSide,J=U-1,M=(U-2)**2,N=H&&(h===ob.PatchType.HAS_SOUTH_POLE||h===ob.PatchType.HAS_BOTH_POLES),C=H&&(h===ob.PatchType.HAS_NORTH_POLE||h===ob.PatchType.HAS_BOTH_POLES);H=6*((N?1:0)+(C?1:0))*(J+1);h=g.neighborData;const u=h.edgeResolutions.reduce((k,m)=>k+m+1,0),R=Y.acquireTerrainAttributes(M+H+u);H=a.geometryInfo;H.numVerticesPerSide=g.numVerticesPerSide;H.vertexAttributes=
R;const O=H.boundingBox;Wb.empty(O);const w=Nb(a);wa.update(J,d,w);Bc(a);xc(a,M);Yb(a);const e=[];(()=>{let k=M+u;const m=B[0],f=B[1],q=B[2],l=r.ellipsoid.radius,I=v[1],D=v[3],L=(x,S)=>{S*=U;Y.minMaxBoundingBox(-m,-f,-q+x*l,O);e.push({connectedRowOffset:S,connectedOuterEdgeOffset:1===x?0:2,rowOffset:k,latitudeResolution:6});S=Math.PI/2-2*Math.atan(Math.exp(-(-1===x?I:D)/l));const y=x*Math.PI/2-S;x=.99*(1===x?1:-1);const c=l+0,K=R.position,T=R.uv0,ba=R.normalCompressed;for(let la=1;6>=la;++la){var na=
S+la/6*y;const aa=Math.cos(na);na=Math.sin(na);for(let ea=0;ea<=J;ea++){const ha=ea/J,oa=wa.cosLonLUT[ea]*aa,ta=wa.sinLonLUT[ea]*aa,ua=na,b=oa*c-m,n=ta*c-f,t=ua*c-q;Y.minMaxBoundingBox(b,n,t,O);K.setValues(k,b,n,t);Y.encodeUVInBuffer(T,k,ha,x);G&&Y.encodeNormalToBufferFromValues(ba,k,oa,ta,ua);++k}}};N&&L(-1,0);C&&L(1,J)})();wc(H,g.numVerticesPerSide,e,[0,U-1],[0,U-1],g.wireframe);a.intersectionData=null;if(F.ENABLE_TERRAIN_INTERNAL_CHECKS)for(a=0;4>a;++a)F.internalAssert(H.outerEdges[a].count===
h.edgeResolutions[a]+1)};kb.updateCornerSpherical=function(a){a.tile.intersectsClippingArea&&(Fb(a),Zb(a,!0),Lb(a))};kb.updateCornersPlanar=function(a,h){a.tile.intersectsClippingArea&&(Fb(a),vc(a,!0),Lb(a))};kb.updateEdgesAndCornersPlanar=function(a,h){a.tile.intersectsClippingArea&&(uc(a),Lb(a))};kb.updateEdgesAndCornersSpherical=function(a){a.tile.intersectsClippingArea&&(Yb(a),Lb(a))};Object.defineProperties(kb,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});