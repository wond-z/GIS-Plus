// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../chunks/_rollupPluginBabelHelpers ../../core/has ../../core/mathUtils ../../core/maybe ./checkWebGLError ./context-util ./enums ./capabilities/isWebGL2Context".split(" "),function(G,J,C,H,v,z,A,e,w){function B(f){return v.isSome(f)&&"type"in f&&"compressed"===f.type}function D(f){var n;if(n=v.isSome(f)&&!B(f))n=!(v.isSome(f)&&"byteLength"in f);return n}function x(f){return f===e.TextureType.TEXTURE_3D||f===e.TextureType.TEXTURE_2D_ARRAY}function I(f,n,a,b=1){n=Math.max(n,a);f===
e.TextureType.TEXTURE_3D&&(n=Math.max(n,b));return Math.round(Math.log(n)/Math.LN2)+1}const E={target:e.TextureType.TEXTURE_2D,samplingMode:e.TextureSamplingMode.LINEAR,wrapMode:e.TextureWrapMode.REPEAT,flipped:!1,hasMipmap:!1,isOpaque:!1,unpackAlignment:4,preMultiplyAlpha:!1,isImmutable:!1};C=function(){function f(a,b,c=null){this._context=a;this.type="texture";this._glName=null;this._wasImmutablyAllocated=this._wrapModeDirty=this._samplingModeDirty=!1;a.instanceCounter.increment(e.ResourceType.Texture,
this);this._descriptor={...E,...b};for(const d in E)void 0===this._descriptor[d]&&(this._descriptor[d]=E[d]);if(a.type!==A.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),x(this._descriptor.target)))throw Error("3D and array textures are not supported in WebGL1");this._descriptor.target===e.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(c):this.setData(c)}var n=f.prototype;n.dispose=function(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),
this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(e.ResourceType.Texture,this))};n.release=function(){this.dispose()};n.resize=function(a,b){const c=this._descriptor;if(c.width!==a||c.height!==b){if(this._wasImmutablyAllocated)throw Error("Immutable textures can't be resized!");c.width=a;c.height=b;this._descriptor.target===e.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}};n._setDataCubeMap=function(a=null){for(let b=
e.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;b<=e.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;b++)this._setData(a,b)};n.setData=function(a){this._setData(a)};n._setData=function(a,b){if(this._context&&this._context.gl){var c=this._context.gl;this._glName||(this._glName=c.createTexture());void 0===a&&(a=null);var d=this._descriptor,h=b??d.target,l=x(h);null===a&&(d.width=d.width||4,d.height=d.height||4,l&&(d.depth=d.depth??1));b=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(f.TEXTURE_UNIT_FOR_UPDATES);
f._validateTexture(this._context,d);this._configurePixelStorage();z.checkWebGLError(c);var k=d.pixelFormat,g=d.internalFormat??this._deriveInternalFormat(k,d.dataType);if(D(a)){k=a.width;let m=a.height;a instanceof HTMLVideoElement&&(k=a.videoWidth,m=a.videoHeight);d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,g,d.hasMipmap,k,m,1);this._texImage(h,0,g,k,m,1,a);z.checkWebGLError(c);d.hasMipmap&&this.generateMipmap();void 0===d.width&&(d.width=k);void 0===d.height&&(d.height=m);l&&
void 0===d.depth&&(d.depth=1)}else{const {width:m,height:p,depth:q}=d;if(null==m||null==p)throw Error("Width and height must be specified!");if(l&&null==q)throw Error("Depth must be specified!");d.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(h,g,d.hasMipmap,m,p,q);c.DEPTH24_STENCIL8&&g===c.DEPTH_STENCIL&&(g=c.DEPTH24_STENCIL8);if(B(a)){const r=a.levels;a=I(h,m,p,q);l=Math.min(a-1,r.length-1);w(c)?c.texParameteri(d.target,c.TEXTURE_MAX_LEVEL,l):d.hasMipmap=d.hasMipmap&&a===r.length;
const u=g;if(!(u in e.CompressedTextureFormat))throw Error("Attempting to use compressed data with an umcompressed format!");this._forEachMipmapLevel((t,y,F,K)=>{this._compressedTexImage(h,t,u,y,F,K,r[Math.min(t,r.length-1)])},l)}else v.isSome(a)?(this._texImage(h,0,g,m,p,q,a),z.checkWebGLError(c),d.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((r,u,t,y)=>{this._texImage(h,r,g,u,t,y,null);z.checkWebGLError(c)})}f._applySamplingMode(c,this._descriptor);f._applyWrapMode(c,this._descriptor);
f._applyAnisotropicFilteringParameters(this._context,this._descriptor);z.checkWebGLError(c);this._context.bindTexture(b,f.TEXTURE_UNIT_FOR_UPDATES)}};n.updateData=function(a,b,c,d,h,l,k=0){l||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const g=this._context.gl,m=this._descriptor,{pixelFormat:p,dataType:q,target:r,isImmutable:u}=m,t=m.internalFormat??this._deriveInternalFormat(p,q);if(u&&!this._wasImmutablyAllocated)throw Error("Cannot update immutable texture before allocation!");
const y=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES,!0);(0>b||0>c||d>m.width||h>m.height||b+d>m.width||c+h>m.height)&&console.error("An attempt to update out of bounds of the texture!");this._configurePixelStorage();if(k){if(!w(g)){console.error("Webgl2 must be enabled to use dataRowOffset!");return}g.pixelStorei(g.UNPACK_SKIP_ROWS,k)}D(l)?w(g)?g.texSubImage2D(r,a,b,c,d,h,p,q,l):g.texSubImage2D(r,a,b,c,p,q,l):B(l)?g.compressedTexSubImage2D(r,a,b,c,d,h,t,l.levels[a]):g.texSubImage2D(r,
a,b,c,d,h,p,q,l);if(k){if(!w(g)){console.error("Webgl2 must be enabled to use dataRowOffset!");return}g.pixelStorei(g.UNPACK_SKIP_ROWS,0)}this._context.bindTexture(y,f.TEXTURE_UNIT_FOR_UPDATES)};n.updateData3D=function(a,b,c,d,h,l,k,g){g||console.error("An attempt to use uninitialized data!");this._glName||console.error("An attempt to update uninitialized texture!");const m=this._context.gl;if(!w(m))throw Error("3D textures are not supported in WebGL1");const p=this._descriptor,{pixelFormat:q,dataType:r,
isImmutable:u,target:t}=p,y=p.internalFormat??this._deriveInternalFormat(q,r);if(u&&!this._wasImmutablyAllocated)throw Error("Cannot update immutable texture before allocation!");x(t)||console.warn("Attempting to set 3D texture data on a non-3D texture");const F=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(f.TEXTURE_UNIT_FOR_UPDATES);(0>b||0>c||0>d||h>p.width||l>p.height||k>p.depth||b+h>p.width||c+l>p.height||d+k>p.depth)&&console.error("An attempt to update out of bounds of the texture!");
this._configurePixelStorage();B(g)?(g=g.levels[a],m.compressedTexSubImage3D(t,a,b,c,d,h,l,k,y,g)):m.texSubImage3D(t,a,b,c,d,h,l,k,q,r,g);this._context.bindTexture(F,f.TEXTURE_UNIT_FOR_UPDATES)};n.generateMipmap=function(){const a=this._descriptor;if(!a.hasMipmap){if(this._wasImmutablyAllocated)throw Error("Cannot add mipmaps to immutable texture after allocation");this._samplingModeDirty=a.hasMipmap=!0;f._validateTexture(this._context,a)}a.samplingMode===e.TextureSamplingMode.LINEAR?(this._samplingModeDirty=
!0,a.samplingMode=e.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):a.samplingMode===e.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,a.samplingMode=e.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const b=this._context.bindTexture(this,f.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(f.TEXTURE_UNIT_FOR_UPDATES);this._context.gl.generateMipmap(a.target);this._context.bindTexture(b,f.TEXTURE_UNIT_FOR_UPDATES)};n.setSamplingMode=function(a){a!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=
a,this._samplingModeDirty=!0)};n.setWrapMode=function(a){a!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=a,f._validateTexture(this._context,this._descriptor),this._wrapModeDirty=!0)};n.applyChanges=function(){const a=this._context.gl,b=this._descriptor;this._samplingModeDirty&&(f._applySamplingMode(a,b),this._samplingModeDirty=!1);this._wrapModeDirty&&(f._applyWrapMode(a,b),this._wrapModeDirty=!1)};n._deriveInternalFormat=function(a,b){if(this._context.type===A.ContextType.WEBGL1)return a;
switch(b){case e.PixelType.FLOAT:switch(a){case e.PixelFormat.RGBA:return e.SizedPixelFormat.RGBA32F;case e.PixelFormat.RGB:return e.SizedPixelFormat.RGB32F;default:throw Error("Unable to derive format");}case e.PixelType.UNSIGNED_BYTE:switch(a){case e.PixelFormat.RGBA:return e.SizedPixelFormat.RGBA8;case e.PixelFormat.RGB:return e.SizedPixelFormat.RGB8}default:return a}};n._configurePixelStorage=function(){const a=this._context.gl,{unpackAlignment:b,flipped:c,preMultiplyAlpha:d}=this._descriptor;
a.pixelStorei(a.UNPACK_ALIGNMENT,b);a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,c?1:0);a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,d?1:0)};n._texStorage=function(a,b,c,d,h,l){const k=this._context.gl;if(!w(k))throw Error("Immutable textures are not supported in WebGL1");if(!(b in e.SizedPixelFormat))throw Error("Immutable textures must have a sized internal format");if(this._descriptor.isImmutable){c=c?I(a,d,h,l):1;if(x(a)){if(null==l)throw Error("Missing depth dimension for 3D texture upload");k.texStorage3D(a,
c,b,d,h,l)}else k.texStorage2D(a,c,b,d,h);this._wasImmutablyAllocated=!0}};n._texImage=function(a,b,c,d,h,l,k){const g=this._context.gl;let m=null;const p=this._context.type===A.ContextType.WEBGL2,q=x(a),{isImmutable:r,pixelFormat:u,dataType:t}=this._descriptor;p&&(m=g);if(!p&&D(k))g.texImage2D(a,0,c,u,t,k);else if(r){if(v.isSome(k))if(q){if(null==l)throw Error("Missing depth dimension for 3D texture upload");m.texSubImage3D(a,b,0,0,0,d,h,l,u,t,k)}else g.texSubImage2D(a,b,0,0,d,h,u,t,k)}else if(k=
v.unwrap(k),q){if(null==l)throw Error("Missing depth dimension for 3D texture upload");m.texImage3D(a,b,c,d,h,l,0,u,t,k)}else g.texImage2D(a,b,c,d,h,0,u,t,k)};n._compressedTexImage=function(a,b,c,d,h,l,k){const g=this._context.gl;let m=null;const p=x(a),q=this._descriptor.isImmutable;if(p){if(this._context.type!==A.ContextType.WEBGL2)throw Error("3D textures are not supported in WebGL1");m=g}if(q){if(v.isSome(k))if(p){if(null==l)throw Error("Missing depth dimension for 3D texture upload");m.compressedTexSubImage3D(a,
b,0,0,0,d,h,l,c,k)}else g.compressedTexSubImage2D(a,b,0,0,d,h,c,k)}else if(p){if(null==l)throw Error("Missing depth dimension for 3D texture upload");m.compressedTexImage3D(a,b,c,d,h,l,0,k)}else g.compressedTexImage2D(a,b,c,d,h,0,k)};n._forEachMipmapLevel=function(a,b=Infinity){let {width:c,height:d,depth:h,hasMipmap:l,target:k}=this._descriptor;const g=k===e.TextureType.TEXTURE_3D;if(null==c||null==d||g&&null==h)throw Error("Missing texture dimensions for mipmap calculation");for(let m=0;;++m){a(m,
c,d,h);if(!l||1===c&&1===d&&(!g||1===h)||m>=b)break;c=Math.max(1,c>>1);d=Math.max(1,d>>1);g&&(h=Math.max(1,h>>1))}};f._validateTexture=function(a,b){(null!=b.width&&0>b.width||null!=b.height&&0>b.height||null!=b.depth&&0>b.depth)&&console.error("Negative dimension parameters are not allowed!");a=w(a.gl);const c=null!=b.width&&H.isPowerOfTwo(b.width)&&null!=b.height&&H.isPowerOfTwo(b.height);a||!b.isImmutable&&!x(b.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!");
a||c||("number"===typeof b.wrapMode?b.wrapMode!==e.TextureWrapMode.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):(b.wrapMode.s!==e.TextureWrapMode.CLAMP_TO_EDGE||b.wrapMode.t!==e.TextureWrapMode.CLAMP_TO_EDGE)&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),b.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))};f._applySamplingMode=function(a,b){let c=b.samplingMode,d=b.samplingMode;if(c===
e.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||c===e.TextureSamplingMode.LINEAR_MIPMAP_LINEAR)c=e.TextureSamplingMode.LINEAR,b.hasMipmap||(d=e.TextureSamplingMode.LINEAR);else if(c===e.TextureSamplingMode.NEAREST_MIPMAP_NEAREST||c===e.TextureSamplingMode.NEAREST_MIPMAP_LINEAR)c=e.TextureSamplingMode.NEAREST,b.hasMipmap||(d=e.TextureSamplingMode.NEAREST);a.texParameteri(b.target,a.TEXTURE_MAG_FILTER,c);a.texParameteri(b.target,a.TEXTURE_MIN_FILTER,d)};f._applyWrapMode=function(a,b){"number"===typeof b.wrapMode?
(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode)):(a.texParameteri(b.target,a.TEXTURE_WRAP_S,b.wrapMode.s),a.texParameteri(b.target,a.TEXTURE_WRAP_T,b.wrapMode.t))};f._applyAnisotropicFilteringParameters=function(a,b){const c=a.capabilities.textureFilterAnisotropic;c&&a.gl.texParameterf(b.target,c.TEXTURE_MAX_ANISOTROPY,b.maxAnisotropy??1)};J._createClass(f,[{key:"glName",get:function(){return this._glName}},{key:"descriptor",get:function(){return this._descriptor}},
{key:"isDirty",get:function(){return this._samplingModeDirty||this._wrapModeDirty}}]);return f}();C.TEXTURE_UNIT_FOR_UPDATES=0;G.Texture=C;Object.defineProperties(G,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});