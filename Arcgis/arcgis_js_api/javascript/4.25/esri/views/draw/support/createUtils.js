// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../geometry ../../../core/arrayUtils ../../../core/lang ../../../core/maybe ../../../core/unitUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/Circle ../../../geometry/geometryEngine ../../../geometry/support/coordsUtils ../../../geometry/support/spatialReferenceUtils ./surfaceCoordinateSystems ../../../geometry/Point ../../../geometry/Multipoint ../../../geometry/Polyline ../../../geometry/Polygon".split(" "),function(m,O,E,F,l,G,H,z,I,A,u,B,g,J,K,L,M){function n(a,
c){c=new J({x:a[0],y:a[1],spatialReference:c});2<a.length&&(c.z=a[2]);return c}function r(a,c,d,e=!0){a=F.clone(a);a.forEach(b=>{E.equals(b[0],b[b.length-1])&&1!==b.length||b.push(b[0])});a=new M({rings:a,spatialReference:c});a.rings.forEach(b=>{u.isClockwise(b,!1,!1)||b.reverse()});d&&u.unnormalizeGeometryOnDatelineCrossing(a);e&&a.isSelfIntersecting&&B.isValid(c)&&(a=A.simplify(a));return a}function C(a,c,d){const e=v(c[3],c[2],d),b=v(c[1],c[2],d),f=v(c[0],c[1],d);c=v(c[0],c[3],d);return{geometry:a,
midpoints:l.isSome(e)&&l.isSome(b)&&l.isSome(f)&&l.isSome(c)?{top:e,right:b,bottom:f,left:c}:null}}function v(a,c,d){p[0]=a.x;p[1]=a.y;p[2]=0;q[0]=c.x;q[1]=c.y;q[2]=0;H.lerp(p,p,q,.5);w.x=p[0];w.y=q[1];w.z=q[2];a=d.localToMap(w);return l.isSome(a)?n(a,d.spatialReference):null}const w=g.makeSurfacePoint(0,0,0),p=z.create(),q=z.create();m.createCircle=function(a,c,d,e){var b=c.mapToLocalMultiple(a),f=a=null;d?(a=b[0],f=b[1]):(a=b[0],d=b[1],f=Math.round(d.x-a.x),d=Math.round(d.y-a.y),b=Math.max(Math.abs(f),
Math.abs(d)),a=g.makeSurfacePoint(0<f?a.x+b/2:a.x-b/2,0<d?a.y+b/2:a.y-b/2),f=g.makeSurfacePoint(Math.abs(f)>Math.abs(d)?a.x-b/2:a.x,Math.abs(f)>Math.abs(d)?a.y:a.y-b/2));d=c.localToMap(a);b=c.localToMap(f);if(l.isNone(d)||l.isNone(b))return null;c.doUnnormalization&&u.unnormalizeVerticesOnDatelineCrossing([[d,b]],c.spatialReference);d=n(d,c.spatialReference);b=n(b,c.spatialReference);const h=G.getMetersPerUnitForSR(c.spatialReference);var k=0;B.isValid(c.spatialReference)?k=h*A.distance(d,b,null):
(k=a.x-f.x,a=a.y-f.y,k=h*Math.sqrt(k*k+a*a)*(e||1));c=new I({center:d,radius:k,radiusUnit:"meters",spatialReference:c.spatialReference});return{geometry:r(c.rings,c.spatialReference,!1),center:d,edge:b}};m.createEllipse=function(a,c,d){function e(x){return g.makeSurfacePoint(k*Math.cos(x)+h.x,y*Math.sin(x)+h.y)}var b=c.mapToLocalMultiple(a);a=b[0];var f=b[1];b=Math.round(f.x-a.x);f=Math.round(f.y-a.y);const h=g.makeSurfacePoint(d?a.x:a.x+b/2,d?a.y:a.y+f/2),k=d?b:b/2,y=d?f:f/2;d=[];a=2*Math.PI/60;
for(b=0;60>b;b++)d.push(e(b*a));d.push(d[0]);const {spatialReference:t,doUnnormalization:N}=c;d=r([l.filterNones(d.map(x=>c.localToMap(x)))],t,N,!1);a=c.localToMap(e(Math.PI/2));b=c.localToMap(e(0));f=c.localToMap(e(-Math.PI/2));const D=c.localToMap(e(Math.PI));return{geometry:d,midpoints:l.isSome(a)&&l.isSome(b)&&l.isSome(f)&&l.isSome(D)?{top:n(a,t),right:n(b,t),bottom:n(f,t),left:n(D,t)}:null}};m.createMultipoint=function(a,c){return new K({points:a,spatialReference:c})};m.createPoint=n;m.createPolygon=
r;m.createPolyline=function(a,c,d){a=new L({paths:a,spatialReference:c});d&&u.unnormalizeGeometryOnDatelineCrossing(a);return a};m.createRectangle=function(a,c,d){var e=c.mapToLocalMultiple(a);1===e.length&&(a=e[0],e=[g.makeSurfacePoint(a.x-48,a.y+48),g.makeSurfacePoint(a.x+48,a.y-48),g.makeSurfacePoint(a.x+48,a.y-48),g.makeSurfacePoint(a.x-48,a.y+48)]);a=[];var b=e[0].x,f=e[0].y,h=e[1].x;e=e[1].y;if(d){d=Math.round(h-b);const k=Math.round(e-f);a.push(g.makeSurfacePoint(b-d,f-k),g.makeSurfacePoint(h,
f-k),g.makeSurfacePoint(h,e),g.makeSurfacePoint(b-d,e))}else a.push(g.makeSurfacePoint(b,f),g.makeSurfacePoint(h,f),g.makeSurfacePoint(h,e),g.makeSurfacePoint(b,e));d=r([l.filterNones(a.map(k=>c.localToMap(k)))],c.spatialReference,c.doUnnormalization,!0);return C(d,a,c)};m.createSquare=function(a,c,d){var e=c.mapToLocalMultiple(a);a=[];var b=e[0].x,f=e[0].y,h=Math.round(e[1].x-b);const k=Math.round(e[1].y-f);e=Math.max(Math.abs(h),Math.abs(k));d?(d=b+e,h=f+e,b-=e,f-=e,a.push(g.makeSurfacePoint(d,
f),g.makeSurfacePoint(b,f),g.makeSurfacePoint(b,h),g.makeSurfacePoint(d,h))):(d=0<h?b+e:b-e,e=0<k?f+e:f-e,a.push(g.makeSurfacePoint(b,f),g.makeSurfacePoint(d,f),g.makeSurfacePoint(d,e),g.makeSurfacePoint(b,e)));f=r([l.filterNones(a.map(y=>c.localToMap(y)))],c.spatialReference,c.doUnnormalization,!0);return C(f,a,c)};Object.defineProperties(m,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});