// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/mathUtils ../../../../core/maybe ../../../../chunks/vec2 ../../../../chunks/vec2f64 ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/plane ../../../../geometry/support/vector ../../../support/geometry2dUtils".split(" "),function(q,z,A,l,u,r,c,g,h,w,x){let B=function(){function k(a,b,d,f=0,m=t.IMMEDIATE){this._helper=a;this._planeType=b;this._edge=d;this.distance=f;this._plane=h.create();this._offsetPlane=
h.create();this._minDistance=-Infinity;this._maxDistance=Infinity;this._selectedArrow=1;m===t.IMMEDIATE&&this._initialize()}var e=k.prototype;e._initialize=function(){this._initializeNeighbors();this._initializePlane();this._initializeDistanceConstraints()};e._initializeNeighbors=function(){const a=this._toXYZ(this._edge.leftVertex.pos),b=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),d=this._toXYZ(this._edge.rightVertex.pos),f=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);
this._edgeDirection=c.direction(g.create(),a,d);this._left=this._computeNeighbor(a,b,this._edgeDirection);this._right=this._computeNeighbor(d,f,this._edgeDirection)};e._toXYZ=function(a){return l.isSome(a)?this._helper.toXYZ(a):null};e._pointToXYZ=function(a){return this._toXYZ(this._helper.pointToVector(a))};e._computeNeighbor=function(a,b,d){if(l.isNone(b))return{start:a,end:b,direction:g.fromValues(-d[1],d[0],0),isOriginalDirection:!0};const f=c.direction(g.create(),a,b),m=!this._passesBisectingAngleThreshold(f,
d);return{start:a,end:b,direction:m?this._bisectVectorsPerpendicular(d,f):f,isOriginalDirection:!m}};e._passesBisectingAngleThreshold=function(a,b){a=Math.abs(w.angle(b,a));return a>=y&&a<=Math.PI-y};e._bisectVectorsPerpendicular=function(a,b){a=0>c.dot(a,b)?a:c.negate(g.create(),a);const d=Math.abs(c.dot(a,b));if(!(.001>d||.999<d))return this._bisectDirection(a,b);b=c.cross(g.create(),a,[0,0,1]);return c.normalize(b,b)};e._bisectDirection=function(a,b){a=c.add(g.create(),a,b);return c.normalize(a,
a)};e._initializePlane=function(){const a=this._computeNormalDirection(this._left),b=this._computeNormalDirection(this._right);0>c.dot(a,b)&&c.negate(b,b);h.fromPositionAndNormal(this._left.start,this._bisectDirection(a,b),this._plane)};e._computeNormalDirection=function(a){a=c.cross(g.create(),a.direction,this._edgeDirection);c.normalize(a,a);a=c.cross(g.create(),this._edgeDirection,a);this._planeType===q.PlaneType.XY&&(a[2]=0);return c.normalize(a,a)};e._initializeDistanceConstraints=function(){l.isSome(this._left.end)&&
!this.requiresSplitEdgeLeft&&this._updateDistanceConstraint(h.signedDistance(this._plane,this._left.end));l.isSome(this._right.end)&&!this.requiresSplitEdgeRight&&this._updateDistanceConstraint(h.signedDistance(this._plane,this._right.end));this._updateIntersectDistanceConstraint(this._plane)};e._updateDistanceConstraint=function(a){0>=a&&(this._minDistance=Math.max(this._minDistance,a));0<=a&&(this._maxDistance=Math.min(this._maxDistance,a))};e._updateIntersectDistanceConstraint=function(a){var b=
h.normal(a);const d=this._edgeDirection;var f=c.add(g.create(),this._left.start,this._left.direction);const m=c.add(g.create(),this._right.start,this._right.direction);var n=this._pointInBasis2D(r.create(),b,d,this._left.start),p=this._pointInBasis2D(r.create(),b,d,f),v=this._pointInBasis2D(r.create(),b,d,this._right.start);b=this._pointInBasis2D(r.create(),b,d,m);[v]=x.intersectLineAndRay({start:p,end:n,type:x.LineType.LINE},{start:b,end:v,type:x.LineType.LINE});v&&(n=u.subtract(r.create(),n,p),
u.normalize(n,n),p=u.subtract(r.create(),v,p),p=u.dot(n,p),f=c.add(g.create(),f,c.scale(g.create(),this._left.direction,-p)),a=h.signedDistance(a,f),this._updateDistanceConstraint(a))};e._pointInBasis2D=function(a,b,d,f){a[0]=w.projectPointSignedLength(b,f);a[1]=w.projectPointSignedLength(d,f);return a};e._offset=function(a,b){Number.isFinite(this._minDistance)&&(b=Math.max(this._minDistance,b));Number.isFinite(this._maxDistance)&&(b=Math.min(this._maxDistance,b));h.copy(this._offsetPlane,this._plane);
this._offsetPlane[3]-=b;b=(f,m,n)=>l.isSome(m)&&h.intersectLine(this._offsetPlane,f,c.add(g.create(),f,m),n);const d=g.create();(a===this._edge.leftVertex?b(this._left.start,this._left.direction,d):b(this._right.start,this._right.direction,d))&&this._helper.copy(this._helper.fromXYZ(d,void 0,this._helper.getM(a.pos)),a.pos)};e.selectArrowFromStartPoint=function(a){this._selectedArrow=h.isPointInside(this.plane,this._pointToXYZ(a))?1:-1};e.signedDistanceToPoint=function(a){return h.signedDistance(this.plane,
this._pointToXYZ(a))};e.apply=function(a){this._offset(a,this.distance)};e.undo=function(a){this._offset(a,0)};e.canAccumulate=function(a){return a instanceof k&&this._edge.leftVertex.index===a._edge.leftVertex.index&&this._edge.rightVertex.index===a._edge.rightVertex.index&&this._edge.component===a._edge.component&&this._maybeEqualsVec3(this._left.direction,a._left.direction)&&this._maybeEqualsVec3(this._right.direction,a._right.direction)&&c.equals(h.normal(this._plane),h.normal(a._plane))};e.accumulate=
function(a,b){this._offset(a,this._plane[3]-b._plane[3]+b.distance)};e.accumulateParams=function(a){this.distance=a.distance-a._plane[3]+this._plane[3]};e.clone=function(){const a=new k(this._helper,this._planeType,this._edge,this.distance,t.DEFERRED);h.copy(a._plane,this._plane);h.copy(a._offsetPlane,this._offsetPlane);a._maxDistance=this._maxDistance;a._minDistance=this._minDistance;a._left=this._cloneNeighbor(this._left);a._right=this._cloneNeighbor(this._right);a._edgeDirection=c.copy(g.create(),
this._edgeDirection);return a};e._maybeEqualsVec3=function(a,b){return l.isNone(a)&&l.isNone(b)||l.isSome(a)&&l.isSome(b)&&c.equals(a,b)};e._cloneNeighbor=function({start:a,end:b,direction:d,isOriginalDirection:f}){return{start:c.copy(g.create(),a),end:l.isSome(b)?c.copy(g.create(),b):null,direction:c.copy(g.create(),d),isOriginalDirection:f}};z._createClass(k,[{key:"plane",get:function(){return this._plane}},{key:"requiresSplitEdgeLeft",get:function(){return!this._left.isOriginalDirection}},{key:"requiresSplitEdgeRight",
get:function(){return!this._right.isOriginalDirection}},{key:"edgeDirection",get:function(){return this._edgeDirection}},{key:"selectedArrow",get:function(){return this._selectedArrow}}]);return k}();const y=A.deg2rad(15);q.PlaneType=void 0;(function(k){k[k.XYZ=0]="XYZ";k[k.XY=1]="XY"})(q.PlaneType||(q.PlaneType={}));var t;(function(k){k[k.IMMEDIATE=0]="IMMEDIATE";k[k.DEFERRED=1]="DEFERRED"})(t||(t={}));q.OffsetEdgeVertex=B;Object.defineProperties(q,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});