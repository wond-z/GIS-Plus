// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/Error ../../../../core/has ../../../../core/Logger ../../../../core/maybe ../../../../core/screenUtils ../../../../core/sql ../../../../core/accessorSupport/diffUtils ../../../../layers/support/labelingInfo ../../engine/webgl/enums ../../engine/webgl/Utils ../../engine/webgl/techniques/utils ../../engine/webgl/util/vvFlagUtils ./createSymbolSchema ./support/pixelBuffering ./support/rendererUtils ../support/clusterUtils ../support/util".split(" "),function(t,l,T,U,
m,I,V,W,J,q,X,Y,Z,p,aa,D,K,L){function B(a,b){let c=0,d=0,e=q.WGLSymbologyType.DEFAULT;if(m.isSome(a)){d=aa.getPtMaxVVSize(a,b);"visualVariables"in a&&(c=Z.getVVFlags(a.visualVariables||[]),"dot-density"===a.type&&(e=q.WGLSymbologyType.DOT_DENSITY));"heatmap"===a.type&&(e=q.WGLSymbologyType.HEATMAP);if("dictionary"===a.type)return{maxVVSize:d,vvFlags:c,symbologyType:q.WGLSymbologyType.DEFAULT};if("pie-chart"===a.type)return{maxVVSize:d,vvFlags:c,symbologyType:q.WGLSymbologyType.PIE_CHART};if(e!==
q.WGLSymbologyType.DOT_DENSITY&&e!==q.WGLSymbologyType.HEATMAP){var f=a.getSymbols();"backgroundFillSymbol"in a&&a.backgroundFillSymbol&&f.push(a.backgroundFillSymbol);b=a=!0;for(const g of f)if("cim"===g.type&&(b=!1),"simple-fill"===g.type||"picture-fill"===g.type){f=(f=g.outline)&&"none"!==f.style&&"solid"!==f.style;var h="simple-fill"===g.type&&"none"!==g.style&&"solid"!==g.style;h="picture-fill"===g.type||h||f;f&&(a=!1);h&&(b=!1)}a?e=b?q.WGLSymbologyType.OUTLINE_FILL_SIMPLE:q.WGLSymbologyType.OUTLINE_FILL:
b&&(e=q.WGLSymbologyType.SIMPLE)}}return{vvFlags:c,maxVVSize:d,symbologyType:e}}function M(a,b=!1){try{const d=ba(a,b);var c="heatmap"===a.renderer?.type&&"raster"===D.getSupportedHeatmapRenderer()?{type:"heatmap"}:{type:"symbol"};const e={};d.map(h=>ca(e,a,h));const f=m.isSome(a.subtypeCode)?`${a.subtypeField} = ${a.subtypeCode}`:null;return{source:{definitionExpression:V.sqlAnd(a.definitionExpression,f),fields:a.fields.map(h=>h.toJSON()),gdbVersion:a.gdbVersion,historicMoment:a.historicMoment?.getTime(),
outFields:a.availableFields,pixelBuffer:a.pixelBuffer,spatialReference:a.spatialReference.toJSON(),timeExtent:a.timeExtent?.toJSON(),customParameters:a.customParameters},attributes:{fields:{},indexCount:0},processors:d,tileRenderer:c,targets:e}}catch(d){if("ValidationError"===d.fieldName)return y.error(d),null;throw d;}}function ca(a,b,c){switch(c.target){case "feature":E(a,F(b),c);break;case "aggregate":if("featureReduction"in b){var d=b.featureReduction;switch(d.type){case "selection":throw new l("ValidationError",
"Mapview does not support `selection` reduction type",d);case "binning":E(a,F(b),c);da(a,d,b.fields.map(e=>e.toJSON()),c);break;case "cluster":E(a,F(b),c),ea(a,d,b.fields.map(e=>e.toJSON()),c)}}}}function G(a,b){for(const c in b){const d=b[c];if(d.target!==a.name)continue;const e=a.attributes[c];e?(e.context.mesh=e.context.mesh||d.context.mesh,e.context.storage=e.context.storage||d.context.storage):a.attributes[c]=d}return a}function F(a){return[m.unwrap(a.filter)?.toJSON()??null,m.unwrap(m.unwrap(a.featureEffect)?.filter)?.toJSON()??
null]}function E(a,b,c){a.feature||(a.feature={name:"feature",input:"source",filters:b,attributes:{}});G(a.feature,c.attributes.fields);return a}function N(a,b){const {onStatisticExpression:c,onStatisticField:d,statisticType:e}=a;switch(e){case "min":case "max":case "avg":case "avg_angle":case "sum":case "count":return"esriFieldTypeDouble";case "mode":if(c)return{returnType:b}=c,b?"string"===b?"esriFieldTypeString":"esriFieldTypeDouble":(y.error(new l("ValidationError","Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",
a)),"esriFieldTypeString");b=b.find(f=>f.name===d);return b?b.type:(y.error(new l("ValidationError","Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",a)),"esriFieldTypeString")}}function da(a,b,c,d){a.aggregate||(a.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:b.fixedBinLevel,fields:(b.fields??[]).map(e=>({...e.toJSON(),type:N(e,c)}))},attributes:{}});G(a.aggregate,d.attributes.fields);return a}function ea(a,
b,c,d){a.aggregate||(a.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:I.pt2px(b.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(I.pt2px(b.clusterMaxSize)/64),fields:(b.fields??[])?.map(e=>({...e.toJSON(),type:N(e,c)}))}});G(a.aggregate,d.attributes.fields);return a}function r(a,b){return b.field?u(a,{...b,type:"field",field:b.field}):b.valueExpression?u(a,{...b,type:"expression",valueExpression:b.valueExpression}):{field:null,fieldIndex:null}}
function u(a,b){switch(b.type){case "expression":var c=b.valueExpression;if(!a.fields[c]){var d=a.indexCount++;a.fields[c]={...b,name:c,fieldIndex:d}}return{fieldIndex:a.fields[c].fieldIndex};case "label-expression":return c=JSON.stringify(b.label),a.fields[c]||(d=a.indexCount++,a.fields[c]={...b,name:c,fieldIndex:d}),{fieldIndex:a.fields[c].fieldIndex};case "field":c=b.field;if("aggregate"===b.target&&a.fields[c])return{field:c};a.fields[c]={...b,name:c};return{field:c};case "statistic":return a.fields[b.name]=
{...b},{field:b.name}}}function ba(a,b=!1){const c=[];let d=0;c.push(fa(a,d++,b));return c}function H(a,b,c,d,e,f=!1){a=u(a,{type:"label-expression",target:c,context:{mesh:!0},resultType:"string",label:{labelExpression:b.labelExpression,labelExpressionInfo:b.labelExpressionInfo?{expression:b.labelExpressionInfo.expression}:null,symbol:!!b.symbol,where:b.where}});({fieldIndex:a}=a);return{...p.createSymbolSchema(b,e,f),fieldIndex:a,target:c,index:d}}function ha(a,b,c){const d="featureReduction"in b&&
b.featureReduction;if(!d)return{fields:[],labels:[],matcher:null,rendererOverride:null};const e=[];let f=null,h=L.toJSONGeometryType(b.geometryType),g=[];var k=null;if(d)switch(d.type){case "selection":return y.error(new l("ValidationError","Mapview does not support `selection` reduction type",d)),{fields:[],labels:[],matcher:null,rendererOverride:null};case "cluster":case "binning":e.push(...(d.fields??[])),"cluster"===d.type?h="esriGeometryPoint":"binning"===d.type&&(h="esriGeometryPolygon"),d.renderer&&
!d.renderer.authoringInfo?.isAutoGenerated?("cluster"===d.type?{renderer:k}=K.injectDynamicLevelDependentSizeVisualVariable(d.renderer,d,null):k=d.renderer,b=B(d.renderer,d),f=C(null,"aggregate",d.renderer,b,c),g=d&&d.labelsVisible&&d.labelingInfo||[]):"cluster"===d.type&&(k=K.createClusterRenderer(e,b.renderer,d,null,!0),d.symbol&&(b=B(k,d),f={type:"simple",symbol:p.createSymbolSchema(d.symbol,b,c),symbologyType:b.symbologyType}),g=d&&d.labelsVisible&&d.labelingInfo||[])}O(a,e);return{labels:J.validateLabelingInfo(g,
"binning"===d.type?"esriGeometryPolygon":h),matcher:f,fields:e,rendererOverride:k}}function fa(a,b,c=!1){const d={indexCount:0,fields:{}};var e="featureReduction"in a&&a.featureReduction;b=e?"aggregate":"feature";if("sublayers"in a){var f={type:"subtype",subtypeField:a.subtypeField,renderers:{},symbologyType:q.WGLSymbologyType.DEFAULT},h={type:"subtype",mapping:{},target:"feature"},g={type:"subtype",classes:{}},k={type:"symbol",target:"feature",aggregateFields:[],attributes:d,storage:h,mesh:{matcher:f,
aggregateMatcher:null,labels:g,sortKey:null}};e=new Set;let v=0;for(const {renderer:w,subtypeCode:x,labelingInfo:ia,labelsVisible:ja}of a.sublayers){const P={symbologyType:q.WGLSymbologyType.DEFAULT,vvFlags:0,maxVVSize:0};a=C(d,b,w,P,c);const A=Q(d,b,w),R=ja&&ia;if("visualVariables"in w&&w.visualVariables&&w.visualVariables.length)throw new l("ValidationError","Visual variables are currently not supported for subtype layers");if("dictionary"===a.type)throw new l("ValidationError","Dictionary renderer is not supported in subtype layers");
if("subtype"===a.type)throw new l("ValidationError","Nested subtype renderers is not supported");if(m.isSome(A)&&"subtype"===A.type)throw new l("ValidationError","Nested subtype storage is not supported");if(m.isSome(A)&&m.isSome(A.attributeMapping))throw new l("ValidationError","Non-visual-variable attributes are not supported in subtype layers");if("heatmap"===a.type)throw new l("ValidationError","Heatmaps are not supported in subtype layers");if("pie-chart"===a.type)throw new l("ValidationError",
"Pie-charts are not supported in subtype layers");if(e.has(x))throw new l("ValidationError","Subtype codes for sublayers must be unique");e.add(x);f.renderers[x]=a;h.mapping[x]=A;R&&(g.classes[x]=R.map(ka=>H(d,ka,"feature",v++,P,c)))}return k}if("heatmap"===a.renderer.type&&"raster"===D.getSupportedHeatmapRenderer()){const {radius:v,fieldOffset:w,field:x}=a.renderer;return{type:"heatmap",aggregateFields:[],attributes:d,target:b,storage:null,mesh:{radius:v,fieldOffset:w,field:r(d,{target:b,field:x,
resultType:"numeric"}).field}}}f=ha(d,a,c);g=L.toJSONGeometryType(a.geometryType);k=f.rendererOverride??a.renderer;const n=B(k,e);h=C(d,b,k,n,c);k=Q(d,b,k);e=la(d,a.orderBy,e);let z=0;a=[...J.validateLabelingInfo(a.labelsVisible&&a.labelingInfo||[],g).map(v=>H(d,v,"feature",z++,n,c)),...f.labels.map(v=>H(d,v,"aggregate",z++,n,c))];return{type:"symbol",target:b,attributes:d,aggregateFields:f.fields,storage:k,mesh:{matcher:h,labels:{type:"simple",classes:a},aggregateMatcher:f.matcher,sortKey:e}}}function la(a,
b,c){if(m.isSome(c)||m.isNone(b)||!b.length)return null;1<b.length&&y.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${b.length}. All but the first will be discarded`);b=b[0];c="ascending"===b.order?"asc":"desc";if(b.field)return{field:b.field,order:c};if(b.valueExpression)return{fieldIndex:u(a,{type:"expression",target:"feature",valueExpression:b.valueExpression,resultType:"numeric"}).fieldIndex,order:c};y.error(new l("ValidationError","Expected to find a field or valueExpression for OrderByInfo",
b));return null}function O(a,b){const c={mesh:!0,storage:!0};for(const d of b){const {name:e,onStatisticField:f,onStatisticExpression:h,statisticType:g}=d;let k=b=null;h?k=u(a,{type:"expression",target:"feature",valueExpression:h.expression,resultType:"numeric"}).fieldIndex:b=u(a,{type:"field",target:"feature",field:f,resultType:"numeric"}).field;u(a,{type:"statistic",target:"aggregate",name:e,context:c,inField:b,inFieldIndex:k,statisticType:g})}}function Q(a,b,c){let d;switch(c.type){case "simple":case "class-breaks":case "unique-value":case "dictionary":d=
{visualVariables:!0,attributes:null};break;default:d=Y.getTechniqueFromRenderer(c).getStorageSpec(c)}return ma(a,b,d,c)}function ma(a,b,c,d){if(m.isNone(c))return null;const {visualVariables:e,attributes:f}=c;c=null;e&&"visualVariables"in d&&(c=na(a,b,d.visualVariables));const h=m.isSome(c)?4:0;d=null;m.isSome(f)&&(d=f.map((g,k)=>{const {field:n,fieldIndex:z}=r(a,{valueExpression:g.valueExpression,field:g.field,resultType:"numeric",target:b});return{binding:k+h,field:n,fieldIndex:z}}));return{type:"simple",
target:b,attributeMapping:d,vvMapping:c}}function na(a,b,c){if(!c||!c.length)return[];const d={storage:!0};return D.simplifyVisualVariables(c).map(e=>{const f=X.getVVType(e.type),{field:h,fieldIndex:g}=r(a,{target:b,valueExpression:e.valueExpression,field:e.field,context:d,resultType:"numeric"});switch(e.type){case "size":return"$view.scale"===e.valueExpression?null:{type:"size",binding:f,field:h,fieldIndex:g,normalizationField:r(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field,
valueRepresentation:e.valueRepresentation??null};case "color":return{type:"color",binding:f,field:h,fieldIndex:g,normalizationField:r(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field};case "opacity":return{type:"opacity",binding:f,field:h,fieldIndex:g,normalizationField:r(a,{target:b,field:e.normalizationField,context:d,resultType:"numeric"}).field};case "rotation":return{type:"rotation",binding:f,field:h,fieldIndex:g}}}).filter(e=>e)}function C(a,b,c,d,e=!1){a=m.unwrapOr(a,
{indexCount:0,fields:{}});switch(c.type){case "simple":case "dot-density":return oa(a,c,d,e);case "class-breaks":return pa(a,b,c,d,e);case "unique-value":return qa(a,b,c,d,e);case "dictionary":return{type:"dictionary",config:c.config,fieldMap:c.fieldMap,scaleExpression:c.scaleExpression,url:c.url,symbolOptions:d,symbologyType:d.symbologyType};case "heatmap":return ra(a,c,d,e);case "pie-chart":return sa(a,c,d,e)}}function oa(a,b,c,d=!1){a=b.getSymbols();return{type:"simple",symbol:p.createSymbolSchema(a.length?
a[0]:null,c,d),symbologyType:c.symbologyType}}function sa(a,b,c,d=!1){a=b.getSymbols();b=1<a.length?a[1]:null;return{type:"pie-chart",markerSymbol:p.createSymbolSchema(a[0],c,d),fillSymbol:p.createSymbolSchema(b,c,d),symbologyType:c.symbologyType}}function pa(a,b,c,d,e=!1){const f=c.backgroundFillSymbol,{field:h,fieldIndex:g}=r(a,{target:b,field:c.field,valueExpression:c.valueExpression,resultType:"numeric",context:{mesh:!0,use:"renderer.field"}});b=c.normalizationType;b="log"===b?"esriNormalizeByLog":
"percent-of-total"===b?"esriNormalizeByPercentOfTotal":"field"===b?"esriNormalizeByField":null;const k=c.classBreakInfos.map(n=>({symbol:p.createSymbolSchema(n.symbol,d,e),min:n.minValue,max:n.maxValue})).sort((n,z)=>n.min-z.min);return{type:"interval",attributes:a.fields,field:h,fieldIndex:g,backgroundFillSymbol:p.createSymbolSchema(f,d,e),defaultSymbol:p.createSymbolSchema(c.defaultSymbol,d,e),intervals:k,normalizationField:c.normalizationField,normalizationTotal:c.normalizationTotal,normalizationType:b,
isMaxInclusive:c.isMaxInclusive,symbologyType:d.symbologyType}}function qa(a,b,c,d,e=!1){const f=[],h=c.backgroundFillSymbol;b={target:b,context:{mesh:!0},resultType:"string"};if(c.field&&"string"!==typeof c.field)throw new l("ValidationError","Expected renderer.field to be a string",c);const {field:g,fieldIndex:k}=r(a,{...b,field:c.field,valueExpression:c.valueExpression});for(const n of c.uniqueValueInfos)f.push({value:""+n.value,symbol:p.createSymbolSchema(n.symbol,d,e)});return{type:"map",attributes:a.fields,
field:g,fieldIndex:k,field2:r(a,{...b,field:c.field2}).field,field3:r(a,{...b,field:c.field3}).field,fieldDelimiter:c.fieldDelimiter,backgroundFillSymbol:p.createSymbolSchema(h,d),defaultSymbol:p.createSymbolSchema(c.defaultSymbol,d),map:f,symbologyType:d.symbologyType}}function ra(a,b,c,d=!1){a=b.getSymbols();return{type:"heatmap",symbol:p.createSymbolSchema(a.length?a[0]:null,c,d),symbologyType:c.symbologyType}}const y=U.getLogger("esri.views.2d.layers.features.schemaUtils");let S=null;t.createSymbolSchema=
p.createSymbolSchema;t.addAggregateFields=O;t.createMatcherSchema=C;t.createRendererAttributeSchema=r;t.createSchema=function(a){if(T("esri-2d-update-debug")){const b=M(a,!0);console.debug("Created new schema",b);console.debug("Schema diff",W.diff(S,b));S=b}return M(a)};t.createSymbolSchemaOptions=B;Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});