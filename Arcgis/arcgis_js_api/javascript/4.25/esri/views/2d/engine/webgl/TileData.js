// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ./enums ./MemoryRequirements ./TileBufferData ./TileDisplayData ./Utils ./WGLDisplayRecord ./cpuMapped/DisplayRecordReader ./mesh/VertexBuffer ./mesh/VertexVector ./util/Writer".split(" "),function(y,B,C,t,w,z,u,A,D,E,F,G){const v=new t,n=new t;t=function(){function l(){this.tileBufferData=this.tileDisplayData=null}var q=l.prototype;q.reshuffle=function(){v.reset();const b=[[],[],[],[],[]];var c=this.tileDisplayData.displayObjects;for(var a of c)for(var d of a.displayRecords)b[d.geometryType].push(d);
for(var f of b)for(var h of f)h&&v.needMore(h.geometryType,h.meshData?h.meshData.vertexCount:h.vertexCount,h.meshData?h.meshData.indexData.length:h.indexCount);c=b.length;a=new w;for(d=0;d<c;++d){a.geometries[d].indexBuffer=new Uint32Array(Math.round(1.5*v.indicesFor(d)));f=[];for(var e in this.tileBufferData.geometries[d].vertexBuffer)f.push(this.tileBufferData.geometries[d].vertexBuffer[e].stride);f=l._computeVertexAlignment(f);h=Math.round(1.5*v.verticesFor(d));f=l._align(h,f);for(var g in this.tileBufferData.geometries[d].vertexBuffer)h=
this.tileBufferData.geometries[d].vertexBuffer[g].stride,a.geometries[d].vertexBuffer[g]={stride:h,data:u.allocateTypedArrayBuffer(f,h)}}n.reset();this.tileDisplayData.displayList.clear();for(e=0;e<c;++e){g=b[e];for(const k of g){if(k.meshData)k.writeMeshDataToBuffers(n.verticesFor(e),a.geometries[e].vertexBuffer,n.indicesFor(e),a.geometries[e].indexBuffer),k.meshData=null;else{g=this.tileBufferData.geometries[e].vertexBuffer;d=this.tileBufferData.geometries[e].indexBuffer;f=a.geometries[e].vertexBuffer;
h=a.geometries[e].indexBuffer;const p=n.verticesFor(e),m=n.indicesFor(e);u.copyMeshData(p,m,f,h,k,g,d);k.vertexFrom=p;k.indexFrom=m}n.needMore(e,k.vertexCount,k.indexCount)}}for(const k of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(k.displayRecords);this.tileBufferData=a};q.getStrides=function(){const b=[];for(let c=0;c<this.tileBufferData.geometries.length;++c){const a=this.tileBufferData.geometries[c];b[c]={};for(const d in a.vertexBuffer)b[c][d]=a.vertexBuffer[d].stride}return b};
q.clone=function(){const b=new l;b.tileBufferData=this.tileBufferData.clone();b.tileDisplayData=this.tileDisplayData.clone();return b};q._guessSize=function(){const {displayObjects:b}=this.tileDisplayData,c=Math.min(b.length,4);let a=0;for(let d=0;d<c;d++)a=Math.max(a,b[d].displayRecords.length);return 2*(12*b.length+b.length*a*40)};q.serialize=function(){const b=this.tileBufferData.serialize(),c=this.tileBufferData.getBuffers(),a=this.tileDisplayData.serialize(new G(Int32Array,this._guessSize())).buffer();
c.push(a);return{result:{displayData:a,bufferData:b},transferList:c}};l.fromVertexData=function(b,c){const a={},d=new Map;for(const f of c)d.set(f.id,f);u.forEachGeometryType(f=>{const h=b.data[f];if(B.isSome(h)){const g=D.DisplayRecordReader.from(h.records).getCursor();for(;g.next();){var e=g.id;const k=g.materialKey,p=g.indexFrom,m=g.indexCount,r=g.vertexFrom,x=g.vertexCount,H=d.get(e);e=new A(e,f,k);e.indexFrom=p;e.indexCount=m;e.vertexFrom=r;e.vertexCount=x;H.displayRecords.push(e)}a[f]=E.VertexBuffers.fromVertexData(h,
f)}else a[f]=(new F.VertexVectors(f,0,C.WGLSymbologyType.DEFAULT)).intoBuffers()});return l.fromMeshData({displayObjects:c,vertexBuffersMap:a})};l.fromMeshData=function(b){const c=new l,a=new z,d=new w;a.displayObjects=b.displayObjects;for(const f in b.vertexBuffersMap){const h=b.vertexBuffersMap[f];d.geometries[f].indexBuffer=h.indexBuffer;d.geometries[f].vertexBuffer=h.namedBuffers}c.tileDisplayData=a;c.tileBufferData=d;return c};l.bind=function(b,c){const a=new l;a.tileDisplayData=b;a.tileBufferData=
c;return a};l.create=function(b,c){const a=new l;a.tileDisplayData=new z;a.tileDisplayData.displayObjects=b;const d=[0,0,0,0,0],f=[0,0,0,0,0],h=[[],[],[],[],[]];for(var e of b)for(var g of e.displayRecords)h[g.geometryType].push(g),d[g.geometryType]+=g.meshData.vertexCount,f[g.geometryType]+=g.meshData.indexData.length;b=new w;c=[c.fill||{},c.line||{},c.icon||{},c.text||{},c.label||{}];for(e=0;5>e;e++){g=new Uint32Array(f[e]);var k=c[e],p=d[e];const m={};for(const r in k){const x={data:u.allocateTypedArrayBuffer(p,
k[r]),stride:k[r]};m[r]=x}k=m;A.writeAllMeshDataToBuffers(h[e],k,g);b.geometries[e]={indexBuffer:g,vertexBuffer:k}}a.tileBufferData=b;return a};l._align=function(b,c){const a=b%c;return 0===a?b:b+(c-a)};l._computeVertexAlignment=function(b){let c=!1,a=!1;for(const d of b)2===d%4?c=!0:0!==d%4&&(a=!0);return a?4:c?2:1};return l}();y.TileData=t;Object.defineProperties(y,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});