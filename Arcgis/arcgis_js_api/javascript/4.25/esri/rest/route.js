// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../chunks/_rollupPluginBabelHelpers ../request ../core/maybe ../geometry/support/normalizeUtils ./networkService ./utils ./route/utils ./support/FeatureSet ./support/RouteSolveResult".split(" "),function(z,C,D,x,E,p,F,G,u,H){function y(){y=C._asyncToGenerator(function*(g,c,f){var m=[],h=[],d={};const q={},v=F.parseUrl(g);({path:g}=v);c.stops instanceof u&&p.collectGeometries(c.stops.features,h,"stops.features",d);c.pointBarriers instanceof u&&p.collectGeometries(c.pointBarriers.features,
h,"pointBarriers.features",d);c.polylineBarriers instanceof u&&p.collectGeometries(c.polylineBarriers.features,h,"polylineBarriers.features",d);c.polygonBarriers instanceof u&&p.collectGeometries(c.polygonBarriers.features,h,"polygonBarriers.features",d);h=yield E.normalizeCentralMeridian(h);for(const k in d){const n=d[k];m.push(k);q[k]=h.slice(n[0],n[1])}if(p.isInputGeometryZAware(q,m)){d=null;try{d=yield p.fetchServiceDescription(g,c.apiKey,f)}catch{}d&&!d.hasZ&&p.dropZValuesOffInputGeometry(q,
m)}for(const k in q)q[k].forEach((n,w)=>{c.get(k)[w].geometry=n});f={...f,query:{...v.query,...G.routeParametersToQueryParameters(c),f:"json"}};m=g.endsWith("/solve")?g:`${g}/solve`;({data:f}=yield D(m,f));return I(f)});return y.apply(this,arguments)}function I(g){const {barriers:c,directionLines:f,directionPoints:m,directions:h,messages:d,polygonBarriers:q,polylineBarriers:v,routes:k,stops:n,traversedEdges:w,traversedJunctions:A,traversedTurns:J}=g,B=b=>{var a=l.find(e=>e.routeName===b);if(x.isSome(a))return a;
a={routeId:l.length+1,routeName:b};l.push(a);return a},t=b=>{var a=l.find(e=>e.routeId===b);if(x.isSome(a))return a;a={routeId:b,routeName:null};l.push(a);return a},l=[];k?.features.forEach((b,a)=>{b.geometry.spatialReference=k.spatialReference;l.push({routeId:a+1,routeName:b.attributes.Name,route:b})});h?.forEach(b=>{const {routeName:a}=b;B(a).directions=b});const K=(n?.features.every(b=>x.isNone(b.attributes.RouteName))??!1)&&0<l.length?l[0].routeName:null;n?.features.forEach(b=>{if(b.geometry){var a;
(a=b.geometry).spatialReference??(a.spatialReference=n.spatialReference)}a=B(K??b.attributes.RouteName);a.stops??(a.stops=[]);a.stops.push(b)});f?.features.forEach(b=>{const a=t(b.attributes.RouteID),{geometryType:e,spatialReference:r}=f;a.directionLines??(a.directionLines={features:[],geometryType:e,spatialReference:r});a.directionLines.features.push(b)});m?.features.forEach(b=>{const a=t(b.attributes.RouteID),{geometryType:e,spatialReference:r}=m;a.directionPoints??(a.directionPoints={features:[],
geometryType:e,spatialReference:r});a.directionPoints.features.push(b)});w?.features.forEach(b=>{const a=t(b.attributes.RouteID),{geometryType:e,spatialReference:r}=w;a.traversedEdges??(a.traversedEdges={features:[],geometryType:e,spatialReference:r});a.traversedEdges.features.push(b)});A?.features.forEach(b=>{const a=t(b.attributes.RouteID),{geometryType:e,spatialReference:r}=A;a.traversedJunctions??(a.traversedJunctions={features:[],geometryType:e,spatialReference:r});a.traversedJunctions.features.push(b)});
J?.features.forEach(b=>{const a=t(b.attributes.RouteID);a.traversedTurns??(a.traversedTurns={features:[]});a.traversedTurns.features.push(b)});return H.fromJSON({routeResults:l,barriers:c,polygonBarriers:q,polylineBarriers:v,messages:d})}z.solve=function(g,c,f){return y.apply(this,arguments)};Object.defineProperties(z,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});