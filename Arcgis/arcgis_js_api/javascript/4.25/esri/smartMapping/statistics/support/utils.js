// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("exports ../../../chunks/_rollupPluginBabelHelpers ../../../geometry ../../../core/Error ../../../core/maybe ../../../core/screenUtils ../../../geometry/SpatialReference ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/fieldUtils ../../../renderers/support/heatmapUtils ../../../statistics/utils ../../../support/arcadeOnDemand ../../../geometry/Point".split(" "),function(q,I,U,J,C,K,L,M,E,F,G,y,N,O){function D(){D=I._asyncToGenerator(function*(a,
b){if(!b)return[];const {field:c,field2:d,field3:f,fieldDelimiter:u}=a,n=a.valueExpression,e=a.normalizationType,k=a.normalizationField,g=a.normalizationTotal,p=[],h=a.viewInfoParams;let l=null,r=null;if(n){if(!x){const {arcadeUtils:w}=yield N.loadArcade();x=w}l=x.createFunction(n);r=h&&x.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new L(h.spatialReference)})}a=a.fieldInfos;const z=b[0]&&"declaredClass"in b[0]&&"esri.Graphic"===b[0].declaredClass||!a?null:{fields:a};b.forEach(w=>
{var t=w.attributes;if(n){var m=x.createExecContext(z?{...w,layer:z}:w,r);m=x.executeFunction(l,m)}else t&&(m=t[c],d&&(m=`${y.processNullValue(m)}${u}${y.processNullValue(t[d])}`,f&&(m=`${m}${u}${y.processNullValue(t[f])}`)));e&&"number"===typeof m&&isFinite(m)&&(t=t&&parseFloat(t[k]),m=y.getNormalizedValue(m,e,t,g));p.push(m)});return p});return D.apply(this,arguments)}function v(a,b){return new J(a,b)}function H(a,b){a=C.isSome(a)?a:"";C.isSome(b)&&b&&(a=a?"("+a+") AND ("+b+")":b);return a}function P(a){const b=
a.layer;return a.fields.filter(c=>!b.getField(c))}function Q(a){const b=a.layer;return a.fields.filter(c=>{c=b.getFieldUsageInfo(c);return!c||!c.supportsStatistics})}let x=null;q.calculateHeatmapStats=function(a,b=18,c,d,f,u){const n=new Float64Array(f*u);b=Math.round(K.pt2px(b));let e=Number.POSITIVE_INFINITY,k=Number.NEGATIVE_INFINITY;var g=0;let p=0,h=0,l=0;c=G.createValueFunction(d,c);for(const {geometry:z,attributes:w}of a){const {x:t,y:m}=z;a=Math.max(0,t-b);g=Math.max(0,m-b);d=Math.min(u,m+
b);const R=Math.min(f,t+b),S=+c(w);for(let A=g;A<d;A++)for(let B=a;B<R;B++){g=A*f+B;const T=G.evaluateDensityKernel(B-t,A-m,b);var r=n[g];g=n[g]+=T*S;r=g-r;p+=r;h+=r*r;g<e&&(e=g);g>k&&(k=g);l++}}return l?{mean:p/l,stdDev:Math.sqrt((h-p*p/l)/l),min:e,max:k,mid:(k-e)/2,count:l}:{mean:0,stddev:0,min:0,max:0,mid:0,count:0}};q.createError=v;q.getDataValues=function(a,b){return D.apply(this,arguments)};q.getRangeExpr=function(a,b,c){b=null!=b?a+" \x3e\x3d "+b:"";a=null!=c?a+" \x3c\x3d "+c:"";c="";return(c=
b&&a?H(b,a):b||a)?"("+c+")":""};q.getSQLFilterForNormalization=function(a){const b=a.field,c=a.normalizationType;a=a.normalizationField;let d;if("field"===c)d="(NOT "+a+" \x3d 0)";else if("log"===c||"natural-log"===c||"square-root"===c)d=`(${b} > 0)`;return d};q.getSumOfAttributesExpr=function(a,b,c){const d=[],f=[],u=[],n=[],e=[];a.forEach((p,h)=>{const l=p.field?"field":"expression",r=p.field||p.valueExpression;p.field?(e.push(r),f.push(`var ${l}${h} = Number($feature["${r}"]);`)):(d.push(`function getValueForExpr${h}() {\n  ${r} \n}`),
f.push(`var ${l}${h} = Number(getValueForExpr${h}());`));c||u.push(`${l}${h} = IIf(${l}${h} < 0, 0, ${l}${h});`);n.push(`${l}${h}`)});a="return sum;";const k=d.length?null:e.reduce((p,h)=>`${p} + ${h}`);let g=null;b||c?b?c||(a="return IIf(sum \x3e\x3d 0, sum, null);",k&&(g=`(( ${k} ) >= 0)`)):(a="return IIf(sum !\x3d 0, sum, null);",k&&(g=`(( ${k} ) <> 0)`)):(a="return IIf(sum \x3e 0, sum, null);",k&&(g=`(( ${k} ) > 0)`));return{valueExpression:[d.length?d.join("\n"):"",f.join("\n"),u.join("\n"),
`var sum = ${n.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:k,sqlWhere:g}};q.mergeWhereClauses=H;q.quantizeFeatures=function(a,b,c,d){const f=E.isWrappable(c)?E.getInfo(c):null,u=f?Math.round((f.valid[1]-f.valid[0])/b.scale[0]):null;return a.map(n=>{const e=new O(C.unwrap(n.geometry));M.quantizePoint(b,e,e,e.hasZ,e.hasM);if(f){var k=d[0];0>e.x?e.x+=u:e.x>k&&(e.x-=u)}n.geometry=e;return n})};q.verifyBasicFieldValidity=function(a,b,c){const d=P({layer:a,fields:b});if(d.length)return v(c,
"Unknown fields: "+d.join(", ")+". You can only use fields defined in the layer schema");a=Q({layer:a,fields:b});if(a.length)return v(c,"Unsupported fields: "+a.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true")};q.verifyFieldType=function(a,b,c,d){let f=null;b?b.name!==a.objectIdField&&d.includes(b.type)||(f=v(c,"'field' should be one of these types: "+d.join(","))):f=v(c,"'field' is not defined in the layer schema");return f};q.verifyFilterValidty=
function(a,b){if(a&&"intersects"!==a.spatialRelationship)return v(b,"Only 'intersects' spatialRelationship is supported for featureFilter")};q.verifyNumericField=function(a,b,c){let d;b?b.name!==a.objectIdField&&F.isNumericField(b)||(d=v(c,"'field' should be one of these numeric types: "+F.numericTypes.join(","))):d=v(c,"'field' is not defined in the layer schema");return d};Object.defineProperties(q,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});