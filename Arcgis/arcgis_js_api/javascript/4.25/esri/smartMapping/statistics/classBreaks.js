// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/maybe ./support/utils ../support/binningUtils ../support/utils ../support/adapters/support/layerUtils".split(" "),function(q,b,w,g,x,r,f){function y(a){return h.apply(this,arguments)}function h(){h=q._asyncToGenerator(function*(a){if(!a||!a.layer||!a.field&&!a.valueExpression)throw new b("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(a.valueExpression&&!a.view)throw new b("class-breaks:missing-parameters",
"View is required when 'valueExpression' is specified");a.forBinning&&x.verifyBinningParams(a,"class-breaks");const {layer:k,...l}=a;var d=a.forBinning?f.binningCapableLayerTypes:f.featureCapableLayerTypes,c=f.createLayerAdapter(k,d,a.forBinning);a={layerAdapter:c,...l};a.normalizationType=r.getNormalizationType(a);a.numClasses=a.numClasses||5;if(!c)throw new b("class-breaks:invalid-parameters","'layer' must be one of these types: "+f.getLayerTypeLabels(d).join(", "));d=w.isSome(a.signal)?{signal:a.signal}:
null;yield c.load(d);var e=a.field;d=a.minValue;const m=a.maxValue,z=null!=d||null!=m,t=a.classificationMethod,u="percent-of-total"===a.normalizationType,v=!1!==a.analyzeData;e=e?c.getField(e):null;var n=yield r.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression});if(n=g.verifyBasicFieldValidity(c,n,"class-breaks:invalid-parameters"))throw n;if(e&&(c=g.verifyNumericField(c,e,"class-breaks:invalid-parameters")))throw c;if(a.valueExpression&&a.normalizationType)throw new b("class-breaks:invalid-parameters",
"Normalization is not allowed when 'valueExpression' is specified");if(z)if(v){if(u&&null==a.normalizationTotal)throw new b("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified");}else{if(null==d||null==m)throw new b("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(d>=m)throw new b("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");
if(t&&"equal-interval"!==t)throw new b("class-breaks:invalid-parameters","'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(u&&null==a.normalizationTotal)throw new b("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false");}else if(!v)throw new b("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(c=g.verifyFilterValidty(a.filter,
"class-breaks:invalid-parameters"))throw c;return a});return h.apply(this,arguments)}function p(){p=q._asyncToGenerator(function*(a){const {layerAdapter:k,...l}=yield y(a);return k.classBreaks(l)});return p.apply(this,arguments)}return function(a){return p.apply(this,arguments)}});