// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../Graphic ../../../core/arrayUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/reactiveUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../layers/support/fieldType ../../../layers/support/fieldUtils ../../../rest/support/FeatureSet ../../statistics/support/statsWorker ../../statistics/support/WorkerClient ../utils ./FeatureLayerAdapter ./LayerAdapter ./support/utils ../../../statistics/utils".split(" "),
function(r,A,B,C,p,x,u,H,I,w,J,K,D,E,v,L,F,M,N,t,O){w=function(G){function y(b){return G.call(this,b)||this}r._inheritsLoose(y,G);var k=y.prototype;k.destroy=function(){this._featureLayerAdapter=null;this.workerClient?.destroy()};k._hasCachedStatistics=function(b){return this.layer.hasCachedStatistics(b)};k._updateQuery=function(b,a=[],c=[]){if(!c.length)return b;const d=this.layer.objectIdField;b=b.clone();a=a.filter(e=>{e=this.layer.getField(e);return!c.includes(e.name)});const f=a.some(e=>this.layer.getField(e).name===
d);b.outFields=f?a:[...a,d];return b};k._fetchFeaturesFromMemory=function(){var b=r._asyncToGenerator(function*(a,c,d){if(!a)throw new p("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const f=yield a.whenLayerView(this.layer);var e=new AbortController;a=e.signal;const g=H.whenOnce(()=>!f.updating,a);yield u.timeout(g,5E3,e);e=t.getMissingFields(this,d,f);u.throwIfAborted(a);c=this._updateQuery(c,d,e);c=yield f.queryFeatures(c,{signal:a});u.throwIfAborted(a);
a=c.features;return e.length?f.whenGraphicAttributes(a,e):a});return function(a,c,d){return b.apply(this,arguments)}}();k._fetchFeaturesJSONFromMemory=function(){var b=r._asyncToGenerator(function*(a,c,d){return this._fetchFeaturesFromMemory(a,c,d).then(t.ensureFeaturesJSON)});return function(a,c,d){return b.apply(this,arguments)}}();k._fetchFeaturesForStats=function(b,a){return F.getFieldsList({field:b.field,normalizationField:b.normalizationField,valueExpression:b.valueExpression}).then(c=>this.getSampleFeatures({sampleSize:-1,
view:b.view,returnGeometry:b.returnGeometry,requiredFields:c,signal:b.signal},a))};k._processStatsFromMemoryParams=function(){var b=r._asyncToGenerator(function*(a){const c=a.features;if(c?.length)return c.length&&"declaredClass"in c[0]&&"esri.Graphic"===c[0].declaredClass?{graphics:c}:{featuresJSON:c};const {view:d,field:f,normalizationField:e,valueExpression:g,signal:l}=a;a=yield this._fetchFeaturesForStats({field:f,valueExpression:g,normalizationField:e,view:d,signal:l});if(!a?.length)throw new p("scene-layer-adapter:insufficient-data",
"No features are available to calculate statistics");return{graphics:a}});return function(a){return b.apply(this,arguments)}}();k._generateFeatureSetForCachedHistogram=function(b,a=b.minimum,c=b.maximum,d){const f=[];for(var e=0;e<d;e++)f[e]=0;e=b.counts.length;const g=b.minimum,l=b.maximum;for(let n=0;n<e;n++){var h=(n+.5)/e;h=((1-h)*g+h*l-a)/(c-a)*d;0<=h&&h<=d&&(f[h===d?d-1:Math.floor(h)]+=b.counts[n])}const m=[];f.forEach((n,q)=>{const z=new B({attributes:{}});z.attributes.EXPR_1=q+1;z.attributes.countOFExpr=
n;m.push(z)});b=new E;b.features=m;return b};k._getCachedStatistics=function(b,a){const c=this.layer;return b.valueExpression||b.sqlExpression||b.sqlWhere||b.minValue||b.maxValue?Promise.reject(new p("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):c.queryCachedStatistics(a&&a.name,{signal:b.signal}).then(d=>{d=d.stats;const {min:f,max:e,totalValuesCount:g}=d;let {avg:l,
stddev:h,sum:m,variance:n,count:q}=d;if(0!==f||0!==e)l=0===l?null:l,m=0===m?null:m,h=0===h?null:h,n=0===n?null:n,q=0===q?null:q;null==q&&(null!=m&&null!=l?q=Math.round(m/l):null!=g&&(q=g));return{avg:l,count:q,max:e,min:f,stddev:h,sum:m,variance:n}})};k._getNormalizationTotal=function(){var b=r._asyncToGenerator(function*(a,c,d){a=(c?yield this.workerClient.summaryStatistics({field:a},c):yield v.summaryStatistics({attribute:{field:a},features:d})).sum;if(null==a)throw new p("scene-layer-adapter:invalid",
"invalid normalizationTotal");return a});return function(a,c,d){return b.apply(this,arguments)}}();k._getSummaryStatisticsFromMemory=function(){var b=r._asyncToGenerator(function*(a,c){const {view:d,field:f,normalizationField:e,valueExpression:g}=a,{featuresJSON:l,graphics:h}=yield this._processStatsFromMemoryParams(a),m={field:f,valueExpression:g,normalizationType:a.normalizationType,normalizationField:e,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue};a.valueExpression&&
d&&l&&(m.fieldType=c?.type?K.kebabDict.toJSON(c.type):null,m.viewInfoParams=t.getViewInfoParams(d));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(m.normalizationTotal=yield this._getNormalizationTotal(f,l,h));return l?this.workerClient.summaryStatistics(m,l):v.summaryStatistics({attribute:m,features:h})});return function(a,c){return b.apply(this,arguments)}}();k._getCachedStatisticsForUniqueValues=function(b,a){const c=this.layer,d=a&&a.name,f=a&&this.getFieldDomain(b.field);
return b.valueExpression||b.sqlExpression||b.sqlWhere?Promise.reject(new p("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):c.queryCachedStatistics(d,{signal:b.signal}).then(e=>{var g=e.stats;if(!g.mostFrequentValues)throw Error();e=e.labels&&e.labels.labels;const l={},h=[],m="countOF"+d;g.mostFrequentValues.forEach(n=>{const q=new B({attributes:{}});q.attributes[d]=a&&a.name!==c.objectIdField&&
(D.isNumericField(a)||D.isDateField(a))?Number(n.value):n.value;q.attributes[m]=n.count;h.push(q)});e&&e.forEach(n=>{l[n.value]=n.label});g=new E;g.features=h;return t.getUniqueValuesFromFeatureSet(g,{layer:this,field:b.field,labels:l,view:b.view,signal:b.signal})}).then(e=>O.createUVResult(e,[f],b.returnAllCodedValues))};k._getUniqueValuesFromMemory=function(){var b=r._asyncToGenerator(function*(a,c){const {view:d,field:f,field2:e,field3:g,valueExpression:l,returnAllCodedValues:h}=a;c={field:f,field2:e,
field3:g,fieldDelimiter:F.FIELD_DELIMITER,valueExpression:l,domains:c,returnAllCodedValues:h};const {featuresJSON:m,graphics:n}=yield this._processStatsFromMemoryParams(a);a.valueExpression&&d&&m&&(c.viewInfoParams=t.getViewInfoParams(d));return m?this.workerClient.uniqueValues(c,m):v.uniqueValues({attribute:c,features:n})});return function(a,c){return b.apply(this,arguments)}}();k._getCachedStatisticsForHistogram=function(b,a){const c=this.layer;return b.valueExpression||b.sqlExpression||b.sqlWhere||
b.normalizationType?Promise.reject(new p("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):c.queryCachedStatistics(a&&a.name,{signal:b.signal}).then(d=>{var f=d.stats;const {minValue:e,maxValue:g}=b;d=null!=e?e:f.min;const l=null!=g?g:f.max,h=b.numBins||10;f=this._generateFeatureSetForCachedHistogram(f.histogram,d,l,h);return t.getHistogramFromFeatureSet(f,d,l,h)})};
k._getClassBreaksFromMemory=function(){var b=r._asyncToGenerator(function*(a){const {view:c,field:d,normalizationField:f,valueExpression:e}=a,{featuresJSON:g,graphics:l}=yield this._processStatsFromMemoryParams(a),h={field:d,valueExpression:e,normalizationType:a.normalizationType,normalizationField:f,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numClasses:a.numClasses};
a.valueExpression&&c&&g&&(h.viewInfoParams=t.getViewInfoParams(c));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(h.normalizationTotal=yield this._getNormalizationTotal(d,g,l));return g?this.workerClient.classBreaks(h,g):v.classBreaks({attribute:h,features:l})});return function(a){return b.apply(this,arguments)}}();k._getHistogramFromMemory=function(){var b=r._asyncToGenerator(function*(a){const {view:c,field:d}=a,{featuresJSON:f,graphics:e}=yield this._processStatsFromMemoryParams(a),
g={field:d,valueExpression:a.valueExpression,normalizationType:a.normalizationType,normalizationField:a.normalizationField,normalizationTotal:a.normalizationTotal,minValue:a.minValue,maxValue:a.maxValue,standardDeviationInterval:a.standardDeviationInterval,classificationMethod:a.classificationMethod,numBins:a.numBins};a.valueExpression&&c&&f&&(g.viewInfoParams=t.getViewInfoParams(c));"percent-of-total"===a.normalizationType&&null==a.normalizationTotal&&(g.normalizationTotal=yield this._getNormalizationTotal(d,
f,e));return f?this.workerClient.histogram(g,f):v.histogram({attribute:g,features:e})});return function(a){return b.apply(this,arguments)}}();k.getField=function(b=""){return this.layer.getField(b)};k.getFieldUsageInfo=function(b){b=this.getField(b);if(!b)return null;b=this.layer.getFieldUsageInfo(b.name);return{supportsLabelingInfo:b.supportsLabelingInfo,supportsPopupTemplate:b.supportsPopupTemplate,supportsRenderer:b.supportsRenderer,supportsLayerQuery:b.supportsLayerQuery,supportsStatistics:!0}};
k.getFieldDomain=function(b,a){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(b,a):null};k.summaryStatistics=function(b){const a=this.getField(b.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.summaryStatistics(b);if(b.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");return this._hasCachedStatistics(a&&a.name)?this._getCachedStatistics(b,a).catch(()=>{u.throwIfAborted(b.signal);return this._getSummaryStatisticsFromMemory(b,
a)}):this._getSummaryStatisticsFromMemory(b,a)};k.uniqueValues=function(){var b=r._asyncToGenerator(function*(a){if(this._featureLayerAdapter)return this._featureLayerAdapter.uniqueValues(a);if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");const c=yield t.getDomainsForFields(a,this),{field:d,field2:f}=a,e=d&&f,g=this.getField(d);return!e&&this._hasCachedStatistics(g&&g.name)?this._getCachedStatisticsForUniqueValues(a,g).catch(()=>{u.throwIfAborted(a.signal);return this._getUniqueValuesFromMemory(a,
c)}):this._getUniqueValuesFromMemory(a,c)});return function(a){return b.apply(this,arguments)}}();k.histogram=function(b){const a=this.getField(b.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.histogram(b);if(b.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");return this._hasCachedStatistics(a&&a.name)?this._getCachedStatisticsForHistogram(b,a).catch(()=>{u.throwIfAborted(b.signal);return this._getHistogramFromMemory(b)}):this._getHistogramFromMemory(b)};
k.classBreaks=function(b){const a=this.getField(b.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.classBreaks(b);if(b.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");return this._hasCachedStatistics(a&&a.name)?Promise.reject(new p("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(b)};k.queryFeatureCount=function(b){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(b):Promise.reject(new p("scene-layer-adapter:not-supported",
"SceneLayer without associated FeatureLayer does not support count query"))};k.generateRenderer=function(b,a){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(b,a):Promise.reject(new p("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))};k.heatmapStatistics=function(b){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(b):Promise.reject(new p("scene-layer-adapter:not-supported",
"SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))};k.predominantCategories=function(){var b=r._asyncToGenerator(function*(a){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(a);throw new p("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories");});return function(a){return b.apply(this,arguments)}}();k.getSampleFeatures=function(){var b=r._asyncToGenerator(function*(a,
c){if(a.filter)throw new p("scene-layer-adapter:not-supported","filter is not supported");const {view:d,sampleSize:f,requiredFields:e,returnGeometry:g,signal:l}=a;var h="json"===c;const m=this.layer.createQuery();m.outFields=e;m.returnGeometry=!!g;m.where=null;m.num=f;let n=[];try{if(n=h?yield this._fetchFeaturesJSONFromMemory(d,m,e):yield this._fetchFeaturesFromMemory(d,m,e),n.length&&0<f&&f<=n.length)return C.pickRandom(n,f,1)}catch(q){u.throwIfAborted(l)}h=null;this._featureLayerAdapter&&(a={...a},
delete a.view,h=yield this._featureLayerAdapter.getSampleFeatures(a,c));return h&&h.length?h:C.pickRandom(n,n.length,1)});return function(a,c){return b.apply(this,arguments)}}();k.load=function(b){var a=this;const c=this.layer.load(b).then(function(){var d=r._asyncToGenerator(function*(f){a.workerClient=L.WorkerClient.getInstance();yield a.workerClient.open(x.unwrap(x.unwrap(b).signal));const e=f.associatedLayer;a.geometryType=f.geometryType;if(x.isSome(e))return a._featureLayerAdapter=new M({layer:e}),
a._featureLayerAdapter.load(b).then(()=>{a.objectIdField=a._featureLayerAdapter.objectIdField;a.supportsSQLExpression=a._featureLayerAdapter.supportsSQLExpression;a.minScale=a._featureLayerAdapter.minScale;a.maxScale=a._featureLayerAdapter.maxScale;a.fullExtent=a._featureLayerAdapter.fullExtent});a.objectIdField=f.objectIdField;a.supportsSQLExpression=!1;a.hasQueryEngine=!1;a.fullExtent=f.fullExtent});return function(f){return d.apply(this,arguments)}}());this.addResolvingPromise(c);return Promise.resolve(this)};
return y}(N);A.__decorate([I.property({constructOnly:!0})],w.prototype,"layer",void 0);return w=A.__decorate([J.subclass("esri.smartMapping.support.adapters.SceneLayerAdapter")],w)});