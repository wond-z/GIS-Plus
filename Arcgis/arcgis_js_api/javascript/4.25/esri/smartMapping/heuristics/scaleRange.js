// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.25/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/maybe ../../geometry/support/scaleUtils ../statistics/spatialStatistics ../support/binningUtils ../support/adapters/support/layerUtils".split(" "),function(r,l,w,t,x,y,m){function z(a){return p.apply(this,arguments)}function p(){p=r._asyncToGenerator(function*(a){const {view:b,sampleSize:e}=a;if(!(a&&b&&a.layer))throw new l("scale-range:missing-parameters","'view' and 'layer' parameters are required");a.forBinning&&y.verifyBinningParams(a,
"scale-range");const {layer:f,...h}=a;var g=a.forBinning?m.binningCapableLayerTypes:m.featureCapableLayerTypes;a=m.createLayerAdapter(f,g,a.forBinning);const k={layerAdapter:a,...h};k.sampleSize=e||500;if(!a)throw new l("scale-range:invalid-parameters","'layer' must be one of these types: "+m.getLayerTypeLabels(g).join(", "));yield b.when();g=w.isSome(k.signal)?{signal:k.signal}:null;yield a.load(g);return k});return p.apply(this,arguments)}function u(a,b,e=!0){if(a.constraints&&"effectiveLODs"in
a.constraints){a=a.constraints.effectiveLODs;a=e?a:a.slice(0).reverse();let f=null;for(const h of a)if(!(e?h.scale>b:h.scale<b)){f=h;break}return f}}function q(){q=r._asyncToGenerator(function*(a){var b,e=yield z(a);const {view:f,sampleSize:h,layerAdapter:g,signal:k}=e;a=yield g.getSampleFeatures({view:f,sampleSize:h,returnGeometry:!0,signal:k});if(!a?.length)throw new l("scale-range:insufficient-info","No features are available to calculate statistics");a=yield x({features:a,geometryType:g.geometryType});
var c=null,d=null;let n=b=null;switch(g.geometryType){case "point":case "multipoint":c=a.avgMinDistance;d=12;b=a.minDistance;n=320;break;case "polyline":c=a.avgLength;d=30;b=a.minLength;n=320;break;case "polygon":c=a.avgSize,d=15,b=a.minSize,n=640}b=0<b?b/n:null;c=t.getScaleForResolution(0<c?c/d:null,f.spatialReference);d=t.getScaleForResolution(b,f.spatialReference);const {minScale:A,maxScale:B}={minScale:c,maxScale:d};c=A;d=B;const {view:v,snapToLOD:C,layerAdapter:D}=e;C&&(e=u(v,c),b=u(v,d,!1),
c=e?e.scale:c,d=b?b.scale:d);if(c<d)throw new l("scale-range:invalid","calculated minScale is less than maxScale.");d>c/2&&(d=Math.floor(d/2));1E8<c&&(c=0);"polygon"!==D.geometryType&&(d=0);return{minScale:Math.ceil(c),maxScale:Math.floor(d),spatialStatistics:a}});return q.apply(this,arguments)}return function(a){return q.apply(this,arguments)}});